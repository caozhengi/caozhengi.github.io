<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Uiideas Blog">
<meta property="og:url" content="http://caozhengi.github.io/page/2/index.html">
<meta property="og:site_name" content="Uiideas Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uiideas Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Uiideas Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?559798d21c881907a6a2339e025bbc03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Uiideas Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章列表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/Linux-笔记/" itemprop="url">
                  Linux-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-14T15:47:52+08:00" content="2016-05-14">
              2016-05-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文为学习Linux的笔记，主要内容来自<a href="http://cn.linux.vbird.org/" target="_blank" rel="external">鸟哥的Linux私房菜</a>，也有一些视频和各处零零碎碎的文章，随着学习和使用内容也会慢慢的更新，笔记里面的内容主要是对学到知识点的梳理和备忘，建议大家查看原版，这样会对Linux有个更清晰完整的认识。</p>
<h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><pre><code>touch    修改文件的访问时间和修改时间  也可用来创建文件
chown    改变文件拥有者和所在用户组
chgrp    改变文件所属群组
chmod    改变文件的权限, SUID, SGID, SBIT等等的特性
chattr   配置文件隐藏属性
lsattr   显示文件隐藏属性

dd       转换和复制文件命令  可用来复制iso到U盘
    if     input file  也可以是装置喔！
    of     output file 也可以是装置；
    bs     规划的一个 block 的大小，若未指定则默认是 512 bytes(一个 sector 的大小)
    count  多少个 bs 的意思
    dd if=input_file of=output_file bs=block_size count=number
    time dd if=/dev/zero of=test.dbf bs=1M count=100 oflag=direct  测试IO写入速度
</code></pre><h2 id="文件查看命令"><a href="#文件查看命令" class="headerlink" title="文件查看命令"></a>文件查看命令</h2><pre><code>file      查看文件类型
cat       由第一行开始显示文件内容
tac       从最后一行开始显示，可以看出 tac 是 cat 的倒著写！
nl        显示的时候，顺道输出行号！

more  一页一页的显示文件内容
    space            代表向下翻一页；
    Enter            代表向下翻『一行』；
    /str             代表在这个显示的内容当中，向下搜寻str这个关键字；
    :f               立刻显示出档名以及目前显示的行数；
    q                代表立刻离开 more ，不再显示该文件内容。
    b or [ctrl]-b    代表往回翻页，不过这动作只对文件有用，对管线无用。

less  与more类似，但是比more更好的是，他可以往前翻页！
    space            向下翻动一页
    [pagedown]       向下翻动一页
    [pageup]         向上翻动一页
    /str             向下搜寻str的功能
    ?str             向上搜寻str的功能
    n                重复前一个搜寻 (与 / 或 ? 有关！)
    N                反向的重复前一个搜寻 (与 / 或 ? 有关！)
    q                离开 less 这个程序

printf  格式化输出内容
    \a    警告声音输出
    \b    倒退键(backspace)
    \f    清除萤幕 (form feed)
    \n    输出新的一行
    \r    亦即 Enter 按键
    \t    水平的 [tab] 按键
    \v    垂直的 [tab] 按键
    \xNN  NN 为两位数的数字，可以转换数字成为字节。关於 C 程序语言内，常见的变量格式
    %ns   那个 n 是数字， s 代表 string ，亦即多少个字节；
    %ni   那个 n 是数字， i 代表 integer ，亦即多少整数码数；
    %N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数码数，
          假设我共要十个位数，但小数点有两位，即为 %10.2f ！

    printf &apos;%s\t %s\t %s\t %s\t %s\t \n&apos; $(cat printf.txt)

awk      逻辑运算字节

head     只看头几行
tail     只看尾巴几行
od       以二进位的方式读取文件内容！

diff  文件比较工具  以行来比对
    -b   忽略一行当中，仅有多个空白的差异(例如 &quot;about me&quot; 与 &quot;about     me&quot; 视为相同
    -B   忽略空白行的差异。
    -i   忽略大小写的不同。

patch    命令可以将旧版数据升级到新版 (主要亦由 diff 创建 patch 的补丁来源文件)

cmp   以位组来比对文件  通常比对二进制文件

通配符
    *       代表 0 个到无穷多个任意字符
    ?       代表一定有一个任意字符
    [ ]     例如 [abcd] 代表a, b, c, d 这四个任何一个
    [-]     [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！
    [^ ]    反向选择，例如 [^abc] 代表非 a, b, c 的其他字符就接受的意思。
    ll -d /etc/cron*    /etc/底下以 cron 为开头的档名
    ll -d /etc/?????    /etc/底下文件名『刚好是五个字母』的文件名
    ll -d /etc/*[0-9]*  /etc/底下文件名含有数字的文件名
    ll -d /etc/[^a-z]*  /etc/底下，档名开头非为小写字母的文件名：

echo [选项] [输出内容]  把指定内容输出到屏幕上
    -e  支持控制字符
        \a     警告音
        \b     退格键
        \n     换行键
        \r     回车键
        \t     制表键
        \v     垂直制表键
        \0nnn     按照8进制ASCII码输出字符    nnn是三位8进制数字
        \xhh       按照16进制ASCII码输出字符          hh是两位16进制数
    echo -e &quot;\e[1;34m 天上掉下个林妹妹！\e[0m&quot;   通过颜色输出字符
</code></pre><h2 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h2><pre><code>mkdir     创建目录      -p   可创建子目录

ls        查看目录
    -l    详细内容
    －h   人性化文件大小
    /etc/DIR_COLORS or ~/.dir_colors 颜色配置文件
    其中第一个字符的含义
        d   目录
        -   文件
        l   示为连结档(link file)；
        b   示为装置文件里面的可供储存的接口设备(可随机存取装置)；
        c   示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)
        s   数据接口文件(sockets)：
        p   数据输送文件(FIFO, pipe) first-in-first-out  主要的目的在解决多个程序同时存取一个文件所造成的错误问题

tree      以树形借口显示文件
rm        删除目录      -rf  强制删除子目录和文件
mv        移动目录,可以重命名目录或文件
ln        创建链接文件, -s创建软链接, 硬链接指向同一i节点盒block数据块, 软链接和windows的快捷方式类似
</code></pre><h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><pre><code>locate    搜索后台数据库中的文件  数据库每天一更新 /var/lib/mlocate
updatedb  更新locate命令的数据库

whereis   搜索命令的命令所在位置和帮助文件   可搜索命令的文字
which     搜索命令所在位置 和 别名
find      搜索文件，可按 时间 所有者 大小 i节点等
    find /var/log -size -1k -exec ls -lh {} \;   对搜索结果使用第二条命令来处理   -exec {} \;  为固定组合
</code></pre><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre><code>man      查看命令的帮助文档  manual的缩写
    /-d              搜索帮助文档中包含-d的行  n下一个  N 上一个
    man man          可查看帮助级别的意义
    man -f passwd    查看passwd命令的帮助级别   相当于 whatis passwd
    man 1 passwd     获取命令级别为1的帮助
    man -k passwd    查看所有帮助文档中包含passwd关键字的命令的帮助   相当于 apropos  passwd

--help   获取选项帮助
help     获取内部命令的帮助，可通过whereis来判断命令是否内部命令，无执行文件则内部命令
info     在系统帮助文档内检索命令的帮助信息
</code></pre><h2 id="压缩和解压缩命令"><a href="#压缩和解压缩命令" class="headerlink" title="压缩和解压缩命令"></a>压缩和解压缩命令</h2><pre><code>zip  压缩后的文件名 源文件
    zip example.zip example
    -r 压缩目录

unzip  解压目录

gzip  压缩文件为gz格式  压缩完文件会消失
    gzip example
    gzip -c example &gt; example.gz  压缩文件不让原文件消失
    gzip -r example               压缩目录内的全部子文件
    gzip -d example.gz            解压缩文件
    gunzip example.gz             解压缩文件

bzip2  压缩文件为bz2文件格式 不能压缩目录
    bzip2 example          压缩example文件不保留原文件
    bzip2 -k example       压缩example文件,保留原文件
    bzip2 -d example.bz2   解压缩文件
    bunzip2 example.bz2    解压缩文件
    bunzip2 -k example.bz2 解压缩文件 保留原文件

tar  打包命令
    -c   打包
    -v   显示过程
    -f   指定打包后的文件名
    -x   解打包
    -z   压缩为 .tar,gz 格式
    -j   压缩或者解压为.tar.bz2格式
    -t   测试压缩包  只查看 不解压
    -C   指定解压目录
    tar -cvf example.tar example  打包文件或目录为一个文件包
    tar -xvf example.tar  解打包一个包文件
    tar -zcvf example.tar.gz example  打包并压缩文件为.tar.gz格式的压缩文件包
    tar -zcvf /tmp/example.tar.gz example  example2 打包并压缩example example1两个文件到/tmp/目录
    tar -zxvf example.tar.gz  解压缩一个.tar.gz的文件压缩包
    tar -jcvf example.tar.bz2 example  打包并压缩文件为.tar.gz格式的压缩文件包
    tar -jxvf example.tar.bz2  解压缩一个.tar.bz2的文件压缩包
    tar -jxvf example.tar.bz2  -C /tmp/ 解压缩一个.tar.bz2的文件压缩包到/tmp/目录下
</code></pre><h2 id="关机和重启命令"><a href="#关机和重启命令" class="headerlink" title="关机和重启命令"></a>关机和重启命令</h2><pre><code>shutdown [选项] 时间    关机或者重启命令
    -h  关机
    -r  重启
    -c  取消前一个关机命令
    shutdown -r 05:30  凌晨05:30重启
    shutdown -r 05:30  &amp;  在后台执行重启命令

其他关机命令   不如shutdown安全   shutdown可在关机重启前保存服务
    halt
    poweroff
    init 0

其他重启命令
    reboot
    init 6  调用系统运行级别
        0 关机
        1 单用户  启动最小程序  类似安全模式
        2 不完全多用户  不含NFS服务  NFS为文件共享服务
        3 完全多用户  正常字符界面
        4 未分配
        5 图形界面
        6 重启
    runlevel 查看当前系统级别  N 3   N是当前级别之前的级别为null  3为当前级别
        /etc/inittab 可定义系统默认启动级别

    logout 退出登入
</code></pre><h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><pre><code>mount 挂载命令  查看挂载设备
    -a  依据配置文件 /etc/fstab 的内容，自动挂载
    mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载名

umount ［设备文件名 或 挂载点］  卸载设备

挂载光盘
    mkdir /mnt/cdrom 建立挂载点
    mount -t iso9660 /dev/sr0 /mnt/cdrom  挂载命令

挂载ISO镜像文件
    mount -o loop /root/centos5.2_x86_64.iso /mnt/centos_dvd

卸载光盘
    umount /mnt/cdrom

挂载U盘
    fdisk -l 查看系统中已经存在的硬盘
    mount -t vfat /dev/sda1 /mnt/usb/   vaft:fat32系统   sda1:通过fdisk查出来的
    ntfs-3g 安装后支持ntfs  只读不可写入数据

系统启动自动挂载
    vi /etc/fstab
        # Device  Mount point  filesystem  parameters  dump  fsck
        Device           磁盘装置文件名或该装置的Label
        Mount point      挂载点 为目录
        filesystem       磁盘分区槽的文件系统
        parameters       文件系统参数
            async/sync     异步/同步
            auto/noauto    自动/非自动
            rw/ro          可擦写/只读
            exec/noexec    可运行/不可运行
            user/nouser    允许/不允许使用者挂载
            suid/nosuid    具有/不具有 suid 权限
            usrquota       启动 filesystem 支持磁盘配额模式
            grpquota       启动 filesystem 对群组磁盘配额模式的支持。
            defaults       同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。
        dump            0代表不做dump备份， 1代表要每天进行dump备份。 2代表其他不定日期的 dump 备份动作。
        fsck            是否要以fsck检验该filesystem喔。 0是不检验， 1 表示最早检验， 2也是要检验，
</code></pre><h2 id="用户登入查看命令"><a href="#用户登入查看命令" class="headerlink" title="用户登入查看命令"></a>用户登入查看命令</h2><pre><code>w 查看用户登入信息
    USER   :  登入的用户名
    TTY    :  登入终端
    FROM   :  从哪个IP地址登入
    LOGIN@ :  登入时间
    IDLE   :  用户闲置时间
    JCPU   :  和该终端连接的所有进程占用的时间，不包括过去后台作业时间，但包括当前正在运行的后台作业所占用时间
    PCPU   :  当前进程所占用的时间
    WHAT   :  当前正在运行的命令

who 查看当前登入用户 无法查看系统占用
last 查看当前登入和过去登入的用户信息 (实际是查看 /var/log/wtmp 文件  二进制文件 不可直接操作)
    命令输出 用户名，登入终端，登入IP，登入时间，退出时间

lastlo 查看系统所有用户的登入时间  读取/var/log/lastlog 文件
    命令输出 用户名，登入终端，登入IP，最后一次登入时间
</code></pre><h2 id="SHELL-基础"><a href="#SHELL-基础" class="headerlink" title="SHELL 基础"></a>SHELL 基础</h2><pre><code>echo $SHELL       打印出来当前使用的shell版本
vi /ect/shells    查看当前系统支持的shell
sh                切换成sh shell，通过exit 退出

执行脚本
    bash xxx.sh   未设置权限时候可通过bash命令执行脚本
    chmod 755 xxx.sh   设置脚本的权限为可执行
    ./xxx.sh  或  /xxx/xxx.sh   绝对路径或相对路径来执行脚本

bash基本功能
    alias     查看系统中默认已经生效的别名
    alias ls=“ls -color=never”  设置命令的别名  临时生效
    unalias   删除别名  临时删除

历史命令
    history   查看历史命令
    history -w   保存历史命令到历史命令保存文件中
    history -c   清空历史命令
    vi ~/.bash_history     查看历史纪录命令的保存文件  保存有上次正确注销前的历史命令
    历史命令默认保存1000条  可在环境变量配置文件/etc/profile中修改
    !n    执行第n条历史命令
    !!    重复执行上一条命令
    !xx   重复执行最后一次以xx开头的命令

输出重定向
    &gt;      以覆盖的方法将 正确的数据 输出到指定的文件或装置上
    &gt;&gt;     以追加的方法将 正确的数据 输出到指定的文件或装置上
    2&gt;     以覆盖的方法将 错误的数据 输出到指定的文件或装置上
    2&gt;&gt;    以追加的方法将 错误的数据 输出到指定的文件或装置上
    命令 &gt;&gt; 文件 2&gt;&amp;1         正确和错误输出都追加写入到文件中
    命令 &amp;&gt;&gt; 文件             正确和错误输出都追加写入到文件中
    命令 &gt;&gt; 文件1 2&gt;&gt;文件2     正确命令保存到文件1   错误输出保存到文件2
    ls &gt; example.log         ls输出的内容写到example文件中
    ls &gt;&gt; example.log 2&gt;&amp;1   正确和错误日志都追加写入到文件中

输入重定向
    wc     统计输入字符   ctrl+d 结束统计
    wc &lt; example.log     统计文件内容
    wc &lt;&lt; mark  当再次输入mark标记时  统计输入的内容

多命令顺序执行
    ;   命令1 ; 命令2   多个命令顺序执行
    &amp;&amp;  命令1 &amp;&amp; 命令2  逻辑与 命令1正确执行 命令2才执行
    ||  命令1 || 命令2  逻辑或 命令1正确执行 命令2不执行
    命令 &amp;&amp; echo yes || echo no 如果命令正确执行 输出yes 否则输出no

管道符
    |   命令1 | 命令2   命令1正确执行的结果作为命令2的操作对象
    netstat -an | grep ESTABLISHED | wc -l  统计当前链接计算机的用户数

通配符
    ?   匹配任意一个字符
    *   匹配0个或多个字符
    []  匹配中括号内的字符

其他特殊符号
    &apos;&apos;         单引号内的的所有特殊符号 如$ `，都没有特殊含义
    &quot;&quot;         双引号中特殊符号没有特殊含义，但是 $ ` \ 是例外
    $name      调用或得到变量的值
    var=`ls`   先执行命令，再把命令结果赋值给变量
    var=$(ls)  先执行命令，再把命令结果赋值给变量
    #          #开头的行代表注释
    \          转义符  让特殊符号失去作用

管线命令(pipe)
    cut     将一段信息中每行 切出来符合规则的副本
        -d    后面接分隔字符。与 -f 一起使用；
        -f    依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思；
        -c    以字符 (characters) 的单位取出固定字符区间；

    grep    匹配获取文件或信息中的包含特定字符串的行
        grep &quot;display&quot; README.md   搜索README.md中&quot;display”字符串
        -a            将 binary 文件以 text 文件的方式搜寻数据
        -c            计算找到 &apos;搜寻字符串&apos; 的次数
        -i            忽略大小写的不同，所以大小写视为相同
        -n            顺便输出行号
        -v            反向选择，亦即显示出没有 &apos;搜寻字符串&apos; 内容的那一行！
        -An           后面可加数字，为after的意思，除了列出该行外，后续的 n 行也列出来；
        -Bn           后面可加数字，为befer的意思，除了列出该行外，前面的 n 行也列出来；
        --color=auto  可以将找到的关键词部分加上颜色的显示喔！

    sort    对一段数据进行排序
        -f    忽略大小写的差异，例如 A 与 a 视为编码相同；
        -b    忽略最前面的空格符部分；
        -M    以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
        -n    使用『纯数字』进行排序(默认是以文字型态来排序的)；
        -r    反向排序；
        -u    就是 uniq ，相同的数据中，仅出现一行代表；
        -t    分隔符，默认是用 [tab] 键来分隔；
        -k    以那个区间 (field) 来进行排序的意思

    uniq    将重复的数据去重
        -i    忽略大小写字符的不同；
        -c    进行计数

    wc      统计数据中的行数和字符数
        -l    仅列出行；
        -w    仅列出多少字(英文单字)；
        -m    多少字符；

    tee     把数据同时输出的标准输出和文件

    tr      删除或替换一段信息当中的文字
        -d    删除信息当中的 SET1 这个字符串；
        -s    取代掉重复的字符！

    col     可将tab转换为空格键
        -x    将 tab 键转换成对等的空格键
        -b    在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符

    join    将两个文件当中，有&quot;相同数据&quot;的那一行加在一起

    paste   将两行贴在一起，且中间以tab键隔开

    expand  将tab转换为空格键
        -t    一个 tab 按键可以用多少个空格替代。默认为8

    split   切割文件  将一个大文件切割为多个小文件
        -b    后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；
        -l    以行数来进行分割。

    xargs   处理参数

    sed     可分析standard input！ 还可以将数据进行取代、删除、新增、撷取特定行等等的功能呢
        -n    使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN
              的数据一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过
              sed 特殊处理的那一行(或者动作)才会被列出来。
        -e    直接在命令列模式上进行 sed 的动作编辑；
        -f    直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的
              sed 动作；
        -r    sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
        -i    直接修改读取的文件内容，而不是由萤幕输出。

        动作说明：  [n1[,n2]]function
        n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
                 是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』
        function：
        a     新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
        c     取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
        d     删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
        i     插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
        p     列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
        s     取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配
              正规表示法！例如 1,20s/old/new/g 就是啦！

正则表达式
    特殊符号（可避免编码对匹配的影响）
        [:alnum:]    代表英文大小写字节及数字，亦即 0-9, A-Z, a-z
        [:alpha:]    代表任何英文大小写字节，亦即 A-Z, a-z
        [:blank:]    代表空白键与 [Tab] 按键两者
        [:cntrl:]    代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
        [:digit:]    代表数字而已，亦即 0-9
        [:graph:]    除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
        [:lower:]    代表小写字节，亦即 a-z
        [:print:]    代表任何可以被列印出来的字节
        [:punct:]    代表标点符号 (punctuation symbol)，亦即：&quot; &apos; ? ! ; : # $...
        [:upper:]    代表大写字节，亦即 A-Z
        [:space:]    任何会产生空白的字节，包括空白键, [Tab], CR 等等
        [:xdigit:]   代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节

变量
    a=123                   echo $a  输出一个变量的值
    a=$(ls)                 先执行ls命令，再把命令结果赋值给变量
    var=&quot;$LANG&quot;             echo $var 得到 en_US  双引号内的保留原有特性
    var=&apos;$LANG&apos;             echo $var 得到 $LANG  单引号内的特殊字符则仅为一般字符
    \                       将特殊符号(如 [Enter], $, \, 空格符, &apos;等)变成一般字符；
    export PATH             若该变量需要在其他子程序运行，则需要以 export 来使变量变成环境变量：
    unset myname            取消 myname 的配置：
    var[index]=content      定义数组
    ${var#pattern}          删除var变量左边开始匹配pattern最短的字符
    ${var##pattern}         删除var变量左边开始匹配pattern最长的字符
    ${var%pattern}          删除var变量后面开始匹配pattern最短的字符
    ${var%%pattern}         删除var变量后面开始匹配pattern最长的字符
    ${var/oldStr/newStr}    替换变量内第一个oldStr为newStr
    ${var//oldStr/newStr}   替换变量内所有的oldStr为newStr
    var=${oldVar-content}   当oldVar不存在时  var为content的值
    var=${oldVar:-content}  当oldVar不存在或oldVar=&quot;&quot;时 var为content的值

环境变量
    env      列出目前的 shell 环境下的所有环境变量与其内容。
        HOME       代表用户的家目录。
        SHELL      目前这个环境使用的 SHELL，默认使用 /bin/bash
        HISTSIZE   历史记录的数量
        MAIL       当我们使用 mail 这个命令在收信时，系统会去读取的邮件信箱文件 (mailbox)。
        PATH       就是运行文件搜寻的路径啦～目录与目录中间以冒号(:)分隔。
        LANG       语系数据  通常为 zh_CN.UTF-8 或 en_GB.UTF-8
        RANDOM     随机数 介于 0~32767 之间

    set      配置配置整个命令输出/输入的环境
        -u      默认不激活。若激活后，当使用未配置变量时，会显示错误信息；
        -v      默认不激活。若激活后，在信息被输出前，会先显示信息的原始内容；
        -x      默认不激活。若激活后，在命令被运行前，会显示命令内容(前面有 ++ 符号)
        -h      默认激活。与历史命令有关；
        -H      默认激活。与历史命令有关；
        -m      默认激活。与工作管理有关；
        -B      默认激活。与刮号 [] 的作用有关；
        -C      默认不激活。若使用 &gt; 等，则若文件存在时，该文件不会被覆盖。
        set      显示所有变量 (含环境变量与自定义变量)
            PS1        提示字符的配置
            $          本 shell 的 PID echo $$
            ?          上个运行命令的返回值  成功运行命令为返回0  错误返回错误代码
            HOSTNAME   记录了主机名
            HOSTTYPE   记录系统的硬件架构
            MACHTYPE   也是记录系统的硬件架构
            OSTYPE     记录的是操作系统的类型
        echo $-   所有的 set 配置值  $- 变量内容就是 set 的所有配置！ bash 默认 himBH

    locale   获取语言环境信息
        LANG=en_US              主语言的环境
        LC_CTYPE=&quot;en_US&quot;        字符(文字)辨识的编码
        LC_NUMERIC=&quot;en_US&quot;      数字系统的显示信息
        LC_TIME=&quot;en_US&quot;         时间系统的显示数据
        LC_COLLATE=&quot;en_US&quot;      字符串的比较与排序等
        LC_MONETARY=&quot;en_US&quot;     币值格式的显示等
        LC_MESSAGES=&quot;en_US&quot;     信息显示的内容，如菜单、错误信息等
        LC_ALL=                 整体语系的环境
        locale -a  列出支持的语言环境

    read     获取键盘输入的值 赋值给变量
        -p      后面可以接提示字符
        -t      后面可以接等待的秒数

    declare  定义变量类型
    typeset  定义变量类型
        -a      将后面名为 variable 的变量定义成为数组 (array) 类型
        -i      将后面名为 variable 的变量定义成为整数数字 (integer) 类型
        -x      用法与 export 一样，就是将后面的 variable 变成环境变量；
        -r      将变量配置成为 readonly 类型，该变量不可被更改内容，也不能 unset

    ulimit   与文件系统及程序的限制关系
        -H      hard limit ，严格的配置，必定不能超过这个配置的数值；
        -S      soft limit ，警告的配置，可以超过这个配置值，但是若超过则有警告信息。
                在配置上，通常 soft 会比 hard 小，举例来说，soft 可配置为 80 而 hard
                配置为 100，那么你可以使用到 90 (因为没有超过 100)，但介于 80~100 之间时，
                系统会有警告信息通知你！
        -a      后面不接任何选项与参数，可列出所有的限制额度；
        -c      当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件(除错用)，
                这种文件就被称为核心文件(core file)。此为限制每个核心文件的最大容量。
        -f      此 shell 可以创建的最大文件容量(一般可能配置为 2GB)单位为 Kbytes
        -d      程序可使用的最大断裂内存(segment)容量；
        -l      可用于锁定 (lock) 的内存量
        -t      可使用的最大 CPU 时间 (单位为秒)
        -u      单一用户可以使用的最大程序(process)数量。
        ulimit -a         列出你目前身份(假设为root)的所有限制数据数值
        ulimit -f 10240   限制用户仅能创建 10MBytes 以下的容量的文件
</code></pre><h2 id="bash-配置文件"><a href="#bash-配置文件" class="headerlink" title="bash  配置文件"></a>bash  配置文件</h2><pre><code>source ~/.bashrc  调用文件内容   不须重启使起生效
. ~/.bashrc       调用文件内容   不须重启使起生效

/etc/issue  登入时显示的信息(无论登录成功与否都会显示)
    \d    本地端时间的日期；
    \l    显示第几个终端机接口；
    \m    显示硬件的等级 (i386/i486/i586/i686...)；
    \n    显示主机的网络名称；
    \o    显示 domain name；
    \r    操作系统的版本 (相当于 uname -r)
    \t    显示本地端时间的时间；
    \s    操作系统的名称；
    \v    操作系统的版本。
/etc/motd  登入时显示的信息(只有登录成功了才能显示)

/etc/profile   整体环境配备文件(login shell)读取,一般会设置如下变量：
    PATH       会依据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录
    MAIL       依据账号配置好使用者的 mailbox 到 /var/spool/mail/账号名
    USER       根据用户的账号配置此一变量内容
    HOSTNAME   依据主机的 hostname 命令决定此一变量内容
    HISTSIZE   历史命令记录笔数。CentOS 5.x 配置为 1000；

    此文件中一般会呼叫如下配置文件
    /etc/sysconfig/i18n  这个文件用来设置终端的语言信息
    /etc/inputrc         这个文件主要设置终端的输入方式，比如Ctrl+C之类的情况
    /etc/profile.d/      全局的bash环境p配置文件目录，包括颜色、语系、别名等。

~/.bash_profile 个人配置文件(login shell) 按照顺序第一个读取
~/.bash_login   个人配置文件(login shell) 如果.bash_profile不存在读取此文件
~/.profile      个人配置文件(login shell) 如果.bash_login不存在读取此文件
    可针对用户配置环境变量 export PATH=$PATH:/root/bin

~/.bashrc (non-login shell) 配置用户的命令别名

/etc/bashrc(CentOS独有)
    依据不同的 UID 规范出 umask 的值；
    依据不同的 UID 规范出提示字符 (就是 PS1 变量)；
    呼叫 /etc/profile.d/*.sh 的配置

/etc/manpath.config   (CentOS) 使用man命令时，帮助文档的路径
/etc/man.config       (Debian) 使用man命令时，帮助文档的路径

~/.bash_history       命令的历史纪录  数量取决于HISTFILESIZE变量

~/.bash_logout        配置系统关机前执行的动作

stty (setting tty 终端机的意思)
    -a     列出当前系统中所有按键列表
        eof      End of file 的意思，代表『结束输入』。
        erase    向后删除字符，
        intr     送出一个 interrupt (中断) 的讯号给目前正在 run 的程序；
        kill     删除在目前命令列上的所有文字；
        quit     送出一个 quit 的讯号给目前正在 run 的程序；
        start    在某个程序停止后，重新启动他的 output
        stop     停止目前屏幕的输出；
        susp     送出一个 terminal stop 的讯号给正在 run 的程序。
    stty erase ^h   设置[ctrl]+h 来进行字符的删除
</code></pre><h2 id="shell-script"><a href="#shell-script" class="headerlink" title="shell script"></a>shell script</h2><pre><code>注意事项
    1，命令的运行是从上而下、从左而右的分析与运行；
    2，命令、选项与参数间的多个空白都会被忽略掉；
    3，空白行也将被忽略掉，并且 [tab] 按键所推开的空白同样视为空白键；
    4，如果读取到一个 Enter 符号 (CR) ，就尝试开始运行该行 (或该串) 命令；
    5，至於如果一行的内容太多，则可以使用『 \[Enter] 』来延伸至下一行；
    6，『 # 』可做为注解！任何加在 # 后面的数据将全部被视为注解文字而被忽略！

运行脚本方式
    直接命令下达： shell.sh 文件必须要具备可读与可运行 (rx) 的权限，然后：
        绝对路径：使用 /home/dmtsai/shell.sh 来下达命令；
        相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来运行
        变量『PATH』功能：将 shell.sh 放在 PATH 指定的目录内，例如： ~/bin/
    以 bash 程序来运行：透过『 bash shell.sh 』或『 sh shell.sh 』来运行

基本语法
    第一行 #!/bin/bash 在宣告这个 script 使用的 shell 名称
    exit 0  这代表离开 script 并且回传一个 0 给系统

判断
    test   可检测文件和相关属性
        例: test -e /etc &amp;&amp; echo &quot;exist&quot; || echo &quot;Not exist&quot;  检测/etc是否存在
        1. 关於某个档名的&quot;文件类型&quot;判断，如 test -e filename 表示存在否
            -e  该&quot;档名&quot;是否存在？(常用)
            -f  该&quot;档名&quot;是否存在且为文件(file)？(常用)
            -d  该&quot;档名&quot;是否存在且为目录(directory)？(常用)
            -b  该&quot;档名&quot;是否存在且为一个 block device 装置？
            -c  该&quot;档名&quot;是否存在且为一个 character device 装置？
            -S  该&quot;档名&quot;是否存在且为一个 Socket 文件？
            -p  该&quot;档名&quot;是否存在且为一个 FIFO (pipe) 文件？
            -L  该&quot;档名&quot;是否存在且为一个连结档？
        2. 关於文件的权限侦测，如 test -r filename 表示可读否 (但 root 权限常有例外)
            -r  侦测该档名是否存在且具有&quot;可读&quot;的权限？
            -w  侦测该档名是否存在且具有&quot;可写&quot;的权限？
            -x  侦测该档名是否存在且具有&quot;可运行&quot;的权限？
            -u  侦测该档名是否存在且具有&quot;SUID&quot;的属性？
            -g  侦测该档名是否存在且具有&quot;SGID&quot;的属性？
            -k  侦测该档名是否存在且具有&quot;Sticky bit&quot;的属性？
            -s  侦测该档名是否存在且为&quot;非空白文件&quot;？
        3. 两个文件之间的比较，如： test file1 -nt file2
            -nt (newer than)判断 file1 是否比 file2 新
            -ot (older than)判断 file1 是否比 file2 旧
            -ef 判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判定，两个文件是否均指向同一个 inode 哩！
        4. 关於两个整数之间的判定，例如 test n1 -eq n2
            -eq 两数值相等 (equal)
            -ne 两数值不等 (not equal)
            -gt n1 大於 n2 (greater than)
            -lt n1 小於 n2 (less than)
            -ge n1 大於等於 n2 (greater than or equal)
            -le n1 小於等於 n2 (less than or equal)
        5. 判定字串的数据
            test -z string  判定字串是否为 0 ？若 string 为空字串，则为 true
            test -n string  判定字串是否非为 0 ？若 string 为空字串，则为 false。
            注： -n 亦可省略
            test str1 = str2    判定 str1 是否等於 str2 ，若相等，则回传 true
            test str1 != str2   判定 str1 是否不等於 str2 ，若相等，则回传 false
        6. 多重条件判定，例如： test -r filename -a -x filename
            -a  (and)两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true。
            -o  (or)两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。
            !   反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true

    [ == ]  判断符号
        例: [ &quot;$HOME&quot; == &quot;$MAIL&quot; ]  是test $HOME = $MAIL的意思  注意[]里面需要有空格

命令行参数
    $0 : 代表当前执行脚本的文件名
    $1 : 第一个命令行参数 $2为第二个 等
    $# : 代表命令后接的参数的个数；
    $@ ：代表『 &quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot; 』之意，每个变量是独立的(用双引号括起来)；
    $* ：代表『 &quot;$1c$2c$3c$4&quot; 』，其中 c 为分隔字节，默认为空白键， 所以本例中代表『 &quot;$1 $2 $3 $4&quot; 』之意。
    shift  从前面开始删除参数

条件判断语句
    单个条件判断式
        if [ 条件判断式 ]; then
            当条件判断式成立时，可以进行的命令工作内容；
        fi   &lt;==将 if 反过来写，就成为 fi 啦！结束 if 之意！

    多个条件判断 (if ... elif ... elif ... else) 分多种不同情况运行
        if [ 条件判断式一 ]; then
            当条件判断式一成立时，可以进行的命令工作内容；
        elif [ 条件判断式二 ]; then
            当条件判断式二成立时，可以进行的命令工作内容；
        else
            当条件判断式一与二均不成立时，可以进行的命令工作内容；
        fi

    &amp;&amp; 代表 AND ；
    || 代表 or ；
    [ &quot;$yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]  代表$yn为Y或y

    case ..... esac 判断
        case $var in
            &quot;value1&quot;)
                progrom1
                ;;
            &quot;value2&quot;)
                progrom2
                ;;
            *)
                default progrom
                exit 1
                ;;
        esac

    function 函数功能
        定义函数
       function fname() {
           program...
       }
        执行函数
            fname pram1 pram2 ...
        参数
            函数名称代表示 $0 ，而后续接的变量也是以 $1, $2...

循环 loop
    当 condition 成立时，就进行循环
        while [ condition ]
        do
            program...
        done

    当 condition 成立时，终止循环
        until [ condition ]
        do
            program...
        done

    for...in...do...done 遍历循环  每次循环var的值分别为con1,con2,con3...
        for var in con1 con2 con3 ...
        do
            program...
        done

    for...do...done  按次数循环
        for (( i=0; i&lt;$num; i=i+1 ))
        do
            program...
        done

debug 调试
    sh [-nvx] scripts.sh
        -n    不要运行 script，仅查询语法的问题；
        -v    再运行 sccript 前，先将 scripts 的内容输出到萤幕上；
        -x    将使用到的 script 内容显示到萤幕上，这是很有用的参数！
</code></pre><h2 id="Linux-的账号与群组"><a href="#Linux-的账号与群组" class="headerlink" title="Linux 的账号与群组"></a>Linux 的账号与群组</h2><pre><code>/etc/passwd 文件结构
    账号名称：如root
    密码：早期 Unix 系统的密码！现将密码数据改放到/etc/shadow，用x占位。
    UID：用户的User ID，通常 Linux 对于 UID 的几个限制：
        0         系统管理员，需其他的账号有 root 的权限，可将该账号的 UID 改为 0，不建这样做。
        1~499     系统账号，保留给系统使用的 ID，除了 0 之外，其他的 UID 权限与特性并没有不一样。
                  由于系统上面启动的服务希望使用较小的权限去运行，因此不希望使用 root 的身份去运行这些服务，
                  所以我们就得要提供这些运行中程序的拥有者账号才行。这些系统账号通常是不可登陆的，
                  所以才会有我们在第十一章提到的 /sbin/nologin 这个特殊的 shell 存在。
        1~99      由 distributions 自行创建的系统账号；
        100~499   若用户有系统账号需求时，可以使用的账号 UID。
        500~65535 可登陆账号，给一般使用者用的。linux核心2.6.x以上已可以支持到 4294967295 (2^32-1)。
    GID： 用户组ID，与 /etc/group 有关
    用户信息说明栏：用来解释这个账号的意义！提供使用 finger 的功能时，可以提供很多的信息呢！
    家目录：这是用户的家目录，移动用户家目录可修改此字段，默认/home/yourIDname
    Shell：用户默认shell，/sbin/nologin 可让用户无法用shell 环境的登陆

/etc/shadow 文件结构
    账号名称：如root
    密码：经过加密后的密码，避免密码被泄露破解，勿修改此文件权限！
         因编码方式不同，这个字段的长度不相同。
    最近修改密码的日期：修改密码的日期。1970年1月1日作为1
    密码不可被修改的天数：密码在最近一次修改后需要经过几天才可以再被修改！0表示随时可以更动的意思。
    密码需要重新变更的天数：99999表示无需变动密码。
    密码需要变更期限前的警告天数：7表示密码到期7天内系统会警告该用户修改密码。
    密码过期后的账号宽限时间：是在口令过期几天后，可用旧密码登入，系统会强制修改密码。
    账号失效日期：账号在此字段规定的日期之后，将无法再使用。
    保留：最后一个字段是保留的，看以后有没有新功能加入。

/etc/group 文件结构
    组名：
    群组密码：通常不需要配置，是给『群组管理员』使用的，很少用到！密码已经移动到/etc/gshadow，x占位；
    GID：群组的ID。我们 /etc/passwd 第四个字段使用的 GID 对应的群组名，就是由这里对应出来的！
    此群组支持的账号名称：那某个账号想要加入此群组时，将该账号加入这个字段。如root:x:0:root,caozheng

/etc/gshadow 文件结构
    组名
    密码：同样的，开头为 ! 表示无合法密码，所以无群组管理员
    群组管理员的账号 (相关信息在 gpasswd 中介绍)
    该群组的所属账号 (与 /etc/group 内容相同！)

有效群组(effective group)与初始群组(initial group)
    初始群组：当用户一登陆系统，立刻就拥有这个群组的相关权限的意思
    有效群组：创建新文件时的群组
    groups  查看支持的群组
        groups user  查看其它用户支持的群组  其中第一个为有效群组
    newgrp  切换有效群组
        newgrp groupname 切换当前用户的有效群组，群组必须是该用户支持的

/etc/default/useradd 文件结构
    GROUP=100              新建账号的GID为100，RHEL,Fedora,CentOS等为私有群组机制，默认创建同名群组，不参考此值。
    HOME=/home             用户家目录的基准目录(basedir)
    INACTIVE=-1            密码过期后是否会失效，0立刻失效，-1永不失效，如果是数字，30 天后才失效。
    EXPIRE=                账号失效的日期
    SHELL=/bin/bash        默认使用的 shell 程序文件名
    SKEL=/etc/skel         用户家目录参考基准目录，新创见用户的家目录会复制此目录
    CREATE_MAIL_SPOOL=yes  创建使用者的 mailbox

 /etc/login.defs 文件结构 用来配置创建用户时的UID/GID 还有口令参数等
    MAIL_DIR /var/spool/mail  用户默认邮件信箱放置目录
    PASS_MAX_DAYS   99999     /etc/shadow 内的第 5 栏，多久需变更口令日数
    PASS_MIN_DAYS   0         /etc/shadow 内的第 4 栏，多久不可重新配置口令日数
    PASS_MIN_LEN    5         口令最短的字符长度，已被 pam 模块取代，失去效用！
    PASS_WARN_AGE   7         /etc/shadow 内的第 6 栏，过期前会警告的日数
    UID_MIN         500       使用者最小的 UID，意即小于 500 的 UID 为系统保留
    UID_MAX       60000       使用者能够用的最大 UID
    GID_MIN         500       使用者自定义组的最小 GID，小于 500 为系统保留
    GID_MAX       60000       使用者自定义组的最大 GID
    CREATE_HOME     yes       在不加 -M 及 -m 时，是否主动创建用户家目录？
    UMASK           077       用户家目录创建的 umask ，因此权限会是 700
    USERGROUPS_ENAB yes       使用 userdel 删除时，是否会删除初始群组
    MD5_CRYPT_ENAB yes        口令是否经过 MD5 的加密机制处理

/etc/sudoers 与 visudo  配置哪些用户可以使用sudo和权限
    root  ALL=(ALL)  ALL
        1，系统的哪个账号可以使用 sudo 这个命令的意思，默认为 root 这个账号；
        2，当这个账号由哪部主机联机到本，可以指定客户端计算机。默认值 root 可来自任何一部网络主机
        3，这个账号可以切换成什么身份来下达后续的命令，默认 root 可以切换成任何人；
        4，可用该身份下达什么命令？这个命令请务必使用绝对路径撰写。
    %admin  ALL=(ALL)  ALL
        %groupname 为群组的意思
    %admin  ALL=(ALL)  NOPASSWD: ALL
        NOPASSWD 表示免除口令输入的意思喔！
    user  ALL=(root) /usr/bin/passwd
        user用户仅能以root身份运行passwd命令
    user  ALL=(root)  !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root
        限制user用户不能使用passwd密令修改root用户的密码
    user  ALL=(root)  /bin/su -
        只执行一次sudo 后面皆可通过root身份执行命令
    User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2
    Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*
    ADMPW  ALL=(root)  ADMPWCOM
        通过用户别名和命令别名来配置

ACL Access Control List 的缩写,针对特定用户特定群组来配置权限
    查看是否启动ACL
        dumpe2fs -h /dev/sda2 中的 Default mount options 字段是否包含acl
    启动ACL
        vi /etc/fstab
        LABEL=/1   /   ext3    defaults,acl    1 1

    setfacl  配置某个目录/文件的 ACL 规范
        -m   配置后续的 acl 参数给文件使用，不可与 -x 合用；
        -x   删除后续的 acl 参数，不可与 -m 合用；
        -b   移除所有的 ACL 配置参数；
        -k   移除默认的 ACL 参数，关于所谓的『默认』参数于后续范例中介绍；
        -R   递归配置 acl ，亦即包括次目录都会被配置起来；
        -d   配置『默认 acl 参数』的意思！只对目录有效，在该目录新建的数据会引用此默认值
        setfacl -m u:user:rx file  对file文件user用户设置acl属性
        setfacl -m g:groupname:rx file  对file文件groupname用户组设置acl属性
        setfacl -m m:r file 设置mask(最大允许的权限)的acl属性

    getfacl 取得某个文件/目录的 ACL 配置项目
</code></pre><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><pre><code>配置文件
    /etc/group   存储当前系统中所有用户组信息
        Group: x:0:user1,user2,user3  分别为  组名:组密码占位符:组编号:组中用户名列表
        组编号: 0固定为root  1~499为系统预留  500开始为用户手动创建的用户组
    /etc/gshadow 存储当前系统中用户组密码的信息
        Group: *::user1,user2,user3  分别代表  组名:组密码:组管理者:组中用户名列表
        组密码: * ! 或者 空 为没有密码
        组管理者：一般情况下为空  表示组内所有用户都可以管理用户组
    /etc/passwd  存储当前系统中用户的信息
        root:x:0:0:xxx:/root:/bin/bash
        用户名:密码占位符:用户编号:用户组编号:用户注释信息:用户目录:shell类型
        用户注释信息：添加用户信息时 可添加用户备注信息
    /etc/shadow  存储用户密码的配置文件

用户组管理
    groupadd groupname  创建用户组
        -g   后面接某个特定的 GID ，用来直接给予某个 GID
        -r   创建系统群组啦！与 /etc/login.defs 内的 GID_MIN 有关。

    groupmod -n oldname modifyname 修改用户组名为modifyname
    groupmod -g 888 groupname      修改name用户组的编号为666
    groupdel groupname             删除名字为name的用户组（必须先删除组内用户）

    gpasswd  群组管理员功能  可以管理哪些账号可以加入/移出该群组
        -A   (root)将 groupname 的主控权交由后面的使用者管理(该群组的管理员)
        -M   (root)将某些账号加入这个群组当中！
        -r   (root)将 groupname 的口令移除
        -R   (root)让 groupname 的口令栏失效
        -a   将某位使用者加入到 groupname 这个群组当中！
        -d   将某位使用者移除出 groupname 这个群组当中。

用户管理
    useradd  创建新的用户
        -u   后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个账号；
        -g   后面接groupname，该群组的GID会被放置到 /etc/passwd 的第四个字段内。
        -G   后面接的组名则是这个账号还可以加入的群组。此参数会修改 /etc/group 内的相关数据！
        -M   强制！不要创建用户家目录！(系统账号默认值)
        -m   强制！要创建用户家目录！(一般账号默认值)
        -c   账户说明信息，/etc/passwd 的第五字段
        -d   指定某个目录成为家目录，而不要使用默认值。务必使用绝对路径！
        -r   创建一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs)
        -s   后面接一个 shell ，若没有指定则默认是 /bin/bash
        -e   账号失效日期，格式YYYY-MM-DD，此项目可写入 shadow 第八字段，
        -f   后面接 shadow 的第七字段，指定口令是否会失效。0为立刻失效，-1 为永远不失效
        -D   查看useradd的参数默认值，读取自/etc/default/useradd

    passwd        修改用户密码
        --stdin   可以透过来自前一个管线的数据，作为口令输入，对 shell script 有帮助！
        -l        是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使口令失效；
        -u        与 -l 相对，是 Unlock 的意思！
        -S        列出口令相关参数，亦即 shadow 文件内的大部分信息。
        -n        后面接天数，shadow 的第 4 字段，多久不可修改口令天数
        -x        后面接天数，shadow 的第 5 字段，多久内必须要更动口令
        -w        后面接天数，shadow 的第 6 字段，口令过期前的警告天数
        -i        后面接『日期』，shadow 的第 7 字段，口令失效日期

    chage [-ldEImMW] username   更详细的口令参数显示功能
        -l   列出该账号的详细口令参数；
        -d   后面接日期，修改 shadow 第三字段(最近一次更改口令的日期)，格式 YYYY-MM-DD
        -E   后面接日期，修改 shadow 第八字段(账号失效日)，格式 YYYY-MM-DD
        -I   后面接天数，修改 shadow 第七字段(口令失效日期)
        -m   后面接天数，修改 shadow 第四字段(口令最短保留天数)
        -M   后面接天数，修改 shadow 第五字段(口令多久需要进行变更)
        -W   后面接天数，修改 shadow 第六字段(口令过期前警告日期)

    usermod  修改用户信息
        -c   后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。
        -d   后面接账号的家目录，即修改 /etc/passwd 的第六栏；
        -e   后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
        -f   后面接天数，为 shadow 的第七字段。
        -g   后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！
        -G   后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～
        -a   与 -G 合用，可『添加次要群组的支持』而非『配置』喔！
        -l   后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！
        -s   后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等等。
        -u   后面接 UID 数字啦！即 /etc/passwd 第三栏的数据；
        -L   暂时将用户的口令冻结，让他无法登陆。其实仅改 /etc/shadow 的口令栏。
        -U   将 /etc/shadow 口令栏的 ! 拿掉，解冻啦！

    userdel username   删除用户
        -r   删除用户的同时删除用户文件

    touch /etc/nologin             禁止除了root之外的用户登入服务器

用户相关其他命令
    passwd -l username             锁定用户 禁止用户使用
    passwd -u username             解锁用户
    passwd -d username             取消用户密码
    gpasswd -a username groupname  修改用户的附属用户组 可用,链接多个附属组
    gpasswd -d username groupname  移除用户附属组
    newgrp groupname               临时切换用户组为groupname

其他用户命令
    su                             切换到root用户
        -     使用 su - 代表login-shell的变量文件读取方式登陆系统；否则为non-login shell。
        -l    与 - 类似，但后面需要加欲切换的使用者账号！也是 login-shell 的方式。
        -m    -m 与 -p 是一样的，表示『使用目前的环境配置，而不读取新使用者的配置文件』
        -c    仅进行一次命令，所以 -c 后面可以加上命令喔！

    whoami                         显示当前登入的用户名
    id username                    显示指定用户信息 包括用户编号主要组编号附属组列表
    groups username                显示用户所在的组 包括附属组
    chfn username                  设置用户详细资料 包括性别生日等 实际为修改etc/passwd第5字段
        -f   后面接完整的大名；
        -o   您办公室的房间号码；
        -p   办公室的电话号码；
        -h   家里的电话号码！

    chsh 修改用户的shell
        -l   列出目前系统上面可用的 shell ，其实就是 /etc/shells 的内容！
        -s   配置修改自己的 Shell

    finger username                显示用户的详细资料
        -s   仅列出用户的账号、全名、终端机代号与登陆时间等等；
        -m   列出与后面接的账号相同者，而不是利用部分比对 (包括全名部分)
        Login：为使用者账号，亦即 /etc/passwd 内的第一字段；
        Name：为全名，亦即 /etc/passwd 内的第五字段(或称为批注)；
        Directory：就是家目录了；
        Shell：就是使用的 Shell 文件所在；
        Never logged in.：figner 还会调查用户登陆主机的情况喔！
        No mail.：调查 /var/spool/mail 当中的信箱数据；
        No Plan.：调查 ~vbird1/.plan 文件，并将该文件取出来说明！

    w 或 who    查看目前已登陆在系统上面的用户呢
    lastlog     读取 /var/log/lastlog  查看每个账户最后登入时间

    write 给其他用户发送信息
        write username port  port可用who命令查看

    mesg [y|n]  是否接受其他人发送的信息

    wall  对系统中所有用户发送信息
        wall &quot;message&quot;

    pwck  检查 /etc/passwd，与对应的家目录是否存在，/etc/passwd /etc/shadow 的信息是否一致等。
    pwconv  将 /etc/passwd 内的账号与口令，移动到 /etc/shadow 当中
    pwunconv  将 /etc/shadow 内的口令栏数据写回 /etc/passwd 当中， 并且删除 /etc/shadow 文件
    chpasswd  读入未加密前的口令，并且经过加密后， 将加密后的口令写入 /etc/shadow 中
</code></pre><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><pre><code>df  查看磁盘分区的使用情况
    -l  仅显示本地磁盘(默认)
    -a  显示所有文件系统的磁盘使用情况，包含/proc/
    -h  以1024进制用最合适的单位显示磁盘容量
    -H  以1000进制用最合适的单位显示磁盘容量
    -T  显示磁盘分区类型
    -t  显示指定类型文件系统的磁盘分区
    -x  不显示指定类型文件系统的磁盘分区

du  统计磁盘上的文件大小
    -b  以byte为单位统计文件
    -k  以KB为单位统计文件
    -m  以MB为单位统计文件
    -h  以1024进制用最合适的单位统计文件
    -H  以1000进制用最合适的单位统计文件
    -s  指定统计目标(可以指定统计某个文件夹的大小)

fdisk   磁盘分区工具  分区最大容量2TB
    -l  列出所有磁盘分区表
    fdisk /dev/sda  进入sda硬盘的分区模式（只能MBR分区）
        设置扇区大小时，可输入 +2000M 来设置分区大小

parted  MBR和GPT分区工具
    注：Using /dev/sda 默认分区磁盘为系统第一块硬盘
    select /dev/sdb   切换目标磁盘为sdb
    mklabel msdos     指定分区表类型为MBR
    mklabel gpt       指定分区表类型为gpt
    print             查看当前硬盘分区详情
    print all         查看所有硬盘分区详情
    mkpart            创建分区
        start         从第几MB开始分区，可输入1，如输入0会有分区对齐的警告，对磁盘性能有影响
        end           可输入2000MB
    mkpart NAME 20 30 命令模式创建分区
    rm NUMBER         删除分区
    unit              修改分区单位
    quit              退出分区工具

分区模式区别
    MBR
        主分区数量最大4个
        单个分区容量最大2TB
    GPT
        主分区数量最大128个
        单个分区容量最大18EB   1EP=1024PB=1024TB=1024GB
        不适合安装X86架构 32位操作系统

硬盘格式化工具
    mkfs   格式化分区
    mkfs.ext3 /dev/sda1     格式化sda1分区
    mkfs -t ext4 /dev/sda1  格式化sda1分区

添加SWAP交换分区
    建立一个普通的linux分区  修改分区类型的16位编码
        fdisk /dev/sda  进入fdisk工具
        t  修改编码 Hex Code 为82  L可查看编码列表
    mkswap /dev/sda1  格式化sda1为交换分区
    swapon /dev/sda1   启用sda1为交换分区
    swapoff /dev/sda1  关闭sda1交换分区
    free可查看swap分区

文件系统备份 dump [-Suvj] [-level] [-f 备份档] 待备份数据
    -S     仅列出后面的待备份数据需要多少磁碟空间才能够备份完毕；
    -u     将这次 dump 的时间记录到 /etc/dumpdates 文件中；
    -v     将 dump 的文件过程显示出来；
    -j     加入 bzip2 的支持！将数据进行压缩，默认 bzip2 压缩等级为 2
    -level 就是我们谈到的等级，从 -0 ~ -9 共十个等级；
    -f     有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 装置档名等
    -W     列出在 /etc/fstab 里面的具有 dump 配置的 partition 是否有备份过？

文件系统还原 restore
    restore -t [-f dumpfile] [-h]         用来察看 dump 档
    restore -C [-f dumpfile] [-D 挂载点]   比较dump与实际文件
    restore -i [-f dumpfile]              进入互动模式
    restore -r [-f dumpfile]              还原整个文件系统

    -t  ：此模式用在察看 dump 起来的备份档中含有什么重要数据！类似 tar -t 功能；
    -C  ：此模式可以将 dump 内的数据拿出来跟实际的文件系统做比较，
          最终会列出『在 dump 文件内有记录的，且目前文件系统不一样』的文件；
    -i  ：进入互动模式，可以仅还原部分文件，用在 dump 目录时的还原！
    -r  ：将整个 filesystem 还原的一种模式，用在还原针对文件系统的 dump 备份；
    其他较常用到的选项功能：
    -h  ：察看完整备份数据中的 inode 与文件系统 label 等资讯
    -f  ：后面就接你要处理的那个 dump 文件罗！
    -D  ：与 -C 进行搭配，可以查出后面接的挂载点与 dump 内有不同的文件！
</code></pre><p>##进程管理</p>
<pre><code>任务管理
    ctrl + z  将一个正在前台执行的命令放到后台，并且暂停
    jobs  查看后台任务状态
        -l  除了列出 job number 与命令串之外，同时列出 PID 的号码；
        -r  仅列出正在背景 run 的工作；
        -s  仅列出正在背景当中暂停 (stop) 的工作
    fg  将放置到后台的任务拿到前台处理
        %number ：number 为后台任务数字。% 是选！默认打开油 + 的任务
    bg  让后台暂停的任务在后台运行
    nohup  让命令在终端离线后不会中断，继续运行。

ps      查看当前时间进程快照
    -A  所有的 process 均显示出来，与 -e 具有同样的效用；
    -a  不与 terminal 有关的所有 process ；
    -u  有效使用者 (effective user) 相关的 process ；
    x   通常与 a 这个参数一起使用，可列出较完整资讯。
    l   较长、较详细的将该 PID 的的资讯列出；
    j   工作的格式 (jobs format)
    -f  做一个更为完整的输出。
    -l  仅观察自己的 bash 相关程序
        F  代表这个程序旗标 (process flags)，说明这个程序的总结权限，常见号码有：
            若为 4 表示此程序的权限为 root ；
            若为 1 则表示此子程序仅进行复制(fork)而没有实际运行(exec)。
        S  代表这个程序的状态 (STAT)，主要的状态有：
            R  (Running)该程序正在运行中；
            S  (Sleep)该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。
            D  不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex&gt;列印)
            T  停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；
            Z  (Zombie)僵尸状态，程序已经终止但却无法被移除至内存外。
        UID    此程序被该 UID 所拥有
        PID    程序的 PID 号码
        PPID   程序的父程序 PID 号码
        C      代表 CPU 使用率，单位为百分比；
        PRI/NI Priority/Nice 的缩写，代表此程序被 CPU 所运行的优先顺序，数值越小该程序越快被 CPU 运行。
        ADDR   是 kernel function，指出该程序在内存的哪个部分，如果是个 running 的程序，一般就会显示 -
        SZ     代表此程序用掉多少内存
        WCHAN  表示目前程序是否运行中，同样的， 若为 - 表示正在运行中。
        TTY    登陆者的终端机位置，若为远程登陆则使用动态终端介面 (pts/n)；
        TIME   使用掉的 CPU 时间，注意，是此程序实际花费 CPU 运行的时间，而不是系统时间；
        CMD    就是 command 的缩写，造成此程序的触发程序之命令为何。
    aux  观察系统所有程序
        USER    属於哪个使用者帐号的
        PID     的程序识别码
        %CPU    使用掉的 CPU 资源百分比
        %MEM    所占用的实体内存百分比
        VSZ     使用掉的虚拟内存量 (Kbytes)
        RSS     占用的固定的内存量 (Kbytes)
        TTY     是在那个终端机上面运行，若与终端机无关则显示 ?
                tty1-tty6 是本机上面的登陆者程序，pts/0 等则表示为由网络连接进主机的程序。
        STAT    该程序目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)
        START   被触发启动的时间；
        TIME    实际使用 CPU 运行的时间。
        COMMAND 该程序的实际命令

prtree  显示进程树
    -p  并同时列出每个 process 的 PID；
    -u  并同时列出每个 process 的所属帐号名称。
    -A  各程序树之间的连接以 ASCII 字节来连接；
    -U  各程序树之间的连接以万国码的字节来连接。在某些终端介面下可能会有错误；

top  动态观察进程的变化
    -d  后面可以接秒数，就是整个程序画面升级的秒数。默认是 5 秒；
    -b  以批量的方式运行 top ，还有更多的参数可以使用喔！
        通常会搭配数据流重导向来将批量的结果输出成为文件。
    -n  与 -b 搭配，意义是，需要进行几次 top 的输出结果。
    -p  指定某些个 PID 来进行观察监测而已。
    在 top 运行过程当中可以使用的按键命令
        ?  显示在 top 当中可以输入的按键命令；
        P  以 CPU 的使用资源排序显示；
        M  以 Memory 的使用资源排序显示；
        N  以 PID 来排序喔！
        T  由该 Process 使用的 CPU 时间累积 (TIME+) 排序。
        k  给予某个 PID 一个讯号  (signal)
        r  给予某个 PID 重新制订一个 nice 值。
        q  离开 top 软件的按键。
    头部6行状态栏意义
        top    目前时间，系统启动时间，已登入系统用户数，系统在 1, 5, 15 分钟的平均工作负载。
        Tasks  显示的是目前程序的总量与个别程序在什么状态(running, sleeping, stopped, zombie)
        Cpus   显示的是 CPU 的整体负载，可按数字1，来显示多核心CPU负载
            us: (user CPU time) 用户态使用的cpu时间比
            sy: (system CPU time) 系统态使用的cpu时间比
            ni: (nice CPU time) 用做nice加权的进程分配的用户态cpu时间比
            id: (idle) 空闲的cpu时间比
            wa: (iowait)  cpu等待磁盘写入完成时间
            hi: (hardware irq) 硬中断消耗时间
            si: (software irq) 软中断消耗时间
            st: (steal time) 虚拟机偷取时间
        Mem    物理内存的使用情况
        Swap   虚拟内存的使用情况，需注意如果 swap 被用的很多，表示系统的物理内存不足
        other  这个是当在 top 程序当中输入命令时，显示状态的地方。
    进程状态的意义
        PID       进程的ID
        USER      进程所有者
        PR        进程的优先级别，越小越优先被执行
        NI        nice值
        VIRT      进程占用的虚拟内存
        RES       进程占用的物理内存
        SHR       进程使用的共享内存
        S         进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
        %CPU      进程占用CPU的使用率
        %MEM      进程使用的物理内存和总内存的百分比
        TIME+     该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
        COMMAND   进程启动命令名称

进程的优先级
    名词概念
        PRI  (Priority)优先运行序,PRI值越低代表越优先的意思。PRI值由核心动态调整，使用者无法直接调整PRI
        NI   (Nice)使用者可修改NI值来影响PRI，范围-20~19，非root用户只能调整自己进程的NI值，且只能调高
    nice    以所设置的nice值运行新的命令
        -n number command   以所设置的nice值运行新的命令
    renice  调整已经运行的程序的nice值
        [number] PID  把该PID的process的nice值调整为number

kill
    PID  杀掉指定PID的进程
    -l   这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？
    signal   代表给予后面接的那个工作什么样的指示罗！用 man 7 signal 可知：
        -1   重新读取一次参数的配置档 (类似 reload)；
        -2   代表与由键盘输入 [ctrl]-c 同样的动作；
        -9   立刻强制删除一个工作；
        -15  以正常的程序方式终止一项工作。与 -9 是不一样的。

screen  终端模拟器
    screen -S name    新建一个会画
    screen -dmS name  建立一个处于断开模式下的会话（并指定其会话名）。
    screen -list      列出所有会话。
    screen -r name    重新连接指定会话。
    CTRL + a d        暂时断开当前会话。
    exit              终止当前会画
    CTRL + d          终止当前会画

fuser  找出正在使用指定文件或文件夹的程序
    -u       除了程序的 PID 之外，同时列出该程序的拥有者；
    -m       后面接的那个文件会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！
    -v       可以列出每个文件与程序还有命令的完整相关性！
    -k       找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID；
    -i       必须与 -k 配合，在删除 PID 之前会先询问使用者意愿！
    -signal  例如 -1 -15 等等，若不加的话，默认是 SIGKILL (-9) 罗！
    -uv .    找出目前所在目录的使用 PID/所属帐号/权限 是什么
    fuser -mvu /proc  找到所有使用到 /proc 这个文件系统的程序
    ACCESS 的意义：
        c  此程序在当前的目录下(非次目录)；
        e  可被触发为运行状态；
        f  是一个被开启的文件；
        r  代表顶层目录 (root directory)；
        F  该文件被开启了，不过在等待回应中；
        m  可能为分享的动态函式库；

lsof   查看正在被进程所开启的文件
    -a  多项数据需要『同时成立』才显示出结果时！
    -U  仅列出 Unix like 系统的 socket 文件类型；
    -u  后面接 username，列出该使用者相关程序所开启的文件；
    +d  后面接目录，亦即找出某个目录底下已经被开启的文件！

pidof  找出某个正在运营程序的PID
    -s  仅列出一个 PID 而不列出所有的 PID
    -x  同时列出该 program name 可能的 PPID 那个程序的 PID
</code></pre><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><pre><code>at [-mldv] TIME   新增，查看，修改定时任务
    -m   当 at 的工作完成后，即使没有输出信息，亦以 email 通知使用者该工作已完成。
    -l   at -l 相当於 atq，列出目前系统上面的所有该使用者的 at 排程；
    -d   at -d 相当於 atrm ，可以取消一个在 at 排程中的工作；
    -v   可以使用较明显的时间格式列出 at 排程中的工作列表；
    -c   可以列出后面接的该项工作的实际命令内容。

    TIME：时间格式，这里可以定义出『什么时候要进行 at 这项工作』的时间，格式有：
        HH:MM  在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。
        HH:MM YYYY-MM-DD  强制规定在某年某月的某一天的特殊时刻进行该工作！
        HH:MM[am|pm] + number [minutes|hours|days|weeks]  在某个时间点『再加几个时间后』才进行。

    相关文件
        /var/spool/at/ 被安排在队列中的任务
        /etc/at.allow  允许使用at的用户，如果at.allow不存在，则取at.deny配置。
        /etc/at.deny   不允许使用at的用户，如果两个都不存在，则只有root可以运行at。

atq  查询目前主机上面有多少的 at 工作计划
atrm num  移除当前主机第num号 at 任务计划
batch  在CPU工作负载小于0.8时，执行所下达的工作计划

crontab [-u username] [-l|-e|-r]  定时计划任务
    -u   只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作排程；
    -e   编辑 crontab 的工作内容
    -l   查阅 crontab 的工作内容
    -r   移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。
    相关文件
        /var/spool/cron/ 已经被crontab安排的工作记录
        /var/log/cron    crontab的工作日志
        /etc/cron.allow  允许使用crontab的用户，如果cron.allow不存在，则取cron.deny配置。
        /etc/cron.deny   允许使用crontab的用户，如果两个都不存在，则只有root可以运行crontab。
        /etc/crontab     系统的定时任务设置

anacron  检测关机期间没有运行的定时任务并运行
    -s    开始一连续的运行各项工作 (job)，会依据时间记录档的数据判断是否进行；
    -f    强制进行，而不去判断时间记录档的时间戳记；
    -n    立刻进行未进行的任务，而不延迟 (delay) 等待时间；
    -u    仅升级时间记录档的时间戳记，不进行任何工作。
    job   由 /etc/anacrontab 定义的各项工作名称。
</code></pre><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><pre><code>uptime               查看系统启动时间与工作负载
cal                  显示日历 也可显示其他月份
date                 显示或者设置系统时间
dumpe2fs partition   查看分区的文件系统信息
/proc/cpuinfo        cpu信息

lsblk   列出块设备  以树状格式输出
    -a  以列表模式输出

free    显示内存占用信息
    属性意义
        Mem     那一行显示的是实体内存的量
        Swap    则是虚拟内存的量
        total   是总量
        used    是已被使用的量
        free    则是剩余可用的量
        shared/buffers/cached 则是在已被使用的量当中，用来作为缓冲及缓存的量

uname    显示机器名 操作系统 及内核详细信息
    -a   所有系统相关的资讯，包括底下的数据都会被列出来；
    -s   系统核心名称
    -r   核心的版本
    -m   本系统的硬件名称，例如 i686 或 x86_64 等；
    -p   CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！
    -i   硬件的平台 (ix86)

netstat  查看网络信息
    -r   列出路由表(route table)，功能如同 route 这个指令；
    -a   将目前系统上所有的连线、监听、Socket 数据都列出来
    -t   列出 tcp 网络封包的数据
    -u   列出 udp 网络封包的数据
    -n   不以程序的服务名称，以端口 (port number) 来显示；
    -l   列出目前正在网络监听 (listen) 的服务；
    -p   列出该网络服务的程序 PID
    -c   可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；
    netstat -tlnp  列出目前系统中已开启的网络服务及PID
    网络连接相关状态：
        Proto           网络的封包协议，主要分为 TCP 与 UDP 封包，相关数据请参考服务器篇；
        Recv-Q          非由使用者程序连结到此 socket 的复制的总 bytes 数；
        Send-Q          非由远程主机传送过来的 acknowledged 总 bytes 数；
        Local Address   本地端的 IP:port 情况
        Foreign Address 远程主机的 IP:port 情况
        State           连线状态；
            ESTABLISED  已建立联机的状态；
            SYN_SENT    发出主动联机 (SYN 标志) 的联机封包；
            SYN_RECV    接收到一个要求联机的主动联机封包；
            FIN_WAIT1   该插槽服务(socket)已中断，该联机正在断线当中；
            FIN_WAIT2   该联机已挂断，但正在等待对方主机响应断线确认的封包；
            TIME_WAIT   该联机已挂断，但 socket 还在网络上等待结束；
            LISTEN      通常用在服务的监听 port ！可使用『 -l 』参数查阅。
    本机进程相关状态：
        Proto   一般就是 unix 啦；
        RefCnt  连接到此 socket 的程序数量；
        Flags   连线的旗标；
        Type    socket 存取的类型。主要有确认连线的 STREAM 与不需确认的 DGRAM 两种；
        State   若为 CONNECTED 表示多个程序之间已经连线创建。
        Path    连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。

hdparm   查看硬盘的相关信息或对硬盘进行测速、优化、修改硬盘相关参数设定。
    -a    表示是否关闭磁盘预读取功能。对于大文件读取，这个显然能提高性能。
    -A    设置硬盘驱动器缓存读取特性。可能就是硬盘缓存开关
    -g    显示硬盘的磁轨，磁头，磁区等参数。
    -i    显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。
    -I    直接读取硬盘所提供的硬件规格信息。
    -p    设定硬盘的PIO模式。
    -t    测试硬盘的读取效率。
    -T    测试硬盘缓存读取效率。
    -u    在硬盘存取时，允许其他中断要求同时执行。
    -v    显示硬盘的相关设定。
    hdparm /dev/sda     显示硬盘相关设置
    hdparm -g /dev/sda  显示硬盘的柱面、磁头、扇区数
    hdparm -t /dev/xvda 测试硬盘的读取速度
    hdparm -C /dev/sda  检测硬盘的电源管理模式

/proc/*
    process 已 /porc/PID 目录的形式保存在/porc中
        cmdline  这个程序被启动的命令串；
        environ  这个程序的环境变量内容。
    /proc/cmdline     加载 kernel 时所下达的相关参数！查阅此文件，可了解系统是如何启动的！
    /proc/cpuinfo     本机的 CPU 的相关资讯，包含时脉、类型与运算功能等
    /proc/devices     这个文件记录了系统各个主要装置的主要装置代号，与mknod有关！
    /proc/filesystems 目前系统已经加载的文件系统罗！
    /proc/interrupts  目前系统上面的 IRQ 分配状态。
    /proc/ioports     目前系统上面各个装置所配置的 I/O 位址。
    /proc/kcore       这个就是内存的大小啦！好大对吧！但是不要读他啦！
    /proc/loadavg     还记得 top 以及 uptime 吧？没错！上头的三个平均数值就是记录在此！
    /proc/meminfo     使用 free 列出的内存资讯，嘿嘿！在这里也能够查阅到！
    /proc/modules     目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序啦！
    /proc/mounts      系统已经挂载的数据，就是用 mount 这个命令呼叫出来的数据啦！
    /proc/swaps       到底系统挂加载的内存在哪里？呵呵！使用掉的 partition 就记录在此啦！
    /proc/partitions  使用 fdisk -l 会出现目前所有的 partition 吧？在这个文件当中也有纪录喔！
    /proc/pci         在 PCI 汇流排上面，每个装置的详细情况！可用 lspci 来查阅！
    /proc/uptime      就是用 uptime 的时候，会出现的资讯啦！
    /proc/version     核心的版本，就是用 uname -a 显示的内容啦！
    /proc/bus/*       一些汇流排的装置，还有 U盘 的装置也记录在此喔！
</code></pre><h2 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h2><pre><code>dmidecode  查询硬件信息
    -t type  查询指定类型信息，常用type如下:
        1    详细系统信息，主板型号及硬件基础信息
        4    CPU相关信息，包括倍频，外频，核心数量，核心数据等
        9    系统相关插槽格式，包括PCI,PCI-E等接口规格说明
        17   内存插槽规格，若已经插上内存，则显示该内存的容量及型号

dmesg    查看开机和系统运行过程中，核心产生的信息

lspci    列出系统中的PCI设备
    -v   显示更多的 PCI 设备的详细信息
    -vv  比 -v 相信的内部信息；
    -n   直接查看 PCI 的 ID 而不是厂商名称

update-pciids  更新PCI设备ID厂商对应表

lsusb    列出系统中各USB接口的状态
    -t   适用树状解构显示各USB设备的相关性

iostat   与vmstat类似，即时查看整个CPU与周边设备的Input/Output状态
    -c   仅显示 CPU 状态
    -d   仅显示存储设备状态
    -k   默认显示的是 block ，可改成 K bytes 的大小显示
    -m   与 -k 类似，以 MB 的单位显示结果
    -t   显示日期日
    状态值意义:
        tps        平均每秒传送次数，只与次数相关，非容量
        kB_read/s  开机到现在平均每秒读取单位
        kB_wrtn/s  开机到现在平均每秒写入单位
        kB_read    开机到现在，移动读取的数据大小
        kB_wrtn    开机到现在，移动写入的数据大小

smartctl  查询设备的SMART信息
    -a /dev/sda        查看/dev/sda设备的SMART信息
    -t short /dev/sda  硬盘检查
</code></pre><h2 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a>系统备份</h2><pre><code>需要备份的文件目录
    /etc/              配置文件目录，可整个目录备份
    /root/             root家目录，可整个目录备份
    /home/             用户家目录，可整个目录备份
    /var/spool/mail/   用户邮件，可整个目录备份
    /var/spool/at/     定时任务文件夹
    /var/spool/cron/   定时任务文件夹
    /boot/             如果修改过核心或启动文件，可整个目录备份
    /usr/local/        自己安装过软件，可整个目录备份
    /opt               自行安装过软件，可整个目录备份

备份相关命令
    dd
        if=/dev/sda of=/dev/sdb   将/dev/sda到完全备份至/dev/sdb，速度较慢
    cpio
        find / -print | cpio -covB &gt; /dev/st0  备份根目录下所有文件至设备st0
        cpio -iduv &lt; /dev/st0  从备份中还原
    xfsdump
        xfsdump -l 0 -L &apos;full&apos; -M &apos;full&apos; -f /backu/home.dump /home  第一次完整备份
        xfsdump -l 1 -L &apos;full-1&apos; -M &apos;full-1&apos; -f /backup/home.dump1 /home  第一次增量备份
    tar
        tar --exclude /proc --exclude /backup -jcvp -f /backup/system.tar.bz2 /  除proc外完整备份
        tar -jpcvf mysql.`date +%Y-%m-%d`.tar.bz2 /var/lib/mysql  备份mysql，并以时间命名
    rsync
        rsync -av /home /backupdata/  保持两个目录文件一致，第一次为完全备份，第二次增量备份
</code></pre><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><pre><code>Tarball源码方式
    安装步骤
        1，获取原始文件，将 tarball 文件在 /usr/local/src 目录下解压缩。
        2，查看源码提供的说明文件，如 INSTALL 与 README 等文件内容。
        3，依照 INSTALL/README 的内容安装依赖软件
        4，建立makefile，通过自动检测程序configure或config检测环境，并建立Makefile 文件。
        5，编译，通过make程序并以Makefile文件为参数设定文件进行编译。
        6，安装，通过make程序并以Makefile文件为参数设定，依据install这个target 的指定路径安装。
    安装相关命令
        ./configure   检测环境建立 Makefile 文件。
        make clean    读取 Makefile 中关于 clean 的内容，删除上一次编译的残留文件。
        make          依据 Makefile 编译。
        make install  依据 Makefile 中关于 install 的内容，将编译好的文件安装到指定目录。
    安装路径
        系统预装软件
            /etc/httpd
            /usr/lib
            /usr/bin
            /usr/share/man
        源码编译安装通常默认安装位置
            /usr/local/etc
            /usr/local/bin
            /usr/local/lib
            /usr/local/man
        建议安装位置（利于删除程序，需指定path）
            /usr/local/software/etc
            /usr/local/software/bin
            /usr/local/software/lib
            /usr/local/software/man
    md5sum/sha1sum/sha256sum  校验文件是否正确
        -b   使用 binary 的读取方式，默认为 Windows/DOS 文件类型的读取方式
        -c   检查文件指纹
        -t   以文字形态读取文件指纹
    函数库
        静态
            扩展名：.a
            编译行为：函数库在编译时整合进可执行文件中，相对动态函数库编译后文件较大。
            独立执行：不依赖外部函数库内容，可独立执行
            升级难度：函数库升级，程序须重新编译。
        动态
            扩展名：.so
            编译行为：程序编译时(Pointer)指向动态函数库目标，相对静态函数库编译后文件较小。
            独立执行：不可独立执行，依赖外部函数库，函数库文件位置不可改变
            升级难度：函数库升级，程序不须重新编译。
        在内存中载入函数库
            1，在 /etc/ld.so.conf 中写入希望在内存中载入的函数库目录
            2，通过 ldconfig 程序将 /etc/ld.so.conf 中的资料载入到内存中
            3，同时将内容复制一份至 /etc/ld.so.cache 文件中
        ldd  查看函数所使用的函数库
            -v   列出所有内容信息
            -d   重新将信息遗失的 link 显示出来
            -r   将 ELF 相关的错误显示出来

dpkg
    目录说明
        /var/lib/dpkg/  通过dpkg安装的软件的相关信息库

RPM - RedHat Package Manager 本地包升级
    目录说明
        /var/lib/rpm/     通过RPM安装的软件的相关信息库
        /etc              软件相关设置文件
        /usr/bin          一些可执行文件
        /usr/lib          一些程序所使用的动态函数库
        /usr/share/doc    一些基本软件使用手册及说明书
        /usr/share/man    一些 man page 文件
    安装升级相关命令选项
        -i               install 的意思
        -v               查看更详细的安装信息
        -h               以安装信息列显示安装进度
        -U               安装过则升级，否则安装
        -F               只是升级，没有安装过不安装
        -e               删除软件
        --nodeps         当放生两个软件相互依赖时可使用
        --replacefiles   当出现文件已存在或confilcting files时
        --replacepkgs    当软件已经安装过，需要重新安装时
        --force          强制安装，是 --replacefiles 与 --replacepkgs 的综合体！
        --test           测试软件是否能被安装到使用者的linux中
        --justdb         由于RPM的资料库破损或某些原因产生错误，可用来个更新软件在资料库中的信息
        --nosignature    略过软件的数字签名检查
        --prefix         指定软件安装路径
        --noscripts      不想软件在安装过程中执行某些系统指令
    查询相关命令选项
        -q               查询指定软件是否安装
        -qa              列出系统已安装的所有软件
        -qi              列出指定软件详细资讯
        -ql              列出指定软件所有的文件和目录名
        -qc              列出指定软件的所有设置文件
        -qd              列出指定软件的所有man相关说明文件
        -qR              列出與指定软件依赖软件
        -qf              由文件名找出属于哪个软件的文件
        -q --scripts     列出是否有安装好需要执行的脚本
        -qp[icdlR]       找出某个软件信息，非已经按照的
    验证相关命令选项
        -V               验证指定软件是否被修改过
            修改状态
                S        (file Size differs)                   文件大小是否有变化
                M        (Mode differs)                        文件属性（rwx）是否有改变
                5        (MD5 sum differs)                     MD5 指纹是否有变化
                D        (Device major/minor number mis-match) 设备代码是否变化
                L        (readLink(2) path mis-match)          Link 路径是否变化
                U        (User ownership differs)              文件拥有者是否变化
                G        (Group ownership differs)             文件所属群组是否变化
                T        (mTime differs)                       文件建立时间是否被改变
                P        (caPabilities differ)                 功能是否被修改
            修改的文件类型
                c        (config file)    配置文件
                d        (documentation)  文档文件
                g        (ghost file)     不属于该软件的档案
                l        (license file)   授权信息档案
                r        (read me)        说明档案
        -Va              列出目前系统商所被可能被改动过的文件
        -Vp              列出该软件内的可能被修改过的文件
        -Vf              查看某个文件是否被修改过

SRPM - 包含源的RPM
    rpmbuild
        -ba              编译并同时生成RPM和SRPM文件
        -ba              仅编译成RPM文件
        --rebuild        进行编译打包操作，最终生成.rpm文件
        --recompile      进行编译打包的操作，完成后安装到系统中
    相关目录
        /root/rpmbuild/SPECS      软件设置文件
        /root/rpmbuild/SOURCES    软件原始文件 (*.tar.gz) 以及 config 设置文件
        /root/rpmbuild/BUILD      编译过程中的临时文件
        /root/rpmbuild/RPMS       编译成功后，打包完成的文件，包含x86_64,noarch等子目录
        /root/rpmbuild/SRPMS      编译成功后，打包完成的文件，以SRPM封装的文件
    配置文件内容 *.spec
        Summary          软件的主要说明
        Name             软件的名称，最终生成的RPM的文件名
        Version          软件版本，RPM文件名组成部分
        Release          软件打包次数，RPM文件名组成部分
        License          软件授权方式
        Group            软件所属的软件组
        URL              源码的主要官网
        SourceN          软件来源网站
        PatchN           作为补丁的patch file
        BuildRoot        临时文件的保存目录
        Requires         所依赖的软件
        BuildRequires    编译过程中需要的软件
        %description     软件相关的描述说明
        %prep            编译之前需要做的事情
        %build           编译相关指令
        %install         编译完成后的安装指令
        %files           软件包括的文件和目录
        %changelog       软件的变更记录

YUM - 线上升级
    相关选项和命令
        -y               当yum 需要输入时，自动选 Yes
        --installroot=   指定软件安装的目录
        install          安装软件
        update           升级软件
        remove           删除软件
        search           搜索某个软件名或描述中的关键字
        list             列出目前 yum 所管理的所有的软件名称和版本
        info             列出目前 yum 所管理的所有的软件，并显示更详细信息
        provides         由文件名找出属于哪个软件的文件
        repolist all     列出目前所有使用的软件仓库
        clean all        删除所有本机缓存的软件仓库相关文件
        grouplist        查询目前已经安装的和软件仓库中的软件组
        groupinstall     安装软件组
    修改相关设置
        设置文件地址
            /etc/yum.repos.d/*
        相关字段
            [base]          软件库名字，中括号必须存在，名字可自定义，不可重复
            name            软件库的说明，非必须
            mirrorlist=     软件仓库的更新列表网址，非必须
            baseurl=        软件库地址
            enable=         此软件库状态，1为启动，0为关闭
            gpgcheck=       是否检查数字签名
            gpgkey=         数字签名文件位置
</code></pre><h2 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h2><pre><code>System V (init)启动服务
    相关文件
        /etc/services     服务和端口对应的配置文件(不建议修改)
        /etc/init.d/*     启动脚本放置的地方
        /etc/sysconfig/*  各服务的初始化环境配置文件
        /etc/xinetd.conf  super daemon 配置文件
        /etc/*            各服务各自的配置文件
        /var/lib/*        各服务产生的数据库
        /var/run/*        各服务的程序之 PID 记录处

    service
        service_name [ command | --full-restart ]  管理某个服务，如start|stop|restart|...
        --status-all   将系统所有的 stand alone 的服务状态通通列出来

    /etc/init.d/service_name  查看service_name服务所能执行的命令

    /etc/init.d/service_name [start|stop|restart|status...] 开启停止重启服务等

systemd 启动服务
    相关文件和目录
        /usr/lib/systemd/system/  系统内置的服务启动脚本设置，类似以前的 /etc/init.d
        /run/systemd/system/      系統执行过程中所产生的服务脚本，优先级比/usr/lib/systemd/system/高
        /etc/systemd/system/      管理员自己编写的服务启动腳本， 优先级比/run/systemd/system/高
        /etc/sysconfig/*          大部分服务的初始化设置
        /var/lib/                 各服务产生的数据库
        /run/*                    各服务的暂存文件，包括 lock file 及 PID file 等等
        /usr/lib/systemd/system/vsftpd.service            服务官方默认配置文件
        /etc/systemd/system/vsftpd.service.d/custom.conf  个人定制配置文件
        /etc/systemd/system/vsftpd.service.wants/*        启动后建起启动此目录下的服务
        /etc/systemd/system/vsftpd.service.requires/*     启动前需要启动此目录下的服务

    配置文件字段说明
        [Unit]  unit 本身说明及依赖设置
            Description    服务说明
            Documentation  相关说明文档
            After          此服务在哪个服务之后启动，不强制
            Before         与After相反，在哪个服务启动前最好启动此服务，不强制
            Requires       依赖某个服务启动后才能启动
            Wants          与Requires相反，此服务启动后还需启动哪些服务
            Conflicts      互相冲突的服务，不能同时启动
        [Service],[Socket],[Timer],[Mount],[Path].. 启动脚本，环境变量，重启方式等设置
            Type              此服务的启动方式，会影响到ExecStart，通常有如下类型
                simple        默认值，这个服务主要由 ExecStart 指定的指令启动，启动后常驻内存。
                forking       由ExecStart启动的程序通过spawns延伸出其他子程序作为服务，子程序启动后终止父程序
                oneshot       与simple类似，但工作完成后结束，不常驻内存
                dbus          与simple类似，但必须获取一个D-Bus后才继续运行，设置此值通常须设定BusName=
                idle          与simple类似，此服务须其他所有程序都顺利执行后才会执行，通常是开机到最后才执行
            EnvironmentFile   环境设置文件
            ExecStart         执行服务的指令，除Type=oneshot不支持 &lt;, &gt;, &gt;&gt;, |, &amp; 等特殊字符
            ExecStartPre      开启服务前执行的指令
            ExecStartPost     开启服务后执行的指令
            ExecStop          与systemctl stop有关，关闭此服务执行的指令。
            ExecReload        与systemctl reload有关的指令
            Restart           当此值为1时，服务终止后会自动重启服务，只能用systemctl关闭
            RemainAfterExit   当此值为1时，服务所属程序全部终止后，此服务重启。
            TimeoutSec        当此服务无法正常启动或关闭时，多久进入强制结束的状态
            KillMode          关闭模式
                process       服务终止后，只终止主要程序（ExecStart后面的指令）
                control-group 由此服务所产生的其他程序也会关闭
                none          不关闭程序
            RestartSec        当服务因Restart重启，需要sleep多少时间再重启，默认100ms
        [Install]  将此unit安装到哪个target里面
            WantedBy   此服务属于哪个target unit，通常为multi-user.target
            Also       服务设置enable时，指定的unit也需设置enable
            Alias      别名

    systemd 常见服务类型（根据文件名可大概判断）
        .service    一般服务类型 (service unit)：主要是系統服務，经常使用，最常见！
        .socket     内部程序资料交换的通信服务 (socket unit)：较少用到
        .target     执行环境类型 (target unit)：通常为一堆服务unit的集合
        .mount      文件系统挂载服务(mount unit)
        .automount  文件系统自动挂载服务 (automount unit)：例如来自网络的自动挂载、NFS等
        .path       检测特定文件类型 (path unit)：某些服务需要侦测特定目录来提供服务，需.path服务支持
        .timer      循环执行的服务 (timer unit)：类似anacrontab，由systemd提供的，更有弹性！

    常见target unit说明
        graphical.target  文字+图形界面 已包含multi-user.target 項目
        multi-user.target 純文字模式
        rescue.target     无法使用root登入系统的情况时，systemd开机时的格外系统
        emergency.target  需要root登入的紧急处理错误，无法使用rescue.target时可尝试
        shutdown.target   开机流程
        getty.target      可设定需要几个tty等，如需要降低tty的項目，可以修改此设定

    systemctl  管理服务
        start unit_name      立即启动所指定的服务
        stop unit_name       立即停止所指定的服务
        restart unit_name    立即重启所指定的服务
        reload unit_name     不关闭服务的情况下，重新加载配置，让配置生效
        enable unit_name     开机时，服务自动启动
        disable unit_name    开机时，服务不自动启动
        is-active unit_name  目前是否在运行
        is-enable unit_name  是否已设置开机启动
        list-sockets         查看本机所用到的socket file

        status unit_name     显示服务的状态，如是否正在执行、是否开机启动等！
            Loaded    开机时是否启动
                enabled  为启动
                disabled 为不启动
                static   不可设置为开机启动，但可被其他开机启动的服务唤醒
                mask     已被禁止开机启动，可通过systemctl unmask 方式修改
            Active    当前服务是否已经启动
                active (running)  服务已启动，有一个或多个程序在运行
                active (exited)   服务已启动，仅运行一次就正常结束的服务，目前没有在系统中运行
                active (waiting)  服务已启动，但需登台其他事件才能继续运行
                inactive (dead)   这个服务目前没有启动
            Docs      服务的文档文件
            Main PID  服务对应的PID

        systemctl   查看当前系统中所有启动的服务，不加参数等同与 list-units
            UNIT    服务的名称
            LOAD    是否开机启动，默认显示的是启动的
            ACTIVE  目前的状态
            DESCRIPTION 详细描述
        list-units      查看当前系统中所有开机启动的服务
            --type=TYPE -all  列出类型为TYPE的服务，TYPE包括 service, socket, target等
        list-unit-files       显示当前系统中所有服务
        list-dependencies     显示系统间各服务的依赖

        get-default                 获取当前目前的 target
        set-default target_name     设定 target 为默认的操作模式
        isolate target_name         切换到指定 target
        list-dependencies [target]  查看指定的target的依赖关系，默认default.target
            -reverse                查看谁用到了指定的target，默认default.target

        poweroff  系统关机
        reboot    系统重启
        suspend   进入睡眠模式，所有资料保存在内存中，关闭其他大部分硬件
        hibernate 进入休眠模式，资料保存在硬盘中并关机，开机后从硬盘恢复
        rescue    强制进入救援模式
        emergency 强制进入紧急救援模式

    systemd.timer 定时任务设置
        系统需求
            timer.target 需要启动
            name.service 需自定义名字的服务
            name.timer   需要自定义名字的时间启动服务存在，可放在/etc/systemd/system中
        name.timer 设置
            OnActiveSec        当timers.target启动多久后执行此unit
            OnBootSec          当开机后多久执行
            OnStartupSec       当systemd第一次启动后多久执行
            OnUnitActiveSec    此timer配置所管理的unit服务在最后一次启动后隔多久再执行一次
            OnUnitInactiveSec  此timer配置所管理的unit服务在最后一次停止后隔多久再执行一次
            OnCalendar         使用绝对时间来启动服务
            Unit               一般不需要設定，会自动找同名对应服务，不存在可指定
            Persistent         当使用OnCalendar时，该功能是否继续执行，通常为yes
        OnCalendar时间设置
            绝对时间
                格式  英文周名 YYYY-MM-DD HH:MM:SS
                例    Thu 2015-08-13 13:40:00
            时间间隔
                单位
                    us 或 usec：微秒 (10-6 秒)
                    ms 或 msec：毫秒 (10-3 秒)
                    s, sec, second, seconds
                    m, min, minute, minutes
                    h, hr, hour, hours
                    d, day, days
                    w, week, weeks
                    month, months
                    y, year, years
                简称对应时间
                    now         Thu 2015-08-13 13:50:00
                    today       Thu 2015-08-13 00:00:00
                    tomorrow    Thu 2015-08-14 00:00:00
                    hourly      *-*-* *:00:00
                    daily       *-*-* 00:00:00
                    weekly      Mon *-*-* 00:00:00
                    monthly     *-*-01 00:00:00
                    +3h10m      Thu 2015-08-13 17:00:00
                    2015-08-16  Sun 2015-08-16 00:00:00

    相关资源
        http://www.jinbuguo.com/systemd/systemd.service.html
        http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html
</code></pre><h2 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h2><pre><code>常见日志文件
    /var/log/boot.log  开机时的启动日志，只保存最近一次记录
    /var/log/cron      crontab定时任务执行日志
    /var/log/dmesg     开机核心检测过程日志
    /var/log/lastlog   记录系统中所有帐号最近一次登入系统的相关信息
    /var/log/maillog   记录SMTP 和 POP3 产生的信息
    /var/log/messages  记录各类系统错误或重要信息
    /var/log/secure    记录系统中的登入操作，包括su,sudo,ssh,telnet等
    /var/log/wtmp      记录正确登入系统的帐号信息
    /var/log/faillog   记录错误登入系统时使用的帐号信息
    /var/log/httpd/*   记录http服务产生的日志
    /var/log/samba/*   记录samba服务产生的日志

日志相关服务
    systemd-journald.service  由systemd提供的日志接收者，信息保存在内存中，可通过/run/log/查看
    rsyslog.service           统一管理日志文件的服务，主要记录系统与网络服务等信息
    logrotate                 日志文件备份保存工具，备份重命名旧文件，生成新文件

rsyslog.service
    配置文件 /etc/rsyslog.conf
        服务分类
            0     kern(kernel)  kernel所产生的信息，多为硬件检测和核心功能启用
            1     user          用户产生的日志，如 logger 的使用
            2     mail          邮件收发相关日志；
            3     daemon        系统服务产生的日志
            4     auth          认证授权相关信息，如login, ssh, su 等
            5     syslog        rsyslogd 程序所产生的信息
            6     lpr           打印相关的日志
            7     news          新闻服务器相关的信息
            8     uucp          Unix to Unix Copy Protocol，早期用于 unix 系统间的信息通信
            9     cron          定时任务 cron/at 等产生的日志
            10    authpriv      与 auth 相似，多记录帐号私有信息，如 pam 模块的运行等！
            11    ftp,FTP       FTP通信协议有关的日志
            16~23 local0 ~ 7    保留给用户使用的信息，通常和终端互动。
        日志级别
            7   debug   debug信息
            6   info    信息说明
            5   notice  比info更需要引起注意的信息
            4   warning 警告信息，可能存在问题，但不至于影响服务正常运行
            3   err     错误信息，如服务无法启动等
            2   crit    严重错误信息，比error更加严重，critical 的缩写
            1   alert   警告信息，比crit更加严重
            0   emerg   最严重的级别，如硬件出现问题，核心无法正常工作
        连接符
            .      代表小于等于该级别，更加严重的都记录下来
            .=     代表只记录.=后面的级别
            .!     除.!后面的级别都记录
            .none  不记录
        日志保存位置
            本机绝对路径 如/var/log
            打印机等设备 如/dev/lp0
            用户名称，显示给指定用户
            远程主机，如 @study.vbird.tsai，需远程主机支持
            * 代表目前线上所有人
        服务名称
            syslog           Linux核心提供的日志函数
            rsyslogd         具有日志分类等功能的程序， 是最基本的daemon
            rsyslog.service  加入 systemd 的控制，由rsyslogd开发的启动服务脚本设置！

logrotate
    配置文件
        /etc/logrotate.conf
        /etc/logrotate.d/
    logrotate
        -v   在logrotate运行时显示过程信息
        -f   无论是否符合设定，强制执行 rotate

journalctl
    配置文件
        /etc/systemd/journald.conf
    命令及选项
        -n           展示最近的几行信息
        -r           反向输出
        -p           按照重要性排序展示信息
        -f           类似 tail -f 的功能，持续展示 journal 日志内容
        -u           输入指定的unit的日志
        --since      设定开始时间
        --until      设定结束时间
        _COMM=bash   只输出 bash 相关的日志
        _PID=pid     只输出指定 PID 进程的日志
        _UID=uid     只输出指定 UID 用户的日志
        _SYSTEMD_UNIT=unit.service   输出 unit.service 的日志
        SYSLOG_FACILITY=[0-23]       使用 syslog.h 规范服务序号显示日志

logger  保存信息至日志文件
dmesg   打印开机过程保存的日志
logwatch  日志分析工具
</code></pre><h2 id="启动流程模块管理-Loader"><a href="#启动流程模块管理-Loader" class="headerlink" title="启动流程模块管理 Loader"></a>启动流程模块管理 Loader</h2><pre><code>开机过程
    1，读取Bios进行硬件自检，并根据Bios设置获取第一个启动设备
    2，读取并执行设备MBR(Master boot record,主引导记录)的boot loader(grub2,spfdisk等)
    3，根据boot loader设定载入Kernel ，Kernel 开始检测硬件并加载驱动
    4，硬件驱动成功后，Kernel 主动启动 systemd 程序，并以 default.target 流程开机；
        systemd 执行 sysinit.target 初始化系统及 basic.target 准备操作系统
        systemd 启动 multi-user.target 下的本机与服务器服务
        systemd 执行 multi-user.target 下的 /etc/rc.d/rc.local 文件
        systemd 执行 multi-user.target 下的 getty.target 及登入服务
        systemd 执行 graphical 需要的服务

boot loader功能
    提供选择不同loader的选项
    加载操作系统核心
    将开机管理功能交给其他loader负责

/boot/相关文件
    config                  内核编译时的功能和模块设置文件
    grub/                   旧版 grub1 相关文件
    grub2/                  启动管理程序 grub2 相关文件
    initrd.gz               内存虚拟磁盘映像
    initramfs-0-rescue.img  救援模式用到的系像文件
    initramfs.img           正常开机用到的系统文件
    initramfskdump.img      内核题时用到的系统文件
    System.map              内核功能放置到内存的地址对应表
    vmlinuz-0-rescue*       救援模式用到的内核文件
    vmlinuz*                内核二进制文件

开机过程中的配置文件
    /etc/modules-load.d/*.conf       核心模块加载配置
    /etc/modprobe.d/*.conf           可附加参数的模块配置
    /etc/sysconfig/authconfig        规范用户身份认证机制，如是否可用/etc/passwd, /etc/shadow等
    /etc/sysconfig/cpupower          cpupower.service服务的配置，规定系统如何高效利用CPU
    /etc/sysconfig/firewalld         firewalld系统防火墙配置
    /etc/sysconfig/iptables-config   iptables系统防火墙配置
    /etc/sysconfig/network-scripts/  网卡设定

核心 &amp; 核心模块
    文件位置
        /boot/vmlinuz[-version]           核心文件
        /boot/initramfs[-version]         核心解压缩RAM Disk
        /lib/modules/version/kernel       核心模块
        /lib/modules/$(uname -r)/kernel   核心模块
        /usr/src/linux                    核心源码
        /usr/src/kernels/                 核心源码
        /proc/version                     核心版本
        /proc/sys/kernel/                 系统核心功能
    新硬件安装驱动
        重新编译内核，并加入最新的硬件驱动
        将该硬件驱动编译为模块，开机载入该模块
    核心模块
        模块目录
            arch     硬件平台相关模块，如CPU等级等
            crypto   内核支持的加密基数，如 md5  des 等
            drivers  硬件驱动，如显卡，网卡，PCI 等
            fs       内核所支持的 filesystems ，如 vfat, reiserfs, nfs 等
            lib      一些函数库；
            net      网络相关协议资料，防火墙模块 (net/ipv4/netfilter/*) 等
            sound    音效相关模块
        模块依赖文件
            /lib/modules/$(uname -r)/modules.dep
        depmod  生成模块依赖文件
            -n  ：不写入 modules.dep ，而是将结果输出到屏幕上(standard out)；
            -e  ：显示出目前已加载的不可执行的模块名
        lsmod  查看已加载的模块
            字段意义
                Module    模块名称
                size      模块大小
                Used by   被哪些模块使用
        modinfo  看看模块信息
            -a [module_name]  仅列出作者名称
            -d [module_name]  仅列出该 modules 的说明 (description)；
            -l [module_name]  仅列出授权 (license)；
            -n [module_name]  仅列出该模块的的詳細路径。
        modprobe 依据modules.dep依赖关系加载模块
            -c             列出目前系统中所有模块
            -f module_name 强制加载模块
            -r module_name 删除模块 类似 rmmod
        insmod   根据文件名加载模块，不依据modules.dep
        rmmod    删除模块
        核心模块额外参数设置  /etc/modprobe.d/*conf

Boot Loader: Grub2
    Grub2文件
        /grub2/device.map                    grub2 的设备对应文件
        /grub2/fonts                         开机画面的字体
        /grub2/grub.cfg                      grub2 主设置文件，重要，不建议修改
        /grub2/grubenv                       环境区块文件
        /grub2/i386-pc                       针对x86PC所需要的grub2的相关模块
        /grub2/locale                        语系相关文件
        /grub2/themes                        开机主题画面相关文件
        /grub2/i386-pc/acpi.mod              電源管理相关模块
        /grub2/i386-pc/ata.mod               磁盘相关模块
        /grub2/i386-pc/chain.mod             进行 loader 控制权限移交相关模块
        /grub2/i386-pc/command.lst           指令相关性列表
        /grub2/i386-pc/efiemu32.o            uefi BIOS 32位相关模块
        /grub2/i386-pc/efiemu64.o            uefi BIOS 64位相关模块
        /grub2/i386-pc/efiemu.mod            uefi BIOS 64位相关模块
        /grub2/i386-pc/ext2.mod              EXT 文件系统家族模块
        /grub2/i386-pc/fat.mod               FAT 文件系统模块
        /grub2/i386-pc/gcry_sha256.mod       sha256加密模块
        /grub2/i386-pc/gcry_sha512.mod       sha512加密模块
        /grub2/i386-pc/iso9660.mod           光盘文件系统模块
        /grub2/i386-pc/lvm.mod               LVM文件系统模块
        /grub2/i386-pc/mdraid09.mod          软磁盘阵列模块
        /grub2/i386-pc/minix.mod             MINIX相关文件系统模块
        /grub2/i386-pc/msdospart.mod         一般 MBR 分区表
        /grub2/i386-pc/part_gpt.mod          GPT 分区表
        /grub2/i386-pc/part_msdos.mod        MBR 分区表
        /grub2/i386-pc/scsi.mod              SCSI 相关模块
        /grub2/i386-pc/usb_keyboard.mod      USB键盘相关模块
        /grub2/i386-pc/usb.mod               USB相关模块
        /grub2/i386-pc/vga.mod               VGA 显卡相关模块
        /grub2/i386-pc/xfs.mod               XFS 文件系统模块
    Grub2优点
        支持较多文件系统，可由Grub2程序直接在文件系统中搜索系统内核文件
        可自定义开机选项
        动态载入设置文件，修改设置文件后不需要重新安装Grub2，重启后生效
    /etc/default/grub 主要环境配置文件
        GRUB_TIMEOUT             默认倒数描述
        GRUB_DEFAULT             默认开机选项菜单
        GRUB_TIMEOUT_STYLE       是否隐藏选单
        GRUB_DISABLE_SUBMENU     是否隐藏子菜单
        GRUB_TERMINAL_OUTPUT     指定信息输出终端格式，默认是文字终端机
        GRUB_CMDLINE_LINUX       核心启动时的格外参数
        GRUB_DISABLE_RECOVERY    关闭救援模式菜单
    grub2-mkconfig  依据/etc/default/grub重建grub.cfg
    grub2 菜单生产脚本 /etc/grub.d/*
        00_header      主要建立初始显示信息，包括终端机格式显示秒数等
        10_linux       分析/boot下文件，尝试找到正确的linux核心读取核心文件和模块
        30_os-prober   默认到其他partition里面的操作系统并添加到菜单中
        40_custom      可在这里手动添加其他的启动项目
    dracut  生成新的initramfs文件
        -f             强制编译initramfs，如果initramfs文件已经存在则覆盖
        -v             显示dracut运营过程
        --add-drivers  在文件中增加驱动核心模块
        --modules      将dracut所提供的模块载入，usr/lib/dracut/modules.d/
        --gzip|--bzip2 选择压缩方式对initramfs压缩。默认gzip
        --filesystems  加入格外的文件系统资支持
</code></pre><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><pre><code>网络设置
    网卡名称
        eno1     主板内置网卡
        ens1     主板内置的PCI-E网卡
        enp2s0   PCI-E独立网卡，多个插槽会有s0, s1... 等编号
        eth0     (Ethernet) 上述名称都不适用时，恢复默认网卡编号
    hostnamectl  查看或修改主机名称
        set-hostname [host-name] 修改主机名称

日期时间设置
    timedatectl  查看或设置系统日期时区
        list-timezones   列出系統上所有支持时区
        set-timezone     设置时区
        set-time         设置时间
        set-ntp          设置网络校时
    ntpdate 设定网络校时服务器
    hwclock 手动依据网络校时服务器更新时间

语言设置
    locale  当前环境语系
    localectl  查询设置系统语言
        set-locale  设置系统语言
</code></pre><h2 id="核心编译"><a href="#核心编译" class="headerlink" title="核心编译"></a>核心编译</h2><pre><code>核心目录
    arch            与硬件平台相关内容，通常为是 CPU 的类别，如 x86, x86_64, Xen 虚拟支持等等；
    block           与存储设备和文件系统相关的内容，文件系统是否允许等
    crypto          核心支持的加密技术，如 md5，des 等
    Documentation   与核心相关的文档说明
    drivers         硬件相关的驱动程序，如网卡，显卡，PCI设备等
    firmware        旧式硬件的微指令码 (固件) 资料
    fs              核心支持的文件系统 filesystems ，如 vfat, reiserfs, nfs 等
    include         一些可让其他程序呼叫的头(header)定义资料
    init            核心初始化的内容，包括挂载与 init 程序的呼叫等
    ipc             定义 Linux 系统各程序的通信
    kernel          定义核心的程序、核心状态、执行序、程序的排程(schedule)、程序的信号(signle)等
    lib             一些函数库；
    mm              与内存单元有关的各项资料，包括 swap 与虚拟内存等；
    net             与网络有关的各项设定资料，还有防火墙模块 (net/ipv4/netfilter/*) 等
    security        包括 selinux 等在内的安全性设定；
    sound           与音效有关的各项模块；
    virt            与虚拟机有关的信息，目前核心支持的是 KVM (Kernel base Virtual Machine)

生成config编译配置文件
    make menuconfig    最常用，终端图形界面核心功能设置界面
    make oldconfig     以已经存在的./.config文件内容作为默认值，提供新功能的选项
    make xconfig       Qt图形设置界面，需 X window 支持，如 KDE
    make gconfig       Gtk图形设置界面，需 X window 支持，如 GNOME
    make config        旧版命令行设置方式，每个设置独立选择

编译
    make vmlinux          编译未经过压缩的核心
    make modules          仅编译核心模块
    make bzImage          编译经过压缩的核心（默认）
    make all              进行如上三种动作
    make -j 4 clean       先清楚临时文件
    make -j 4 bzImage     编译核心
    make -j 4 modules     编译核心模块

安装
    make modules_install  安装模块
</code></pre><h2 id="硬件设备名"><a href="#硬件设备名" class="headerlink" title="硬件设备名"></a>硬件设备名</h2><pre><code>IDE硬盘机              /dev/hd[a-d]
SCSI/SATA/U盘硬盘机    /dev/sd[a-p]
U盘                    /dev/sd[a-p](与SATA相同)
软盘机                 /dev/fd[0-1]
打印机 25针:           /dev/lp[0-2]
打印机 USB:            /dev/usb/lp[0-15]
鼠标  USB:             /dev/usb/mouse[0-15]
鼠标  PS2:             /dev/psaux
当前CDROM/DVDROM       /dev/cdrom
当前的鼠标             /dev/mouse
磁带机 IDE:            /dev/ht0
磁带机 SCSI:           /dev/st0
</code></pre><h2 id="apt-get包管理工具"><a href="#apt-get包管理工具" class="headerlink" title="apt-get包管理工具"></a>apt-get包管理工具</h2><pre><code>apt-cache search package 搜索包
apt-cache show package 获取包的相关信息，如说明、大小、版本等
apt-cache depends package 了解使用依赖
apt-cache rdepends package 查看该包被哪些包依赖
sudo apt-get install package 安装包
sudo apt-get install package --reinstall 重新安装包
sudo apt-get -f install package 修复安装包
sudo apt-get remove package 删除包
sudo apt-get remove package --purge 删除包，包括删除配置文件等
sudo apt-get update 更新源
sudo apt-get upgrade 更新已安装的包
sudo apt-get dist-upgrade 升级系统
sudo apt-get dselect-upgrade 使用 dselect 升级
sudo apt-get build-dep package 安装相关的编译环境
apt-get source package 下载该包的源代码
sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包
sudo apt-get check 检查是否有损坏的依赖
</code></pre><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><pre><code>ctrl + c    强行终止
ctrl + l    清屏   相当于clear命令
ctrl + a    光标移动到命令行首
ctrl + e    光标移动到命令行尾
ctrl + u    从光标所在位置删除到行首
ctrl + z    把命令放入后台
ctrl + r    在历史命令中搜索
ctrl + d    输入结束 (eof)，例如邮件结束的时候；
ctrl + m    就是 enter 啦！
ctrl + s    暂停屏幕的输出
ctrl + q    恢复屏幕的输出
</code></pre><h2 id="目录作用"><a href="#目录作用" class="headerlink" title="目录作用"></a>目录作用</h2><pre><code>/bin/                  系统所需要的任意用户可执行的命令
/sbin/                 系统所需要的超级用户才可以执行的命令
/usr/                  系统软件资源目录 unix software resources
    /usr/              存放Unix系统商（比如IBM和HP）开发的程序
    /usr/bin/          任意用户可执行的命令
    /usr/sbin/         超级用户才可以执行的命令
    /usr/include       linux下开发和编译应用程序所需要的头文件
    /usr/lib           常用的动态链接库和软件包的配置文件
    /usr/local/        存放用户自己安装的程序
    /usr/local/bin     本地增加的命令
    /usr/local/lib     本地增加的库
    /usr/doc           linux文档，实际是 /usr/share/doc 的软链接
    /usr/etc           一个极少用到的配置文件存放地
    /usr/games         曾经包含游戏等文件，现在很少用到
    /usr/info          系统相关信息，是 /usr/share/info 的软链接
    /usr/man           man 手册，已经移至 /usr/share/man
    /usr/share         它包含了各种程序间的共享文件，如字体，图标，文档等
    /usr/share/doc     类似应用程序的 man 手册。它包含程序的说明文件，默认配置文件等
    /usr/share/info    不常用，已经被 man 代替
    /usr/share/man     app 的 manual
    /usr/share/icons   应用程序的图标等文件，分为 png，svg 等多种格式
    /usr/share/fonts   字体文件，系统范围内可使用，~/.fonts 仅当前用户可用
    /usr/src           linux 内核的源码和说明文档等
    /usr/tmp           已经被众多发行版抛弃的临时文件夹
    /usr/X11R6         存放X window的目录
/boot/                 启动目录，保存启动数据
/dev/                  设备特殊文件，保存硬件文件
/ect/                  系统管理和配置文件
/home/                 普通用户主目录
/root/                 系统管理员的主目录
/lib/                  函数库文件保存目录
/misc/                 挂载磁带机目录(不常用 因老版linux不存在此目录)
/media/                挂载光盘目录(不常用 因老版linux不存在此目录)
/mnt/                  让用户临时挂载其他的文件系统，如移动硬盘和U盘
/proc/                 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息
/sys/                  内存挂载点目录，不可直接操作，数据直接写在目录中
/tmp/                  公用的临时文件存储点
/var/                  某些大文件的溢出区，比方说各种服务的日志文件
/opt/                  option-选装,存放第三方厂商开发的程序，软件所有的数据在同一文件夹
/lost+found            这个目录平时是空的，系统非正常关机而留下“无家可归”的文件
</code></pre><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><pre><code>OSI七层网络协议
    1.物理层  Physical Layer
        一个（不一定可靠的）点对点数据直链。定义机械特性；电气特性；功能特性；规程特性
        例如:线路、无线电、光纤
    2.数据链路层  Data-Link Layer
        一个可靠的点对点数据直链。检错与纠错（CRC码）；多路访问；寻址
        例如:以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP
    3.网络层  Network Layer
        在网络的各个节点之间进行地址分配、路由和（不一定可靠的）分发报文。路由（ IP寻址）；拥塞控制。
        例如:IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、X.25
    4.传输层  Transport Layer
        在网络的各个节点之间可靠地分发数据包。所有传输遗留问题；复用；流量；可靠
        例如:TCP、UDP、TLS、RTP、SCTP、SPX、ATP、IL
    5.会话层  Session Layer
        主机间通讯，管理应用程序之间的会话。规定通信时序 ；数据交换的定界、同步，创建检查点等
        例如:ASAP、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets
    6.表示层  Presentation Layer
        数据表示形式，加密和解密，把机器相关的数据转换成独立于机器的数据。规定数据的格式化表示 ，数据格式的转换等
        例如:XDR、ASN.1、SMB、AFP、NCP
    7.应用层  Application Layer
        网络进程到应用程序。针对特定应用规定各层协议、时序、表示等，进行封装 。在端系统中用软件来实现，如HTTP等
        例如:HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP

TCP/IP参考模型
    1 网络接口层 link layer
        例如:以太网、Wi-Fi、MPLS等。
    2 网络互连层 internet layer
        对于TCP/IP来说这是因特网协议（IP）
    3 传输层 transport layer
        例如:TCP、UDP、RTP、SCTP
    4 应用层 application layer
        例如:HTTP、FTP、DNS
</code></pre><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><pre><code>配置文件
    /etc/sysconfig/network-scripts/ifcfg-eth0  IP相关参数配置
        DEVICE=&quot;eth0&quot;                网络卡代号，必须要 ifcfg-eth0 相对应
        HWADDR=&quot;08:00:27:71:85:BD&quot;   就是网络卡地址，若只有一张网卡，可省略此项目
        NM_CONTROLLED=&quot;no&quot;           不要受到其他软件的网络管理！
        ONBOOT=&quot;yes&quot;                 是否默认启动此接口的意思
        BOOTPROTO=none               取得IP的方式，其实关键词只有dhcp，手动可输入none
        IPADDR=192.168.1.100         IP地址
        NETMASK=255.255.255.0        子网掩码
        GATEWAY=192.168.1.254        预设路由
        NETWORK=192.168.1.0          该网段的第一个 IP，可省略
        BROADCAST=192.168.1.255      广播地址啰，可省略
        MTU=1500                     最大传输单元的设定值，若不更改则 可省略
    /etc/resolv.conf  DNS配置文件
    /etc/sysconfig/network  主机名相关配置
    /etc/hosts  hosts配置

网络配置和查询命令
    dig        检查DNS设置
    host       查看某个域名对应的IP
    nslookup   互相查询域名和IP的对应
    hostname   查看主机名
    ifup       开启网络接口
    ifdown     关闭网络接口
    iwconfig   查看设置无线网卡
    iwlist     利用无线网卡进行无线 AP 的侦测与取得相关的数据
    dhclient   手动使用 DHCP 取得IP

    ping
        -c        后面接的是执行 ping 的次数，例如 -c 5 ；
        -n        在输出数据时不进行 IP 与主机名的反查，直接使用 IP 输出(速度较快)；
        -s        发送出去的 ICMP 封包大小，预设为 56bytes，不过你可以放大此一数值；
        -t        TTL 的数值，预设是 255，每经过一个节点就会少一；
        -W        等待响应对方主机的秒数。
        -M        主要在侦测网络的 MTU 数值大小，两个常见的项目是：
            do    代表传送一个 DF (Don&apos;t Fragment) 旗标，让封包不能重新拆包与打包；
            dont  代表不要传送 DF 旗标，表示封包可以在其他主机上拆包与打包
        状态意义
           64 bytes   ICMP的封包大小为64 bytes，这是默认值。可修改此值测试网络内最大的MTU
           icmp_seq   ICMP 所侦测进行的次数，第一次编号为 1 ；
           ttl=       默认255或64，每经过一个带MAC的节点时，TTL减1
           time=      响应时间，越小的响应时间，表示两部主机之间的网络联机越良好！

    traceroute     分析两个主机之间的节点
        -n         可以不必进行主机的名称解析，单纯用 IP ，速度较快！
        -U         使用 UDP 的 port 33434 来进行侦测，这是默认的侦测协议；
        -I         使用 ICMP 的方式来进行侦测；
        -T         使用 TCP 来进行侦测，一般使用 port 80 测试
        -w         若对方主机在几秒钟内没有回声就宣告不治...预设是 5 秒
        -p port    若不想使用 UDP 与 TCP 的默认端口来侦测，可在此改变端口。
        -i device  当前有多台设备，可指定其中一个
        -g gate    与 -i 的参数相仿，只是 -g 后面接的是 gateway 的 IP 就是了。

    netstat  查看网络信息
        -r   列出路由表(route table)，功能如同 route 这个指令；
        -a   将目前系统上所有的连线、监听、Socket 数据都列出来
        -t   列出 tcp 网络封包的数据
        -u   列出 udp 网络封包的数据
        -n   不以程序的服务名称，以端口 (port number) 来显示；
        -l   列出目前正在网络监听 (listen) 的服务；
        -p   列出该网络服务的程序 PID
        -c   可以设定几秒钟后自动更新一次，例如 -c 5 每五秒更新一次网络状态的显示；
        netstat -tlnp  列出目前系统中已开启的网络服务及PID
        网络连接相关状态：
            Proto           网络的封包协议，主要分为 TCP 与 UDP 封包，相关数据请参考服务器篇；
            Recv-Q          非由使用者程序连结到此 socket 的复制的总 bytes 数；
            Send-Q          非由远程主机传送过来的 acknowledged 总 bytes 数；
            Local Address   本地端的 IP:port 情况
            Foreign Address 远程主机的 IP:port 情况
            State           连线状态；
                ESTABLISED  已建立联机的状态；
                SYN_SENT    发出主动联机 (SYN 标志) 的联机封包；
                SYN_RECV    接收到一个要求联机的主动联机封包；
                FIN_WAIT1   该插槽服务(socket)已中断，该联机正在断线当中；
                FIN_WAIT2   该联机已挂断，但正在等待对方主机响应断线确认的封包；
                TIME_WAIT   该联机已挂断，但 socket 还在网络上等待结束；
                LISTEN      通常用在服务的监听 port ！可使用『 -l 』参数查阅。
        本机进程相关状态：
            Proto   一般就是 unix 啦；
            RefCnt  连接到此 socket 的程序数量；
            Flags   连线的旗标；
            Type    socket 存取的类型。主要有确认连线的 STREAM 与不需确认的 DGRAM 两种；
            State   若为 CONNECTED 表示多个程序之间已经连线创建。
            Path    连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。

    nmap  扫描主机和开启的服务和端口
        -sT    扫瞄 TCP 封包已建立的联机 connect() ！
        -sS    扫瞄 TCP 封包带有 SYN 卷标的数据
        -sP    以 ping 的方式进行扫瞄
        -sU    以 UDP 的封包格式进行扫瞄
        -sO    以 IP 的协议 (protocol) 进行主机的扫瞄
        -PT    使用 TCP 里头的 ping 的方式来进行扫瞄，可以获知目前有几部计算机存活(较常用)
        -PI    使用实际的 ping (带有 ICMP 封包的) 来进行扫瞄
        -p     这个是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式
        [Hosts 地址与范围]：这个有趣多了，有几种类似的类型
            192.168.1.100  ：直接写入 HOST IP 而已，仅检查一部；
            192.168.1.0/24 ：为 C Class 的型态，
            192.168.*.*　　：嘿嘿！则变为 B Class 的型态了！扫瞄的范围变广了
            192.168.1.0-50,60-100,103,200 ：这种是变形的主机范围

    ifconfig   查询、设定网卡与 IP 网域等相关参数
        up, down    启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)
        mtu         可以设定不同的 MTU 数值，例如 mtu 1500 (单位为 byte)
        netmask     就是子屏蔽网络
        broadcast   就是广播地址啊
        查询状态意义
            eth0          网络卡的代号，也有 lo 这个 loopback ；
            HWaddr        网络卡的硬件地址，俗称的 MAC 地址；
            inet addr     IPv4 的 IP 地址，后续的 Bcast, Mask 分别代表的是 Broadcast 与 netmask
            inet6 addr    是 IPv6 的版本的 IP
            MTU           每次MAC封包数据的最大字节数
            RX            网络由启动到目前为止的封包接收量，packets封包数、errors错误量、dropped丢弃封包量
            TX            与 RX 相反，为网络由启动到目前为止的传送情况；
            collisions    代表封包碰撞的情况，如果发生太多次， 表示你的网络状况不太好；
            txqueuelen    代表用来传输数据的缓冲区的储存长度；
            RX bytes      总接收节总量
            TX bytes      总发送字节总量

    route  查看路由表
        -n           不要使用通讯协议或主机名，直接使用 IP 或 port number；
        -ee          使用更详细的信息来显示
        add          新增路由
        del          删除路由
            -net     表示后面接的路由为一个网域；
            -host    表示后面接的为连接到单部主机的路由；
            netmask  与网域有关，可以设定 netmask 决定网域的大小；
            gw       gateway 的简写，后续接的是 IP 的数值喔，与 dev 不同；
            dev      如果只是要指定由那一块网络卡联机出去，则使用这个设定，后面接 eth0 等
        状态意义
            Destination  其实就是 Network 的意思；
            Gateway      该接口的 Gateway 那个 IP 啦！若为 0.0.0.0 表示不需要额外的 IP；
            Genmask      Netmask！与 Destination 组合成为一部主机或网域；
            Flags        共有多个旗标可以来表示该网域或主机代表的意义：
                U        该路由是启动的；
                H        目标是一部主机 (IP) 而非网域；
                G        需要透过外部的主机 (gateway) 来转递封包；
                R        使用动态路由时，恢复路由信息的旗标；
                D        已经由服务或转 port 功能设定为动态路由
                M        路由已经被修改了；
                !        这个路由将不会被接受(用来抵挡不安全的网域！)
            Iface        Interface (接口) 的意思。

    ip   查询修改网络设置,比ifconfig route 更加全面
        link          关于装置 (device) 的相关设定，包括 MTU, MAC 地址等等
        addr/address  关于额外的 IP 协议，例如多 IP 的达成等等；
        route         与路由有关的相关设定

    arp  查看本机 MAC/IP 对应表
        -n   将主机名以 IP 的型态显示
        -d   将 hostname 的 hardware_address 由 ARP table 当中删除掉
        -s   设定某个 IP 或 hostname 的 MAC 到 ARP table 当中

远程联机相关命令
    telnet  通过telnet连接远程主机
    lftp    自动化脚本FTP

    ftp     从FTP服务器下载文件
        连接主机后可执行的命令
            help            提供需要的指令说明，可以常参考！
            dir             显示远程服务器的目录内容 (文件名列表)
            cd /pub         变换目录到 /pub 当中
            get filename    下载单一档案，档名为 filename
            mget filename*  下载多个档案，可使用通配符 *
            put filename    上传 filename 这个档案到服务器上
            delete file     删除主机上的 file 这个档案
            mkdir dir       建立 dir 这个目录
            lcd /home       切换『本地端主机』的工作目录
            passive         启动或关闭 passive 模式
            binary          数据传输模式设定为 binary 格式
            bye             结束 ftp 软件的使用

    links  文本网页浏览
        进入程序后的快捷键
            h    history ，曾经浏览过的 URL 就显示到画面中
            g    Goto URL，按 g 后输入网页地址(URL) 如 :http://www.abc.edu/等
            d    download，将该链接数据下载到本机成为档案；
            q    Quit，离开 links 这个软件；
            o    Option，进入功能参数的设定值修改中，最终可写入 ~/.elinks/elinks.conf 中

    wget   文本接口下载工具
        --http-user        设置用户名
        --http-password    设置密码
        --quiet            不要显示 wget 在抓取数据时候的显示讯息
        /etc/wgetrc        配置文件

    tcpdump  抓包工具
        -A   封包的内容以 ASCII 显示，通常用来捉取 WWW 的网页封包资料。
        -e   使用资料连接层 (OSI 第二层) 的 MAC 封包数据来显示；
        -n   直接以 IP 及 port number 显示，而非主机名与服务名称
        -q   仅列出较为简短的封包信息，每一行的内容比较精简
        -X   可以列出十六进制 (hex) 以及 ASCII 的封包内容，对于监听封包内容很有用
        -i   后面接要『监听』的网络接口，例如 eth0, lo, ppp0 等等的界面；
        -w   如果你要将监听所得的封包数据储存下来，用这个参数就对了！后面接文件名
        -r   从后面接的文件将封包数据读出来。这个文件是由 -w 所制作出来的。
        -c   监听的封包数，如果没有这个参数， tcpdump 会持续不断的监听。

    nc  启动 TCP/UDP 封包的端口联机
        -l   作为监听之用，亦即开启一个 port 来监听用户的联机；
        -u   不使用 TCP 而是使用 UDP 作为联机的封包状态
</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><pre><code>相关概念
    静态路由：类似route指令来直接设定路由表到核心功能当中，网域有变化时需重新设定；
    动态路由：透过类似Quagga或zebra软件的功能，动态的侦测网域的变化修改路由表信息。
    NAT：(Network Address Translation)除了路由，多出Public IP与Private IP转换功能。

相关文件
    /proc/sys/net/ipv4/ip_forward  查看是否启用数据包传递，1开启，0未开启
    /etc/sysctl.conf   系统变量设置，可启动数据包传递功能

quagga  动态路由功能，相当于zebra + ripd
    相关服务
        zebra   这个 daemon 的功能在更新核心的路由规则；
        RIP     这个 daemon 则是在向附近的其他 Router 沟通协调路由规则的传送与否。
    配置文件
        /etc/quagga/*.conf
</code></pre><h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><pre><code>TCP wrappers
    配置文件
        /etc/hosts.allow
        /etc/hosts.deny
    语法
        &lt;service(program_name)&gt; : &lt;IP, domain, hostname&gt;
        &lt;服务(亦即程序名称)&gt; : &lt;IP 或 域名 或 主机名&gt;
    例
        ALL: 127.0.0.1     这就是本机全部的服务都接受
        rsync: 192.168.1.0/255.255.255.0 10.0.0.100  多个IP可用空格相加

iptables
    Linux核心默认包含的表格
        raw              用于配置数据包，raw 中的数据包不会被系统跟踪。
        filter           过滤器，主要跟进入 Linux 本机的封包有关，这个是默认的 table
            INPUT        主要与想要进入我们 Linux 本机的封包有关
            OUTPUT       与我们 Linux 本机所要送出的封包有关
            FORWARD      可以转递数据包到后端的计算机中，与下列 nat table 相关性较高。
        nat              是用于存放所有与防火墙相关操作的默认表。
            PREROUTING   在进行路由判断之前所要进行的规则(DNAT/REDIRECT)
            POSTROUTING  在进行路由判断之后所要进行的规则(SNAT/MASQUERADE)
            OUTPUT       与发送出去的封包有关
        mangle           破坏者，这个表格主要是与特殊的封包的路由旗标有关
        security         用于 强制访问控制 网络规则。

    选项与参数
        -t   后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的 filter
        -L   列出目前的 table 的规则
        -n   不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！
        -v   列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等
        -F   清除所有的已订定的规则；
        -X   杀掉所有使用者 &quot;自定义&quot; 的 chain (应该说的是 tables ）啰；
        -Z   将所有的 chain 的计数与流量统计都归零
        -P   定义政策( Policy )

    修改相关的选项与参数
        -A       新增一条规则至最后
        -I       插入一条规则至最前
        -i       封包所进入的那个网络接口，例如 eth0, lo 等接口。需INPUT链配合；
        -o       封包所传出的那个网络接口，需与 OUTPUT 链配合；
        -p       协议：设定此规则适用于哪种封包格式，有tcp, udp, icmp 及 all 。
        -s       来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：
                 IP    192.168.0.100
                 网域   192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。
                 若规范为 不允许 时，则加上 ! 即可，例如：
                 -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；
        -d       目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。
        --syn    SYN标识
        --sport  端口范围：限制来源的端口号码，端口号码可以是连续的，例如 1024:65535
        --dport  端口范围：限制目标的端口号码。
        -m       一些外挂模块，主要常见的有：state状态模块，mac网卡物理地址
        --state  一些封包的状态，主要有：
            INVALID     无效的封包，例如数据破损的封包状态
            ESTABLISHED 已经联机成功的联机状态；
            NEW         想要新建立联机的封包状态；
            RELATED     这个最常用！表示这个封包是与我们主机发送出去的封包有关
        -j       后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)

    状态与意义
        target       代表进行的动作， ACCEPT放行，REJECT拒绝，DROP丢弃
        prot         代表使用的封包协议，主要有 tcp, udp 及 icmp 三种封包格式
        opt          额外的选项说明
        source       代表此规则是针对哪个 来源 IP 进行限制？
        destination  代表此规则是针对哪个 目标 IP 进行限制？

    IPv4 的核心管理功能
        防止利用TCP SYN Flooding 的 DoS 攻击
            相关文件
                /proc/sys/net/ipv4/tcp_syncookies
            原理
                当启动 SYN Cookie 时，主机在发送 SYN/ACK 确认封包前，
                会要求 Client 端在短时间内回复一个序号，
                这个序号包含许多原本 SYN 封包内的信息，
                包括 IP、port 等。若 Client 端可以回复正确的序号，
                那么主机就确定该封包为可信的，因此会发送 SYN/ACK 封包，否则就不理会此一封包。

    防止数据包很大的Ping攻击 ping flooding DoS 攻击
        相关文件
            /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
        原理
            可利用防火墙取消 ICMP 类型 8 的 ICMP 封包回应就是了
            也可通过核心功能禁止ping
            icmp_echo_ignore_broadcasts (仅有 ping broadcast 地址时才取消 ping 的回应)
            icmp_echo_ignore_all (全部的 ping 都不回应)

    针对不通的网络接口实现不通的参数设置
        相关文件
            /proc/sys/net/ipv4/conf/网络接口/*
</code></pre><p>##远程联机与服务器</p>
<pre><code>SSH联机过程
    1.服务器建立公钥档，文件保存在/etc/ssh/ssh_host*
    2.客户端主动联机要求
    3.服务器传送公钥档给客户端，保存在客户端~/.ssh/known_hosts
    4.客户端保存/对比服务器的公钥数据及随机计算自己的公私钥：
    5.回传客户端的公钥数据到服务器端：
    6.开始双向加解密

ssh 命令联机选项与参数
    -f  需要配合后面的 [指令] ，不登入远程主机直接发送一个指令过去而已；
    -o  参数项目：主要的参数项目有：
            ConnectTimeout=秒数 ：联机等待的秒数，减少等待的时间
            StrictHostKeyChecking=[yes|no|ask]：默认 ask，若要让 public key
            主动加入 known_hosts ，则可以设定为 no 即可。
    -p  指定端口，非默认22端口时使用

文件位置
    /etc/ssh/sshd_config   sshd服务配置文件
    ~/.ssh/known_hosts     服务器的公钥记录文件

sftp  通过SSH上传下载文件
    针对Server的行为
        cd PATH                 变换目录
        ls                      列出目前下文件名
        mkdir directory         建立目录
        rmdir directory         删除目录
        pwd                     显示目前所在的目录
        chgrp groupname PATH    更改档案或目录群组
        chown username PATH     更改档案或目录拥有者
        chmod 644 PATH          更改档案或目录的权限
        ln oldname newname      建立连结档
        rm PATH                 删除档案或目录
        rename oldname newname  更改档案或目录名称
        exit                    离开远程主机
    针对本机的命令前需加l(L的小写)
        lcd PATH                变换目录到本机的PATH 当中
        lls                     列出目前本机所在目录下的文件名
        lmkdir                  在本机建立目录
        lpwd                    显示目前所在的本机目录
    文件上传下载相关行为
        put [LocalDir] [ServerDir]   发送文件至远程服务器
        put [LocalDir]               发送文件至远程服务器
        get [ServerDir] [LocalDir]   从服务器下载文件
        get [ServerDir]              从服务器下载文件

scp  档案的直接复制
    -p   保留原本档案的权限数据；
    -r   复制来源为目录时，可以复制整个目录 (含子目录)
    -l   可以限制传输的速度，单位为 Kbits/s

sshd  服务配置
    关于 SSH Server 的整体设定
        Port 22                    SSH服务的的端口，多行此字段用来开放多个端口
        Protocol 2                 选择的 SSH 协议版本，2,1可支持旧版
        ListenAddress 0.0.0.0:22   监听地址和端口，可通过多行监听多个地址
        PidFile /var/run/sshd.pid  放置 SSHD 这个 PID 的文件
        LoginGraceTime 2m          在输入密码过程中，超时自动断线时间
        Compression delayed        使用压缩传输，有yes,no与登入后压缩delayed
    主机的 Private Key 放置的文件
        HostKey /etc/ssh/ssh_host_key      SSH version 1 使用的私钥
        HostKey /etc/ssh/ssh_host_rsa_key  SSH version 2 使用的 RSA 私钥
        HostKey /etc/ssh/ssh_host_dsa_key  SSH version 2 使用的 DSA 私钥
    关于日志文件的信息数据放置与 daemon 的名称！
        SyslogFacility AUTHPRIV     可用[DAEMON|USER|AUTH|LOCAL0~5]
        LogLevel INFO               日志级别
    登入设定部分
        PermitRootLogin yes         是否允许 root 登入！默认yes，建议设定成 no！
        StrictModes yes             是否让 sshd 去检查用户家目录或相关档案的权限数据，
        PubkeyAuthentication yes    是否允许自行使用成对的密钥登入。仅version 2
        AuthorizedKeysFile .ssh/authorized_keys  公钥文件位置
        PasswordAuthentication yes  密码验证当然是需要的
        PermitEmptyPasswords no     是否允许以空的密码登入
    认证部分
        RhostsAuthentication no     是否使用.rhosts（使用不安全）
        IgnoreRhosts yes            是否取消使用 ~/.ssh/.rhosts 来做为认证
        RhostsRSAAuthentication no  使用rhosts配合RSA进行认证，用于version 1
        HostbasedAuthentication no  与上类似，用于version 2
        IgnoreUserKnownHosts no     是否忽略家目录内的 ~/.ssh/known_hosts
        ChallengeResponseAuthentication no  允许任何的密码认证
        UsePAM yes                  利用 PAM 管理使用者认证
    与Kerberos有关的参数设定！
        KerberosAuthentication no
        KerberosOrLocalPasswd yes
        KerberosTicketCleanup yes
        KerberosTgtPassing no
    在 X-Window 底下使用的相关设定
        X11Forwarding yes           是否允许窗口的数据透过 ssh 信道来传送
        X11DisplayOffset 10
        X11UseLocalhost yes
    登入后的项目：
        PrintMotd yes               登入后是否显示出一些信息呢？例如上次登入的时间、地点等等
        PrintLastLog yes            显示上次登入的信息
        TCPKeepAlive yes            保持TCP连接，连接过程中通过TCP包检测是否掉线。
        UsePrivilegeSeparation yes  是否权限较低的程序来提供用户操作
        MaxStartups 10              同时允许几个尚未登入的联机画面，密码界面
    关于用户限制的设定项目：
        DenyUsers *                 设定受限制的使用者名称
        DenyGroups test             设置受限制的使用组名称
    关于 SFTP 服务与其他的设定项目！
        Subsystem  sftp             /usr/lib/ssh/sftp-server
        UseDNS yes                  通过DNS反查用户主机是否合法
</code></pre><h2 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h2><pre><code>工作方式
    1.客户端：播UDP数据包发送搜索 DHCP 服务器，包的目标IP为255.255.255.255
    2.服务器端：提供客户端网络相关的租约以供选择，IP根据MAC是否存在和是否静态来判断
    3.客户端：决定选择的 DHCP 服务器提供的网络参数租约并回报服务器
    4.服务器端：记录该次租约行为并回报客户端已确认的响应封包信息

相关文件
    /etc/dhcp/dhcpd.conf         配置文件
    /usr/sbin/dhcpd              二进制执行文件
    /var/lib/dhcp/dhcpd.leases   客户端租约到期日文件
    /var/lib/dhcp/dhclient*      客户端租约所记载的信息
    /var/lib/dhcpd/dhcpd.leases  服务器记录客户端租约的文件
</code></pre><h2 id="NFS文件服务器"><a href="#NFS文件服务器" class="headerlink" title="NFS文件服务器"></a>NFS文件服务器</h2><pre><code>RPC (Remote Procedure Call)
    1.客户端会向服务器端的 RPC (port 111) 发出 NFS 档案存取功能的询问要求
    2.服务器端找到对应的已注册的 NFS daemon 端口后，会回报给客户端
    3.客户端了解正确的端口后，就可以直接与 NFS daemon 来联机

相关服务
    rpc.nfsd   主要NFS服务，管理客户端是否能够使用服务器文件系统挂载信息等
    rpc.mountd 管理 NFS 的文件系统，包括用户文件权限等
    rpc.lockd  非必要，这个玩意儿可以用在管理档案的锁定 (lock) 用途
    rpc.statd  非必要，可以用来检查档案的一致性，与 rpc.lockd 有关

所需软件
    rpcbind    RPC 主程序
    nfs-utils  NFS 主程序，提供rpc.nfsd 及 rpc.mountd

相关文件
    /etc/exports         主要配置文件
    /usr/sbin/exportfs   NFS文件系统维护指令
    /var/lib/nfs/*tab    分享资源的日志，etab记录权限设置，xtab记录客户端数据
    /usr/sbin/showmount  客户端查询服务器分享资源的指令

配置说明
    格式
        [分享目录] [第一部主机(权限)] [可用主机名] [可用通配符]
    例子
        /tmp  192.168.100.0/24(ro)  localhost(rw)  *.ncku.edu.tw(ro,sync)
    权限规则
        rw              该目录分享的权限是可擦写(read-write)
        ro              该目录分享的权限是可擦写(read-only)
        sync            数据会同步写入到内存与硬盘中
        async           数据会先暂存于内存当中，而非直接写入硬盘！
        no_root_squash  允许客户端以root身份操作文件，不转换身份
        root_squash     当客户端的身份为root时，自动转换为nfsnobody
        all_squash      客户端任何身份都会被压缩为匿名用户，通常是nobody(nfsnobody)
        anonuid         anonymous匿名UID设定
        anongid         anonymous匿名GID设定
    rpcinfo  显示RPC服务状态
        -p   针对某 IP (未写则预设为本机) 显示出所有的 port 与 porgram 的信息；
        -t   针对某主机的某支程序检查其 TCP 封包所在的软件版本；
        -u   针对某主机的某支程序检查其 UDP 封包所在的软件版本；
    showmount  查看NFS联机状态
        -a   显示目前主机与客户端的 NFS 联机分享的状态；
        -e   显示某部主机的 /etc/exports 所分享的目录数据。
    exportfs  重新处理设置文件
        -a  全部加载(或卸除)/etc/exports 档案内的设定
        -r  重新加载/etc/exports 里面的设定，同时更新 /etc/exports 及 /var/lib/nfs/xtab
        -u  卸除某一目录
        -v  在 export 的时候，将分享的目录显示到屏幕上！
</code></pre><h2 id="NIS-帐号管控服务器"><a href="#NIS-帐号管控服务器" class="headerlink" title="NIS 帐号管控服务器"></a>NIS 帐号管控服务器</h2><pre><code>NIS提供的数据
    /etc/passwd         提供用户账号、UID、GID、家目录所在、Shell 等等
    /etc/group          提供群组数据以及 GID 的对应，还有该群组的加入人员
    /etc/hosts          主机名与 IP 的对应，常用于 private IP 的主机名对应
    /etc/services       每一种服务 (daemons) 所对应的端口 (port number)
    /etc/protocols      基础的 TCP/IP 封包协定，如 TCP, UDP, ICMP 等
    /etc/rpc            每种 RPC 服务器所对应的程序号码
    /var/yp/ypservers   NIS 服务器所提供的数据库

NIS环境组件
    NIS Master server   将档案建置成数据库，并提供 slave server 来更新；
    NIS Slave server    以 Master server 的数据库作为本身的数据库来源；
    NIS client          向 master/server 要求登入者的验证数据。

NIS运行流程
    NIS Server (master/slave) 的运作程序：
        1.NIS Master 先将本身的账号密码相关档案制作成为数据库档案；
        2.NIS Master 可以主动的告知 NIS slave server 来更新；
        3.NIS slave 亦可主动的前往 NIS master server 取得更新后的数据库档案；
        4.若有账号密码的异动时，需要重新制作 database 与重新同步化 master/slave。
    NIS Client 有任何登入查询的需求时：
        1.NIS client 若有登入需求时，会先查询其本机的 /etc/passwd, /etc/shadow 等档案；
        2.若在 NIS Client 本机找不到相关的账号数据，才开始向整个 NIS 网域的主机广播查询；
        3.每部 NIS server (不论 master/slave) 都可以响应，基本上是『先响应者优先』。

NIS Server 设置
    NIS 服务器所需要的软件
        yp-tools   提供 NIS 相关的查寻指令功能
        ypbind     提供 NIS Client 端的设定软件
        ypserv     提供 NIS Server 端的设定软件
        rpcbind    就是 RPC 一定需要的数据啊
    NIS 服务器相关的配置文件
        /etc/ypserv.conf        主要配置文件，可以规范 NIS 客户端是否可登入的权限。
        /etc/hosts              NIS server/client 需要主机和IP的对应关系
        /etc/sysconfig/network  可以在这个档案内指定 NIS 的网域 (nisdomainname)。
        /var/yp/Makefile        NIS 数据库相关的配置文件
    NIS 服务器提供的服务
        /usr/sbin/ypserv         NIS 服务器的主要提供服务；
        /usr/sbin/rpc.yppasswdd  提供NIS 客户端用户通过yppasswd修改密码的服务
    与账号密码的数据库有关的指令
        /usr/lib64/yp/ypinit  建立数据库的指令(32位的系统/usr/lib/yp/ypinit)；
        /usr/bin/yppasswd     NIS客户端有关，主要在让用户修改服务器上的密码。
    NIS server 的设定与启动
        1.设定 NIS 的域名 (NIS domain name)
            vim /etc/sysconfig/network
                NISDOMAIN=vbirdnis       设定NIS域名
                YPSERV_ARGS=&quot;-p 1011&quot;    设定NIS每次都启动在固定的端口
        2.编辑主要配置文件 /etc/ypserv.conf
        3.设定主机名与 IP 的对应 (/etc/hosts)
        4.启动与观察所有相关的服务
        5.处理账号并建立数据库
            /usr/lib64/yp/ypinit -m

NIS Client端的设定
    NIS client 端所需要的软件
        ypbind     与 ypserv 互相沟通的客户端联机软件
        yp-tools   是提供查询的软件
    相关配置文件
        /etc/sysconfig/network     设置NIS的域名
        /etc/hosts                 设置NIS服务器的IP与主机名对应关系
        /etc/yp.conf               ypbind 的主要配置文件，里面主要设定 NIS 服务器所在
        /etc/sysconfig/authconfig  规范账号登入时的允许认证机制；
        /etc/pam.d/system-auth     需要在 PAM 模块内加入 NIS 的支持
        /etc/nsswitch.conf         这个文件可以规范账号密码与相关信息的查询顺序
    相关程序
        /usr/bin/yppasswd  更改你在 NIS database(NIS Server 所制作的数据库)的密码
        /usr/bin/ypchsh    更改你在 NIS database 的 shell
        /usr/bin/ypchfn    更改你在 NIS database 的一些用户的讯息
    NIS client 的设定与启动（两种方式）
        1，通过Linux distributions的配置工具，如CentOS的setup
        2，手动修改配置如下配置文件
            /etc/sysconfig/network      加入 NISDOMAIN 项目
            /etc/nsswitch.conf          修改许多主机验证功能的顺序
            /etc/sysconfig/authconfig   CentOS 的认证机制
            /etc/pam.d/system-auth      许多登入所需要的 PAM 认证过程
            /etc/yp.conf                亦即是 ypbind 的配置文件
    NIS client 端的检验
        yptest    可测试NIS数据库
        ypwhich   可检验数据库数量
        ypcat     读取数据库内
</code></pre><h2 id="NTP服务器"><a href="#NTP服务器" class="headerlink" title="NTP服务器"></a>NTP服务器</h2><pre><code>相关概念
    GMT      格林威治时间为标准时间 (Greenwich Mean Time, GMT 时间)
    UTC      Coordinated Universal Time (协和标准时间)，利用原子震荡周期计时。
    NTP      Network Time Protocol
    DTSS     Digital Time Synchronization Protocol
    软件时钟  由 Linux 操作系统根据 1970/01/01 开始计算的总秒数；
    硬件时钟  主机硬件系统上面的时钟，例如 BIOS 记录的时间；

NTP服务运行过程
    1.首先，主机当然需要启动这个 daemon ，之后，
    2.Client 会向 NTP Server 发送出调校时间的 message ，
    3.然后 NTP Server 会送出目前的标准时间给 Client ，
    4.Client 接收了来自 Server 的时间后，会据以调整自己的时间，就达成了网络校时咯！

相关程序
    ntp      就是 NTP 服务器的主要软件啦，包括配置文件以及执行档等等。
    tzdata   软件名称为『 Time Zone data 』的缩写，提供各时区对应的显示格式。

配置文件
    /etc/ntp.conf         NTP服务器的主要配置文件，也是唯一的一个；
    /usr/share/zoneinfo/  由tzdata所提供，为各时区的时间格式对应文件。
    /etc/sysconfig/clock  设定时区与是否使用UTC时间钟的配置文件。
    /etc/localtime        本地端的时间配置文件，复制clock指定的zoneinfo文件

相关命令
    /bin/date          用于 Linux 时间 (软件时钟) 的修改与显示的指令；
    /sbin/hwclock      用于 BIOS 时钟 (硬件时钟) 的修改与显示的指令。
    /usr/sbin/ntpd     主要提供NTP服务的程序！配置文件为 /etc/ntp.conf
    /usr/sbin/ntpdate  用于客户端的时间校正，不启动NTP仅需要矫正时间时使用

NTP服务配置 ntp.conf
    通过restrict来管理权限控制
        restrict [你的IP] mask [netmask_IP] [parameter]
        parameter包括：
            ignore      拒绝所有类型的NTP联机
            nomodify    客户端不能使用ntpc与ntpq这两支程序来修改服务器的时间参数，
                        但客户端仍可透过这部主机来进行网络校时的；
            noquery     不提供NTP的网络校时，客户端不能使用ntpq,ntpc指令查询时间服务器
            notrap      不提供trap这个远程事件登录 (remote event logging) 的功能。
            notrust     拒绝没有认证的客户端。
    通过server设定上层 NTP 服务器
        server [IP or hostname] [prefer]
    通过driftfile记录时间差异
        driftfile [可以被 ntpd 写入的目录与档案]
        driftfile 后面接的档案需要使用完整路径文件名；
            driftfile 后面接的档案需要使用完整路径文件名；
            该档案不能是连结档；
            该档案需要设定成 ntpd 这个 daemon 可以写入的权限。
            该档案所记录的数值单位为：百万分之一秒 (ppm)。
    ntpstat  查看ntp运行状态
    ntpq     NTP查询程序
        -p   列出目前我们的 NTP 与相关的上层 NTP 的状态
            remote    亦即是 NTP 主机的 IP 或主机名，*为正在起作用，+为候选
            refid     参考的上一层 NTP 主机的地址
            st        就是 stratum 阶层啰！
            when      几秒钟前曾经做过时间同步化更新的动作；
            poll      下一次更新在几秒钟之后；
            reach     已经向上层 NTP 服务器要求更新的次数
            delay     网络传输过程当中延迟的时间，单位为 10^(-6) 秒
            offset    时间补偿的结果，单位与 10^(-3) 秒
            jitter    Linux 系统时间与 BIOS 硬件时间的差异时间， 单位为 10^(-6) 秒。
    date  显示或设置系统时间
        时间格式 MMDDhhmmYYYY
    hwclock  显示或设置Bios时间
        -r   亦即 read ，读出目前 BIOS 内的时间参数；
        -w   亦即 write ，将目前的 Linux 系统时间写入 BIOS 当中啊！
    ntpdate  手动进行网络校时
</code></pre><h2 id="Samba服务器"><a href="#Samba服务器" class="headerlink" title="Samba服务器"></a>Samba服务器</h2><pre><code>相关概念
    NFS      Unix Like上面可以分享档案数据的file system
    CIFS     Windows网上邻居所使用的文件系统 (Common Internet File System)
    SAMBA    支持Unix Like和Windows数据分享的文件系统 (Server Message Block - SMB)
    NetBIOS  由IBM开发 (Network Basic Input/Output System)

SAMBA使用的daemons
    nmbd   用来管理工作组、NetBIOS name 等等的解析。使用UDP协议，port 137,138
    smbd   管理SAMBA主机分享的目录、档案与打印机等等。使用TCP协议，port 139,445

联机模式
    peer/peer (对等模式)
    domain model (主控模式)

SAMBA服务器设置
    所需软件
        samba         提供SMB服务器所需的各项服务程序 (smbd及nmbd)文件、
                      以及其他与 SAMBA 相关的 logrotate 配置文件及开机默认选项档案等；
        samba-client  提供当Linux做为SAMBA Client端时，所需要的工具指令，
                      如挂载SAMBA文件格式的 mount.cifs、获取网邻相关树形图的smbtree等；
        samba-common  这个软件提供的则是服务器与客户端都会使用到的数据，
                      包括SAMBA的主要配置文件(smb.conf)、语法检验指令(testparm)等；
    相关配置文件
        /etc/samba/smb.conf    Samba的主要配置文件
        /etc/samba/lmhosts     lmhosts的NetBIOS name对应的IP文件，非必须，早期使用
        /etc/sysconfig/samba   提供启动 smbd, nmbd 时，你还想要加入的相关服务参数。
        /etc/samba/smbusers    Windows与Linux在管理员与访客的帐号对应文件
        /var/lib/samba/private/{passdb.tdb,secrets.tdb}   帐号密码数据库文件
        /usr/share/doc/samba-&lt;版本&gt;  这个目录包含了SAMBA的所有相关的文档手册
    可执行文件
        Server
            /usr/sbin/smbd       权限管理
            /usr/sbin/nmbd       NetBIOS name查询
            /usr/bin/tdbdump     查看Samba TDB数据库内容。
            /usr/bin/tdbtool     进入TBD数据库操作接口直接手动修改帐密参数。
            /usr/bin/smbstatus   可以列出目前 Samba 的联机状况。
            /usr/bin/smbpasswd   修改Samba账户的密码
            /usr/bin/pdbedit     用来管理用户账号密码
            /usr/bin/testparm    检查配置文件smb.conf的语法是否正确
        Client
            /sbin/mount.cifs     挂载Samba远程分享的文件
            /usr/bin/smbclient   查看其他计算机分享的目录
            /usr/bin/nmblookup   类似 nslookup，检查 NetBIOS name
            /usr/bin/smbtree     查询工作组与计算机名称的树状目录分布图
    Server配置流程
        1.服务器整体设定方面：在smb.conf中设定工作组、NetBIOS name、密码使用状态等
        2.规划准备分享的目录参数：在smb.conf中设定要分享的目录或装置以及可供使用的账号数据
        3.建立所需要的文件系统：建立好分享出去的档案或装置，以及相关的权限参数
        4.建立可用Samba的账号：建立所需的Linux实体账号，再以pdbedit建立使用Samba的密码
        5.启动服务：启动 Samba 的 smbd, nmbd 服务，开始运转
    smb.conf设置
        参数意义
            workgroup          工作组的名称：注意，主机群要相同；
            netbios name       主机的 NetBIOS 名称啊，每部主机均不同；
            server string      主机的简易说明，这个随便写即可。
            log file           日志文件位置，文件名可能会使用变量处理
            max log size       日志最大仅能到多少 Kbytes ，若大于该数字，则会被rotate掉。
            security           [share|user|domain]三选一，这三个设定值分别代表：
                share          分享的数据不需要密码，大家均可使用 (没有安全性)；
                user           使用 SAMBA 服务器本身的密码数据库
                domain         使用外部服务器的密码，需 password server = IP 的设置
            encrypt passwords  是否需要加密
            passdb backend     数据库格式
            comment            只是这个目录的说明而已
            path               分享目录
            browseable         是否让所有的用户看到这个项目
            writable           是否可以写入
            create mask        新文件权限
            directory mask     目录权限
            writelist          使用者, @群组
        smb.conf 内的可用变量
            %S    目前的设定项目值
            %m    Client 端的 NetBIOS 主机名喔！
            %M    Client 端的 Internet 主机名喔！就是 HOSTNAME。
            %L    SAMBA 主机的 NetBIOS 主机名。
            %H    用户的家目录。
            %U    目前登入的使用者的使用者名称
            %g    登入的使用者的组名。
            %h    目前这部 SAMBA 主机的 HOSTNAME！不是 NetBIOS name
            %I    Client 的 IP
            %T    目前的日期与时间
    testparm  检查smb.conf的语法设定正确性
        -v    检查完整的参数设定，连同默认值也会显示出来
    pdbedit   管理用户账号密码
        -L    列出目前在数据库当中的账号与 UID 等相关信息；
        -v    需要搭配 -L 来执行，可列出更多的讯息，包括家目录等数据；
        -w    需要搭配 -L 来执行，使用旧版的 smbpasswd 格式来显示数据；
        -a    新增一个可使用 Samba 的账号，后面的账号需要在 /etc/passwd 内存在者；
        -r    修改一个账号的相关信息，需搭配很多特殊参数，请 man pdbedit；
        -x    删除一个可使用 Samba 的账号，可先用 -L 找到账号后再删除；
        -m    后面接的是机器的代码 (machine account)，与 domain model 有关！
    smbpasswd  修改密码

Linux客户端设置
    smbclient  查看计算机分享的目录
        -L //[IP|hostname] [-U username]  查看指定计算机分享的目录
    mount -t cifs  挂载远程分享的Samba目录
        -t cifs //IP/分享资源 /挂载点 [-o options]
        options 可用参数
            username=你的登入账号：例如 username=smb1
            password=你的登入密码：需要与上面 username 相对应啊！
            iocharset=本机的语系编码方式，如 big5 或 utf8 等等；
            codepage=远程主机的语系编码方式，例如繁体中文为cp950
    nmblookup   查询 NetBIOS name 与 IP 及其他相关信息：
        -S   除了查询 name 的 IP 之外，亦会找出该主机的分享资源与 MAC 等；
        -U   后面一般可接 Windows 的主要名称管理服务器的 IP ，可与 -R 互用；
        -R   与 -U 互用，以 Wins 服务器来查询某个 Netbios name；
        -A   相对于其他的参数， -A 后面可接 IP ，藉 IP 来找出相对的 NetBIOS 数据；
    smbtree  网络邻居浏览器显示模式！
        -b   以广播的方式取代主要浏览器的查询
        -D   仅列出工作组，不包括分享的资源
        -S   列出工作组与该工作组下的计算机名称 (NetBIOS) 不包括各项资源目录
    smbstatus  查看SAMBA的状态
        -p   列出已经使用 SAMBA 联机的程序 PID ；
        -S   列出已经被使用的资源共享状态；
        -u   只列出某个用户相关的分享数据
</code></pre><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><pre><code>需要的软件
    squid
相关文件
    /etc/squid/squid.conf   squid的主要的配置文件
    /etc/squid/mime.conf    设定squid所支持的mime文件格式
    /usr/sbin/squid         提供 squid 的主程序啊！
    /var/spool/squid        默认的 squid 缓存放置的目录。
    /usr/lib64/squid/       提供 squid 额外的控制模块，如影响认证密码方面的程序
</code></pre><h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h2><pre><code>Client端配置
    相关配置
        /etc/hosts           hostname 对应 IP 的文件；
        /etc/resolv.conf     重要！就是 ISP 的 DNS 服务器 IP 记录处；
        /etc/nsswitch.conf   决定先要使用 /etc/hosts 还是 /etc/resolv.conf
        host   查询域名信息
            -a        代表列出该主机所有的相关信息，包括 IP、TTL 与除错讯息等等
            -l        如指定的domain允许allow-transfer，则列出所管理的所有主机名对应数据
            server    不使用/etc/resolv.conf 而指定 DNS 来查询主机名与 IP 的对应
        nslookup
        dig
            -t   指定查询PR类型
            -x   反向解析，由IP地址解析域名
            查询结果格式
                [domain] [ttl] IN [[RR type] [RR data]]
                [待查数据] [暂存时间(秒)] IN [[资源类型] [资源内容]]
            RR类型
                A           IPv4 的 IP 地址
                AAAA        IPv6 的 IP 地址
                NS          管理这个领域名的服务器主机名字.
                SOA         管理这个领域名的七个重要参数(容后说明)
                MX          顺序数字  接收邮件的服务器主机名字
                CNAME       实际代表这个主机别名的主机名字.

Server搭建DNS
    涉及软件
        BIND    Berkeley Internet Name Domain
    配置文件
        /etc/named.conf       我们的主配置文件啦
        /etc/sysconfig/named  是否启动 chroot 及额外的参数，就由这个档案控制
        /var/named/           数据库档案默认放置在这个目录
        /var/run/named        named 这支程序执行时默认放置 pid-file 在此目录内
    named.conf设置
        listen-on      监听在这部主机系统上面的哪个网络接口。
        directory      默认的zone file正反解析文件目录地址
        allow-query    设置哪些客户端可以使用搭建的 DNS 服务
        forward only   这个设定可以让你的 DNS 服务器仅进行 forward
        forwarders     上层DNS服务器，可设置多个，每个IP以为 &quot;;&quot; 分号结尾
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/12/ES2015-笔记/" itemprop="url">
                  ES2015-笔记.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-12T15:47:52+08:00" content="2016-04-12">
              2016-04-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文是学习<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰 - ECMAScript 6 入门</a>时的笔记，内容为用来作为备忘速查的知识点。推荐大家阅读原版，以便于对ES6有更清晰完整的认识。</p>
<h2 id="版本概述"><a href="#版本概述" class="headerlink" title="版本概述"></a>版本概述</h2><pre><code>说明
    ECMAScript 2016 开始，ECMAScript将进入每年发布一次新标准的阶段。
    浏览器引擎通常6周一次版本。
    ECMA TC39 是制定ECMAScript标准的组织。主要包括各大JS引擎厂商员工。
    最后是通过 ECMA General Assembly 来表决标准是否通过。
</code></pre><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><pre><code>let
    说明
        用来声明变量，和var类似，有块级作用域特性，只在代码块内有效，
        可用于循环，let声明的变量只在本次循环有效
        不允许重复声明
        不存在变量提升
        暂时性死区（temporal dead zone，简称TDZ）
    范例
        无变量提升
            console.log(foo); // 输出undefined
            console.log(bar); // 报错ReferenceError
            var foo = 2;
            let bar = 2;
        暂时性死区
            var tmp = 123;
            if (true) {
              tmp = &apos;abc&apos;; // ReferenceError
              let tmp;
            }

块级作用域中函数声明
    说明
        ES5中规定函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域之中声明。
        虽然浏览器并没有遵守ES5的规定，但在严格模式下函数在块级作用域声明会报错。
        ES6引入了块级作用域，明确允许在块级作用域之中声明函数。
        ES6函数声明类似于var，即会提升到全局作用域或函数作用域的头部.
        ES6中函数特性在不同的浏览器和平台表现不同。开发时需注意平台。
    范例
        function f() { console.log(&apos;I am outside!&apos;); }
        (function () {
          if (false) {
            // 重复声明一次函数f
            function f() { console.log(&apos;I am inside!&apos;); }
          }
          f();
        }());
        //ES5中运行，输出 I am inside!
        //ES6中运行，会报错，f is not a function
        //ES6严格模式下中运行，会输出 I am outside!

const
    说明
        声明常量,不能改变值
        一旦声明变量，就必须立即初始化赋值
        对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。
        其他特性与let相同

全局对象的属性
    说明
        var命令和function命令声明的全局变量，依旧是全局对象的属性；
        let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。
    范例
        var a = 1;
        // 如果在Node的REPL环境，可以写成global.a
        // 或者采用通用方法，写成this.a
        window.a // 1
        let b = 1;
        window.b // undefined
</code></pre><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><pre><code>数组的解构赋值
    说明
        ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。
        如果解构不成功，变量的值就等于undefined。
        等号的右边不是不是可遍历的结构，将会报错。
        只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。
        解构赋值不仅适用于var命令，也适用于let和const命令。
    范例
        数组的解构赋值
            var [a, b, c] = [1, 2, 3];
            let [foo, [[bar], baz]] = [1, [[2], 3]];
            let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
            let [x, , y] = [1, 2, 3];
            let [head, ...tail] = [1, 2, 3, 4];
        不完全解构
            let [x, y] = [1, 2, 3];
            let [a, [b], d] = [1, [2, 3], 4];
        报错情况
            let [foo] = 1;
            let [foo] = false;
            let [foo] = NaN;
            let [foo] = undefined;
            let [foo] = null;
            let [foo] = {};
        对Set结构解构
            let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);
        对提供Iterator接口的数据结构解构
            function* fibs() {
              var a = 0;
              var b = 1;
              while (true) {
                yield a;
                [a, b] = [b, a + b];
              }
            }
            var [first, second, third, fourth, fifth, sixth] = fibs();

默认值
    说明
        解构赋值允许指定默认值。
        如果解构出的值===undefined，那么变量的值将为默认值。
        默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
    范例
        指定默认值
            var [foo = true] = [];             // foo=true
            [x, y = &apos;b&apos;] = [&apos;a&apos;];              // x=&apos;a&apos;, y=&apos;b&apos;
            [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];   // x=&apos;a&apos;, y=&apos;b&apos;
        undefined情况
            var [x = 1] = [undefined];         // x=1
            var [x = 1] = [null];              // x=null
        懒加载情况
            function f() { return 0; };
            let [x = f()] = [1];               // x=1
        默认值可以引用其他变量
            let [x = 1, y = x] = [];           // x=1; y=1
            let [x = 1, y = x] = [2];          // x=2; y=2
            let [x = 1, y = x] = [1, 2];       // x=1; y=2
            let [x = y, y = 1] = [];           // ReferenceError

对象的解构赋值
    说明
        对象的解构赋值没有次序，只要变量与属性同名，即可取到正确的值。
        如果变量名与属性名不一致需指定属性名，格式为 {属性名:变量名}。
        如果变量的声明和赋值是一体的，需注意重复声明会报错。
        解构也可以用于嵌套结构的对象。
        可指定默认值，默认值生效的条件是，对象的属性值严格等于undefined。
        如果解构失败，变量的值等于undefined。
        需注意不能将大括号写在行首，避免JavaScript将其解释为代码块。
        解构赋值允许，等号左边的模式之中，不放置任何变量名，虽然没有意义。
    范例
        变量名属性名一致
            var { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
            // foo=&quot;aaa&quot;  bar=&quot;bbb&quot;
            var { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
            // baz=undefined
        变量名属性名不一致
            var { foo: baz } = { foo: &apos;aaa&apos;, bar: &apos;bbb&apos; };
            // baz=&quot;aaa&quot;
            let obj = { first: &apos;hello&apos;, last: &apos;world&apos; };
            let { first: f, last: l } = obj;
            // f=&apos;hello&apos; l=&apos;world&apos;
        重复声明
            let foo; 
            let {foo} = {foo: 1};        // SyntaxError
            let baz; 
            let {bar: baz} = {bar: 1};   // SyntaxError
            let foo;
            ({foo} = {foo: 1});          // 成功
            let baz;
            ({bar: baz} = {bar: 1});     // 成功
        嵌套
            var obj = {
              p: [&apos;Hello&apos;, {y: &apos;World&apos;}]
            };
            var { p: [x, { y }] } = obj;
            // x=&quot;Hello&quot; y=&quot;World&quot;
        默认值
            var {x = 3} = {};            // x=3
            var {x, y = 5} = {x: 1};     // x=1 y=5
        解构失败
            var {foo} = {bar: &apos;baz&apos;};    // foo=undefined
        不放置任何变量名
            ({} = [true, false]);
            ({} = &apos;abc&apos;);
            ({} = []);
        对数组进行对象属性的解构
            var arr = [1, 2, 3];
            var {0 : first, [arr.length - 1] : last} = arr;
            // first=1 last=3

字符串的解构赋值
    说明
        赋值时，字符串被转换成了一个类似数组的对象
        赋值时，可对字符串的属性解构
    范例
        const [a, b, c, d, e] = &apos;hello&apos;;
        let {length : len} = &apos;hello&apos;;

数值和布尔值的解构赋值
    说明
        解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
        如果等号右边的值无法转换为对象，则报错。
    范例
        let {toString: s} = 123;
        s === Number.prototype.toString   // true
        let { prop: x } = undefined;      // TypeError
        let { prop: y } = null;           // TypeError

函数参数的解构赋值
    说明
        函数的参数可以使用解构赋值。
        函数参数的解构可以使用默认值。
    范例
        函数的参数解构赋值
            function add([x, y]){return x + y;}; add([1, 2]);  //结果为3
            [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b)            // [3,7]
        函数参数的解构使用默认值
            function move({x = 0, y = 0} = {}) {return [x, y]; }
            move({x: 3, y: 8});       // [3, 8]
            move({x: 3});             // [3, 0]
            move({});                 // [0, 0]
            move();                   // [0, 0]
        函数参数的解构使用默认值另外结果
            function move({x, y} = { x: 0, y: 0 }) { return [x, y]; }
            move({x: 3, y: 8});       // [3, 8]
            move({x: 3});             // [3, undefined]
            move({});                 // [undefined, undefined]
            move();                   // [0, 0]

圆括号问题
    说明
        ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
        可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。
        声明语句中，不能带有圆括号。
        函数参数中，函数参数也属于变量声明，因此不能带有圆括号。
        赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。
    范例
        声明语句中(报错)
            var [(a)] = [1];
            var {x: (c)} = {};
            var ({x: c}) = {};
            var {(x: c)} = {};
            var {(x): c} = {};}
            var { o: ({ p: p }) } = { o: { p: 2 } };
        函数参数中(报错)
            function f([(z)]) { return z; }
        赋值语句中(报错)
            ({ p: a }) = { p: 42 };
            ([a]) = [5];
            [({ p: a }), { x: c }] = [{}, {}];
        赋值语句的非模式部分，可以使用圆括号
            [(b)] = [3];
            ({ p: (d) } = {});
            [(parseInt.prop)] = [3];

用途
    范例
        交换变量的值
            [x, y] = [y, x];
        从函数返回多个值
            function example() {return [1, 2, 3]; }
            var [a, b, c] = example();
        函数参数的定义
            function f([x, y, z]) { ... }
            f([1, 2, 3])
        提取JSON数据
            var jsonData = {
                id: 42,
                status: &quot;OK&quot;,
                data: [867, 5309]
            }
            let { id, status, data: number } = jsonData;
        函数参数的默认值
            jQuery.ajax = function (url, {
                async = true,
                beforeSend = function () {},
                cache = true,
                complete = function () {},
                crossDomain = false,
                global = true,
                // ... more config
            }) {
                // ... do stuff
            };
        遍历Map结构
            var map = new Map();
            map.set(&apos;first&apos;, &apos;hello&apos;);
            map.set(&apos;second&apos;, &apos;world&apos;);
            for (let [key, value] of map) {
                console.log(key + &quot; is &quot; + value);
            }
        加载模块的指定方法
            const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre><p>##字符串扩展</p>
<pre><code>字符的Unicode表示法
    说明
        JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。
        超出\u0000——\uFFFF范围的字符，将码点放入大括号，就能正确解读该字符
    范例
        大括号表示Unicode字符
            &quot;\u{20BB7}&quot;              // &quot;𠮷&quot;
            &quot;\u{41}\u{42}\u{43}&quot;     // &quot;ABC&quot;
        6种表示一个字符的方法
            &apos;\z&apos; === &apos;z&apos;             // true
            &apos;\172&apos; === &apos;z&apos;           // true
            &apos;\x7A&apos; === &apos;z&apos;           // true
            &apos;\u007A&apos; === &apos;z&apos;         // true
            &apos;\u{7A}&apos; === &apos;z&apos;         // true

codePointAt()
    说明
        JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。
        需4个字节储存的字符（码点大于0xFFFF），JavaScript会认为它们是两个字符。
        codePointAt方法能够正确处理4个字节储存的字符，返回一个字符的码点。
    范例
        大于0xFFFF的字符
            var s = &quot;𠮷&quot;;
            s.length                       // 2
            s.charAt(0)                    // &apos;&apos;
            s.charAt(1)                    // &apos;&apos;
            s.charCodeAt(0)                // 55362
            s.charCodeAt(1)                // 57271
        codePointAt
            var s = &apos;𠮷a&apos;;
            s.codePointAt(0)               // 134071 既十六进制的20BB7
            s.codePointAt(1)               // 57271
            s.charCodeAt(2)                // 97
            s.codePointAt(0).toString(16)  // &quot;20bb7&quot;
            s.charCodeAt(2).toString(16)   // &quot;61&quot;
        测试一个字符是否是32位字符
            function is32Bit(c) {
                return c.codePointAt(0) &gt; 0xFFFF;
            }
            is32Bit(&quot;𠮷&quot;)   // true
            is32Bit(&quot;a&quot;)    // false

String.fromCodePoint()
    说明
        ES5中的String.fromCharCode方法，可从码点返回对应字符，无法识别32位UTF-16字符
        ES6提供了String.fromCodePoint，功能与fromCharCode类似。
        可以识别32位的UTF-16字符。
        如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。
    范例
        String.fromCharCode(0x20BB7)   // &quot;ஷ&quot;
        String.fromCodePoint(0x20BB7)  // &quot;𠮷&quot;
        String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;
        // true

字符串的遍历器接口
    说明
        ES6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。
        除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点。
    范例
        遍历
            for (let codePoint of &apos;foo&apos;) {
              console.log(codePoint)
            }
        遍历32位字符
            var text = String.fromCodePoint(0x20BB7);
            for (let i = 0; i &lt; text.length; i++) {
              console.log(text[i]);
            }
            // &quot; &quot;
            // &quot; &quot;
            for (let i of text) {
              console.log(i);
            }
            // &quot;𠮷&quot;

at()
    说明
        ES5中的charAt方法，可返回字符串给定位置的字符。但不识别码点大于0xFFFF的字符。
        ES6提案中的at方法识别Unicode编号大于0xFFFF的字符。
    范例
        &apos;abc&apos;.charAt(0)  // &quot;a&quot;
        &apos;𠮷&apos;.charAt(0)    // &quot;\uD842&quot;
        &apos;abc&apos;.at(0)      // &quot;a&quot;
        &apos;𠮷&apos;.at(0)        // &quot;𠮷&quot;

normalize()
    说明
        对于欧洲语言中的带有重音符号等字符，Unicode提供了两种方法表示。
        一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。
        另一种是合成符号，即原字符与重音符号两个字符合成一个字符。
        如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。
        这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。
        ES6提供normalize()方法，用来将字符的不同表示方法统一为同样的形式。
        这称为Unicode正规化。
    参数
        NFC    标准等价合成，默认，指的是视觉和语义上的等价。
        NFD    标准等价分解，在标准等价的前提下，返回合成字符分解的多个简单字符。
        NFKC   兼容等价合成，指的是语义上存在等价，但视觉上不等价。
        NFKD   兼容等价分解，兼容等价的前提下，返回合成字符分解的多个简单字符。
    范例
        不带参数
            &apos;\u01D1&apos;===&apos;\u004F\u030C&apos;   //false
            &apos;\u01D1&apos;.length             // 1
            &apos;\u004F\u030C&apos;.length       // 2
            &apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize()  //true
        带有参数
            &apos;\u004F\u030C&apos;.normalize(&apos;NFC&apos;).length // 1
            &apos;\u004F\u030C&apos;.normalize(&apos;NFD&apos;).length // 2

includes(), startsWith(), endsWith()
    说明
        之前JavaScript只有indexOf方法，用来确定一个字符串是否包含在另一个字符串中。
        ES6又提供了三种新方法，这三个方法都支持第二个参数，表示开始搜索的位置。
    方法
        includes()      返回布尔，表示是否找到了参数字符串。
        startsWith()    返回布尔，表示参数字符串是否在源字符串的头部。
        endsWith()      返回布尔，表示参数字符串是否在源字符串的尾部
    范例
        var s = &apos;Hello world!&apos;;
        s.startsWith(&apos;Hello&apos;)        // true
        s.endsWith(&apos;!&apos;)              // true
        s.includes(&apos;o&apos;)              // true
        s.startsWith(&apos;world&apos;, 6)     // true
        s.endsWith(&apos;Hello&apos;, 5)       // true
        s.includes(&apos;Hello&apos;, 6)       // false

repeat()
    说明
        repeat方法返回一个新字符串，表示将原字符串重复n次。
        参数如果是小数，会被取整。
    范例
        &apos;x&apos;.repeat(3)            // &quot;xxx&quot;
        &apos;hello&apos;.repeat(2)        // &quot;hellohello&quot;
        &apos;na&apos;.repeat(0)           // &quot;&quot;
        &apos;na&apos;.repeat(2.9)         // &quot;nana&quot;
        &apos;na&apos;.repeat(Infinity)    // RangeError
        &apos;na&apos;.repeat(-1)          // RangeError
        &apos;na&apos;.repeat(-0.9)        // &quot;&quot;
        &apos;na&apos;.repeat(NaN)         // &quot;&quot;
        &apos;na&apos;.repeat(&apos;na&apos;)        // &quot;&quot;
        &apos;na&apos;.repeat(&apos;3&apos;)         // &quot;nanana&quot;

padStart()，padEnd()
    说明
        ES7的函数,如果某个字符串不够指定长度，会在头部或尾部补全。
        padStart用于头部补全，padEnd用于尾部补全。
    范例
        &apos;x&apos;.padStart(5, &apos;ab&apos;)               // &apos;ababx&apos;
        &apos;x&apos;.padStart(4, &apos;ab&apos;)               // &apos;abax&apos;
        &apos;x&apos;.padEnd(5, &apos;ab&apos;)                 // &apos;xabab&apos;
        &apos;x&apos;.padEnd(4, &apos;ab&apos;)                 // &apos;xaba&apos;
        &apos;xxx&apos;.padStart(2, &apos;ab&apos;)             // &apos;xxx&apos;
        &apos;xxx&apos;.padEnd(2, &apos;ab&apos;)               // &apos;xxx&apos;
        &apos;abc&apos;.padStart(10, &apos;0123456789&apos;)    // &apos;0123456abc&apos;
        &apos;x&apos;.padStart(4)                     // &apos;   x&apos;
        &apos;x&apos;.padEnd(4)                       // &apos;x   &apos;

模板字符串
    说明
        为解决JS的字符串拼接不便，ES6推出了模板字符串。
        模板字符串（template string）是增强版的字符串，用反引号（`）标识。
        它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
        表示多行字符串时，所有的空格和缩进都会被保留在输出之中。
        模板字符串中嵌入变量，需要将变量名写在${}之中。
    范例
        普通字符串
            `In JavaScript &apos;\n&apos; is a line-feed.`
        多行字符串
            `In JavaScript this is
             not legal.`
            console.log(`string text line 1
            string text line 2`);
        嵌入变量
            var name = &quot;Bob&quot;, time = &quot;today&quot;;
            `Hello ${name}, how are you ${time}?`
        放入表达式
            var x = 1,y = 2;
            `${x} + ${y * 2} = ${x + y * 2}`
            var obj = {x: 1, y: 2};
            `${obj.x + obj.y}`
        调用函数
            function fn() { return &quot;Hello World&quot;;}
            `foo ${fn()} bar`
            // foo Hello World bar

标签模板
    说明
        模板字符可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。
        标签模板函数会收到三个参数，第一个参数为拆分的字符串数组，后续参数为替换的值。
        如果模板字符里面有变量，会将模板字符串先处理成多个参数，再调用函数
    范例
        无参数
            alert`123`    // 等同于alert(123)
        有参数
            var a = 5,b = 10;
            tag`Hello ${ a + b } world ${ a * b }`;
            // 等同于 tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50);

String.raw()
    说明
        String.raw方法，往往用来充当模板字符串的处理函数。
        返回一个斜杠都被转义的字符串，对应于替换变量后的模板字符串.
        作为正常的函数使用时。第一个参数是一个有raw属性的对象，且raw属性的值应该是一个数组。
    范例
        直接使用
            String.raw`Hi\u000A!`;
            // &apos;Hi\\u000A!&apos;
        做为函数使用
            String.raw({ raw: &apos;test&apos; }, 0, 1, 2);
            // &apos;t0e1s2t&apos;
            // 等同于
            String.raw({ raw: [&apos;t&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;] }, 0, 1, 2);
</code></pre><p>##正则的扩展</p>
<pre><code>RegExp构造函数
    说明
        在ES6中，RegExp作为构造函数时，当第一个参数为正则时，允许第二个修饰符参数。
        第二个修饰符参数会覆盖正则中的修饰符
    范例
        new RegExp(/abc/ig, &apos;i&apos;)  //实际修饰符为i

字符串的正则方法
    说明
        ES6将如下4个方法，修改为在语言内部全部调用RegExp的实例方法.
        从而做到所有与正则相关的方法，全都定义在RegExp对象上。
    方法
        String.prototype.match    调用 RegExp.prototype[Symbol.match]
        String.prototype.replace  调用 RegExp.prototype[Symbol.replace]
        String.prototype.search   调用 RegExp.prototype[Symbol.search]
        String.prototype.split    调用 RegExp.prototype[Symbol.split]

u修饰符
    说明
        ES6对正则表达式添加了u修饰符，含义为“Unicode模式”。
        加上u修饰符，. 在正则表达式中可以识别码点大于0xFFFF的Unicode字符。
        ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符。
        使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。
        和i修饰符一起使用，可识别字形相近但编码不同的Unicode字符。
    范例
        匹配32位字符
            /^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)    // false
            /^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)     // true
        点字符
            var s = &apos;𠮷&apos;;
            /^.$/.test(s)    // false
            /^.$/u.test(s)   // true
        Unicode字符表示法
            /\u{61}/.test(&apos;a&apos;)      // false
            /\u{61}/u.test(&apos;a&apos;)     // true
            /\u{20BB7}/u.test(&apos;𠮷&apos;)  // true
        量词
            /a{2}/.test(&apos;aa&apos;)     // true
            /a{2}/u.test(&apos;aa&apos;)    // true
            /𠮷{2}/.test(&apos;𠮷𠮷&apos;)   // false
            /𠮷{2}/u.test(&apos;𠮷𠮷&apos;)  // true
        预定义模式
            /^\S$/.test(&apos;𠮷&apos;)     // false
            /^\S$/u.test(&apos;𠮷&apos;)    // true
        i修饰符
            /[a-z]/i.test(&apos;\u212A&apos;)   // false
            /[a-z]/iu.test(&apos;\u212A&apos;)  // true

y修饰符
    说明
        ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。
        y修饰符的作用与g修饰符类似，也是全局匹配。
        不同的是，y修饰符确保匹配必须从剩余的第一个位置开始。
    范例
        和g修饰符区别
            var s = &apos;aaa_aa_a&apos;;
            var r1 = /a+/g;
            var r2 = /a+/y;
            r1.exec(s)         // [&quot;aaa&quot;]
            r2.exec(s)         // [&quot;aaa&quot;]
            r1.exec(s)         // [&quot;aa&quot;]
            r2.exec(s)         // null
        和g修饰符一起使用
            const REGEX = /a/gy;
            console.log(&apos;aaxa&apos;.replace(REGEX, &apos;-&apos;));
            // &apos;--xa&apos;

sticky属性
    说明
        与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。
    范例
        var r = /hello\d/y;
        r.sticky
        // true

flags属性
    说明
        ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符
    范例
        /abc/ig.source     // &quot;abc&quot;
        /abc/ig.flags      // &apos;gi&apos;

后行断言
    说明
        这个是ES7的提案。
        目前JavaScript只支持正向肯定预查和正向否定预查。
        不支持反向肯定预查和反向否定预查。
    表达式
        (?=pattern)     正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。
        (?!pattern)     正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。
        (?&lt;=pattern)    反向肯定预查，与正向肯定预查类似，只是方向相反。
        (?&lt;!pattern)    反向否定预查，与正向否定预查类似，只是方向相反。
    范例
        /x(?=y)/      //x只有在y前面才匹配
        /x(?!y)/      //x只有不在y前面才匹配
        /(?&lt;=y)x/     //x只有在y后面才匹配
        /(?&lt;!y)x/     //x只有不在y后面才匹配

Unicode属性类
    说明
        这是一个提案。
        引入了一种新的类的写法\p{...}和\P{...}。
        允许正则表达式匹配符合Unicode某种属性的所有字符。
    两种格式
        \p{UnicodePropertyName}
        \p{UnicodePropertyName=UnicodePropertyValue}
    范例
        匹配希腊字符
            const regexGreekSymbol = /\p{Script=Greek}/u;
            regexGreekSymbol.test(&apos;π&apos;)   // true
        匹配所有十进制字符
            const regex = /^\p{Decimal_Number}+$/u;
            regex.test(&apos;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&apos;) // true
        匹配所有数字
            const regex = /^\p{Number}+$/u;
            regex.test(&apos;²³¹¼½¾&apos;)             // true
            regex.test(&apos;㉛㉜㉝&apos;)              // true
            regex.test(&apos;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&apos;)  // true
</code></pre><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><pre><code>二进制和八进制表示法
    说明
        ES6提供了二进制和八进制数值的新的写法。
        分别用前缀0b（或0B）和0o（或0O）表示。
        ES5严格模式之中，八进制不允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示。
    范例
        二进制和八进制表示
            0b111110111 === 503  // true
            0o767 === 503        // true
        转化为10进制
            Number(&apos;0b111&apos;)      // 7
            Number(&apos;0o10&apos;)       // 8

Number.isFinite(), Number.isNaN()
    说明
        ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
    方法
        Number.isFinite()    检查一个数值是否为有限的（finite）
        Number.isNaN()       检查一个值是否为NaN。
    范例
        检查是否有限
            Number.isFinite(15);         // true
            Number.isFinite(0.8);        // true
            Number.isFinite(NaN);        // false
            Number.isFinite(Infinity);   // false
            Number.isFinite(-Infinity);  // false
            Number.isFinite(&apos;foo&apos;);      // false
            Number.isFinite(&apos;15&apos;);       // false
            Number.isFinite(true);       // false
        检查是否为NaN
            Number.isNaN(NaN)            // true
            Number.isNaN(15)             // false
            Number.isNaN(&apos;15&apos;)           // false
            Number.isNaN(true)           // false
            Number.isNaN(9/NaN)          // true
            Number.isNaN(&apos;true&apos;/0)       // true
            Number.isNaN(&apos;true&apos;/&apos;true&apos;)  // true

Number.parseInt(), Number.parseFloat()
    说明
        ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面。
        行为完全保持不变。
    范例
        ES5的写法
            parseInt(&apos;12.34&apos;)               // 12
            parseFloat(&apos;123.45#&apos;)           // 123.45
        ES6的写法
            Number.parseInt(&apos;12.34&apos;)        // 12
            Number.parseFloat(&apos;123.45#&apos;)    // 123.45

Number.isInteger()
    说明
        用来判断一个值是否为整数。
        在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。
    范例
        Number.isInteger(25)      // true
        Number.isInteger(25.0)    // true
        Number.isInteger(25.1)    // false
        Number.isInteger(&quot;15&quot;)    // false
        Number.isInteger(true)    // false

Number.EPSILON
    说明
        ES6在Number对象上面，新增一个极小的常量Number.EPSILON
        引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。
        如果误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。
    范例
        极小常量
            Number.EPSILON               // 2.220446049250313e-16
            Number.EPSILON.toFixed(20)   // &apos;0.00000000000000022204&apos;
        判断误差是否在范围内
            0.1 + 0.2                          // 0.30000000000000004
            0.1 + 0.2 - 0.3                    // 5.551115123125783e-17
            5.551115123125783e-17.toFixed(20)  // &apos;0.00000000000000005551&apos;
            5.551115123125783e-17 &lt; Number.EPSILON   // true

安全整数和Number.isSafeInteger()
    说明
        JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点）。
        ES6引入了两个常量和一个方法用来判断这个范围。
    常量
        Number.MAX_SAFE_INTEGER        可表示的数的最大值
        Number.MIN_SAFE_INTEGER        可表示的数的最小值
    方法
        Number.isSafeInteger()         判断指定的值是否在-2^53到2^53之间
    范例
        常量
            Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1        // true
            Number.MAX_SAFE_INTEGER === 9007199254740991           // true
            Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER   // true
            Number.MIN_SAFE_INTEGER === -9007199254740991          // true
        范围
            Number.isSafeInteger(&apos;a&apos;)                        // false
            Number.isSafeInteger(null)                       // false
            Number.isSafeInteger(NaN)                        // false
            Number.isSafeInteger(Infinity)                   // false
            Number.isSafeInteger(-Infinity)                  // false
            Number.isSafeInteger(3)                          // true
            Number.isSafeInteger(1.2)                        // false
            Number.isSafeInteger(9007199254740990)           // true
            Number.isSafeInteger(9007199254740992)           // false
            Number.isSafeInteger(Number.MIN_SAFE_INTEGER)    // true
            Number.isSafeInteger(Number.MAX_SAFE_INTEGER)    // true
            Number.isSafeInteger(Number.MIN_SAFE_INTEGER-1)  // false
            Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1)  // false

Math对象的扩展
    说明
        ES6在Math对象上新增了17个与数学相关的方法。
        所有这些方法都是静态方法，只能在Math对象上调用。
    方法
        Math.trunc        去除一个数的小数部分，返回整数部分
        Math.sign         判断一个数到底是正数、负数、还是零
        Math.cbrt         计算一个数的立方根
        Math.clz32        返回一个数的32位无符号整数形式有多少个前导0
        Math.imul         返回两个数以32位带符号整数形式相乘的结果
        Math.fround       返回一个数的单精度浮点数形式
        Math.hypot        返回所有参数的平方和的平方根
    对数方法
        Math.expm1        Math.expm1(x)返回ex-1，即Math.exp(x) - 1
        Math.log1p        Math.log1p(x)方法返回1+x的自然对数，即Math.log(1 + x)
        Math.log10        Math.log10(x)返回以10为底的x的对数
        Math.log2         Math.log2(x)返回以2为底的x的对数
    三角函数方法
        Math.sinh(x)      返回x的双曲正弦
        Math.cosh(x)      返回x的双曲余弦
        Math.tanh(x)      返回x的双曲正切
        Math.asinh(x)     返回x的反双曲正弦
        Math.acosh(x)     返回x的反双曲余弦
        Math.atanh(x)     返回x的反双曲正切

指数运算符
    说明
        ES7新增了一个指数运算符（**）
    范例
        2 ** 2                  // 4
        2 ** 3                  // 8
        let b = 3; b **= 3;     // 等同于 b = b * b * b;
</code></pre><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><pre><code>Array.from()
    说明
        Array.from方法用于将类似数组的对象和可遍历对象转为真正的数组。
    范例
        转换类似数组的对象
            let arrayLike = {
                &apos;0&apos;: &apos;a&apos;,
                &apos;1&apos;: &apos;b&apos;,
                &apos;2&apos;: &apos;c&apos;,
                length: 3
            };
            [].slice.call(arrayLike)    //ES5写法  [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
            Array.from(arrayLike)       //ES6写法  [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]

Array.of()
    说明
        Array.of方法用于将一组值，转换为数组。
    范例
        Array.of(3, 11, 8)       // [3,11,8]
        Array.of(3)              // [3]
        Array.of(3).length       // 1
        Array()                  // []
        Array(3)                 // [, , ,]
        Array(3, 11, 8)          // [3, 11, 8]

数组实例的copyWithin()
    说明
        在当前数组实例内部，将指定位置的成员复制（覆盖）到其他位置
    参数
        Array.prototype.copyWithin(target, start = 0, end = this.length)
            target 必需，从该位置开始替换数据。
            start  可选，从该位置开始读取数据，默认为0。如果为负值，表示倒数。
            end    可选，到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
    范例
        [1, 2, 3, 4, 5].copyWithin(0, 3)       // [4, 5, 3, 4, 5]
        [1, 2, 3, 4, 5].copyWithin(0, 3, 4)    // [4, 2, 3, 4, 5]
        [1, 2, 3, 4, 5].copyWithin(0, -2, -1)  // [4, 2, 3, 4, 5]
        [].copyWithin.call({length: 5, 3: 1}, 0, 3)
        // {0: 1, 3: 1, length: 5}

数组实例的find()和findIndex()
    说明
        数组实例的find方法，用于找出第一个符合条件的数组成员。
        它的参数是一个回调函数，对数组元素依次执行函数，如返回值为true，返回该成员。
        如果没有符合条件的成员，则返回undefined。
        findIndex用法与find类似，返回第一个符合条件的元素位置，都不符合条件，则返回-1。
        这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。
    范例
        find
            [1, 4, -5, 10].find((n) =&gt; n &lt; 0)  // -5
            [1, 5, 10, 15].find(function(value, index, arr) {
              return value &gt; 9;
            }) // 10
        findIndex
            [1, 5, 10, 15].findIndex(function(value, index, arr) {
              return value &gt; 9;
            }) // 2
        NaN的判断
            [NaN].indexOf(NaN)                         // -1
            [NaN].findIndex(y =&gt; Object.is(NaN, y))    // 0

数组实例的fill()
    说明
        fill方法使用给定值，填充一个数组
        fill方法可接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
    范例
        [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)            // [7, 7, 7]
        new Array(3).fill(7)               // [7, 7, 7]
        [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)      // [&apos;a&apos;, 7, &apos;c&apos;]

数组实例的entries()，keys()和values()
    说明
        ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。
        它们都返回一个遍历器对象，可以用for...of循环进行遍历。
        keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。
    范例
        for...of遍历
            for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {
              console.log(index);
            }
            for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) {
              console.log(elem);
            }
            for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {
              console.log(index, elem);
            }
        next遍历
            let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
            let entries = letter.entries();
            console.log(entries.next().value);   // [0, &apos;a&apos;]
            console.log(entries.next().value);   // [1, &apos;b&apos;]
            console.log(entries.next().value);   // [2, &apos;c&apos;]

数组实例的includes()
    说明
        该方法属于ES7。
        Array.prototype.includes返回一个布尔值，表示某个数组是否包含给定的值。
        该方法的第二个参数表示搜索的起始位置，默认为0，负数表示倒数。
        相对于indexOf不会误判NaN，且返回的是布尔值。
    范例
        [1, 2, 3].includes(2);       // true
        [1, 2, 3].includes(4);       // false
        [1, 2, NaN].includes(NaN);   // true
        [1, 2, 3].includes(3, 3);    // false
        [1, 2, 3].includes(3, -1);   // true

数组的空位
    说明
        数组的空位指，数组的某一个位置没有任何值。
        Array构造函数返回的数组都是空位。
        空位不是undefined，空位是没有任何值，in运算符可以说明这一点。
        ES5中对不同的函数对空位的处理不一致，ES6则是明确将空位转为undefined。
    ES5中对空位的处理
        forEach(), filter(), every() 和some()都会跳过空位。
        map()会跳过空位，但会保留这个值
        join()和toString()将空位视为undefined，undefined和null会被处理成空字符串。
    ES6中对空位的处理
        Array.from方法会将数组的空位，转为undefined。
        扩展运算符（...）也会将空位转为undefined。
        copyWithin()会连空位一起拷贝。
        fill()会将空位视为正常的数组位置。
        for...of循环也会遍历空位。
        entries、keys、values、find和findIndex会将空位处理成undefined。
    范例
        ES5中对空位的处理
            [,&apos;a&apos;].forEach((x,i) =&gt; console.log(i));     // 1
            [&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true)                 // [&apos;a&apos;,&apos;b&apos;]
            [,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;)                   // true
            [,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;)                  // false
            [,&apos;a&apos;].map(x =&gt; 1)                           // [,1]
            [,&apos;a&apos;,undefined,null].join(&apos;#&apos;)              // &quot;#a##&quot;
            [,&apos;a&apos;,undefined,null].toString()             // &quot;,a,,&quot;
        ES6中对空位的处理
            Array.from([&apos;a&apos;,,&apos;b&apos;])          // [ &quot;a&quot;, undefined, &quot;b&quot; ]
            [...[&apos;a&apos;,,&apos;b&apos;]]                 // [ &quot;a&quot;, undefined, &quot;b&quot; ]
            [,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0)    // [,&quot;a&quot;,,&quot;a&quot;]
            new Array(3).fill(&apos;a&apos;)          // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
            [...[,&apos;a&apos;].entries()]           // [[0,undefined], [1,&quot;a&quot;]]
            [...[,&apos;a&apos;].keys()]              // [0,1]
            [...[,&apos;a&apos;].values()]            // [undefined,&quot;a&quot;]
            [,&apos;a&apos;].find(x =&gt; true)          // undefined
            [,&apos;a&apos;].findIndex(x =&gt; true)     // 0
</code></pre><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><pre><code>函数参数的默认值
    说明
        ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。
        参数变量是默认声明的，所以不能用let或const再次声明。
        参数默认值可以与解构赋值的默认值，结合起来使用。
        通常情况下，定义了默认值的参数，应该是函数的尾参数。
    函数的length属性
        指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。
        如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
    作用域
        如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的。
        即先是当前函数的作用域，然后才是全局作用域。
        如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。
    范例
        默认值
            function Point(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            var p = new Point();
            p  // { x: 0, y: 0 }
        与解构赋值默认值结合使用
            function foo({x, y = 5}) {
                console.log(x, y);
            }
            foo({})             // undefined, 5
            foo({x: 1})         // 1, 5
            foo({x: 1, y: 2})   // 1, 2
            foo() // TypeError: Cannot read property &apos;x&apos; of undefined
        双重默认值
            function m1({x = 0, y = 0} = {}) {
                return [x, y];
            }
        函数的length属性
            (function (a) {}).length               // 1
            (function (a = 5) {}).length           // 0
            (function (a, b, c = 5) {}).length     // 2
            (function (a = 0, b, c) {}).length     // 0
            (function (a, b = 1, c) {}).length     // 1
        参数默认值不是定义时执行
            function throwIfMissing() {
              throw new Error(&apos;Missing parameter&apos;);
            }
            function foo(mustBeProvided = throwIfMissing()) {
              return mustBeProvided;
            }
            foo()
            // Error: Missing parameter

rest参数
    说明
        ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数。
        rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
        rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
        函数的length属性，不包括rest参数。
        和arguments的区别是，arguments并不是数组，无法调用数组相关的方法。
    范例
        function push(array, ...items) {
           items.forEach(function(item) {
              array.push(item);
              console.log(item);
           });
        }
        var a = [];
        push(a, 1, 2, 3);

扩展运算符
    说明
        扩展运算符（spread）是三个点（...）。
        它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。
        能够正确识别32位的Unicode字符。
        任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。
    范例
        函数调用
            function add(x, y) {
                return x + y;
            }
            var numbers = [4, 38];
            add(...numbers);   // 42
        替代apply方法
            // ES5的写法
            function f(x, y, z) {
              // ...
            }
            var args = [0, 1, 2];
            f.apply(null, args);
            // ES6的写法
            function f(x, y, z) {
              // ...
            }
            var args = [0, 1, 2];
            f(...args);
        合并数组
            var arr1 = [&apos;a&apos;, &apos;b&apos;];
            var arr2 = [&apos;c&apos;];
            var arr3 = [&apos;d&apos;, &apos;e&apos;];
            [...arr1, ...arr2, ...arr3]
            // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]
        与解构赋值结合
            const [first, ...rest] = [1, 2, 3, 4, 5];
            first // 1
            rest  // [2, 3, 4, 5]
            const [first, ...rest] = [];
            first // undefined
            rest  // []:
            const [first, ...rest] = [&quot;foo&quot;];
            first  // &quot;foo&quot;
            rest   // []
        字符串
            [...&apos;hello&apos;]                     // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
            &apos;x\uD83D\uDE80y&apos;.length          // 4
            [...&apos;x\uD83D\uDE80y&apos;].length     // 3 \uD83D\uDE80y 是一个32位字符
            let str = &apos;x\uD83D\uDE80y&apos;;
            str.split(&apos;&apos;).reverse().join(&apos;&apos;) // &apos;y\uDE80\uD83Dx&apos;
            [...str].reverse().join(&apos;&apos;)      // &apos;y\uD83D\uDE80x&apos;
        实现了Iterator接口的对象
            var nodeList = document.querySelectorAll(&apos;div&apos;);
            var array = [...nodeList];
        Map和Set结构，Generator函数
            let map = new Map([
                [1, &apos;one&apos;],
                [2, &apos;two&apos;],
                [3, &apos;three&apos;],
            ]);
            let arr = [...map.keys()]; // [1, 2, 3]
            var go = function*(){
                yield 1;
                yield 2;
                yield 3;
            };
            [...go()] // [1, 2, 3]

name属性
    说明
        函数的name属性，返回该函数的函数名。
        这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。
        如果将一个匿名函数赋值给一个变量，ES5中name为空字符串，ES6中name为变量名。
        Function构造函数返回的函数实例，name属性的值为“anonymous”。
        bind返回的函数，name属性值会加上“bound ”前缀。
    范例
        ES5与ES6区别
            var func1 = function () {};
            // ES5
            func1.name // &quot;&quot;
            // ES6
            func1.name // &quot;func1&quot;
        构造函数
            (new Function).name            // &quot;anonymous&quot;
        bind返回的函数
            function foo() {};
            foo.bind({}).name              // &quot;bound foo&quot;
            (function(){}).bind({}).name   // &quot;bound &quot;

箭头函数
    说明
        ES6允许使用“箭头”（=&gt;）定义函数。
        如果不需要参数或需要多个参数，需使用一个圆括号代表参数部分。
        如果的代码块部分多于一条语句，需使用大括号将它们括起来，并且使用return语句返回。
        箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。
        因为没有this，所以也就不能用作构造函数。也不能用call,apply,bind这些方法。
    注意
        函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
        不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
        不可以使用arguments对象，该对象在函数体内不存在。可以用Rest参数代替。
        super、new.target 在箭头函数之中也是不存在的。
        不可以使用yield命令，因此箭头函数不能用作Generator函数。
    范例
        无参数
            var f = () =&gt; 5;
        一个参数
            var f = v =&gt; v;
        多个参数
            var sum = (num1, num2) =&gt; num1 + num2;
        多个参数且代码块多与1行
            var sum = (num1, num2) =&gt; {var sum = num1 + num2; return sum; }
        直接返回一个对象
            var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
        与变量解构结合使用
            const full = ({ first, last }) =&gt; first + &apos; &apos; + last;
        简化回调函数
            [1,2,3].map(x =&gt; x * x);
        与rest参数结合
            const numbers = (...nums) =&gt; nums;
            numbers(1, 2, 3, 4, 5)    // [1,2,3,4,5]
        this值
            function foo() {
              setTimeout(() =&gt; {
                console.log(&apos;id:&apos;, this.id);
              }, 100);
            }
            var id = 21;
            foo.call({ id: 42 });    // id: 42

函数绑定
    说明
        该语法是ES7的一个提案，Babel转码器已经支持。
        函数绑定（function bind）运算符，用来取代call、apply、bind调用。
        函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。
        该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。
        如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。
    范例
        语法
            foo::bar;                 // 等同 bar.bind(foo);
            foo::bar(...arguments);   // 等同 bar.apply(foo, arguments);
            var method = ::obj.foo;   // 等同 var method = obj::obj.foo;
        链式写法
            let { find, html } = jake;
            document.querySelectorAll(&quot;div.myClass&quot;)
            ::find(&quot;p&quot;)
            ::html(&quot;hahaha&quot;);

尾调用优化
    说明
        尾调用优化是某个函数的最后一步是调用另一个函数。
    尾调用优化
        正常函数嵌套调用会在内存中形成一个调用帧组成的调用栈。
        尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧。
        如果所有函数都是尾调用，那么每次执行时，调用帧只有一项，这将大大节省内存。
        只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用。
    尾递归
        函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
        递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误。
        尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
        尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。
    严格模式
        ES6的尾调用优化只在严格模式下开启，正常模式是无效的。
        这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。
        func.arguments：返回调用时函数的参数。
        func.caller：返回调用当前函数的那个函数。
    范例
        尾调用
            function f(x){
                return g(x);
            }
        不属于尾调用
            // 情况一
            function f(x){
              let y = g(x);
              return y;
            }
            // 情况二
            function f(x){
              return g(x) + 1;
            }
            // 情况三
            function f(x){
              g(x);
            }
        尾调用优化
            function f() {
              let m = 1;
              let n = 2;
              return g(m + n);
            }
            f();
            // 等同于
            function f() {
              return g(3);
            }
            f();
            // 等同于
            g(3);
        非尾递归
            function Fibonacci (n) {
                if ( n &lt;= 1 ) {return 1};
                return Fibonacci(n - 1) + Fibonacci(n - 2);
            }
            Fibonacci(10); // 89
            // Fibonacci(100)
            // Fibonacci(500)
            // 堆栈溢出了
        尾递归
            function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
                if( n &lt;= 1 ) {return ac2};
                return Fibonacci2 (n - 1, ac2, ac1 + ac2);
            }
            Fibonacci2(100) // 573147844013817200000
            Fibonacci2(1000) // 7.0330367711422765e+208
            Fibonacci2(10000) // Infinity

函数参数的尾逗号
    说明
        ECMAScript 2017将允许函数的最后一个参数有尾逗号（trailing comma）。
        此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。
    范例
        function clownsEverywhere(
          param1,
          param2,
        ) { /* ... */ }
        clownsEverywhere(
          &apos;foo&apos;,
          &apos;bar&apos;,
        );
</code></pre><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><pre><code>属性的简洁表示法
    说明
        ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
        如果某个方法的值是一个Generator函数，前面需要加上星号。
    范例
        var birth = &apos;2000/01/01&apos;;
        var Person = {
            name: &apos;张三&apos;,
            //等同于birth: birth
            birth,
            // 等同于getPoint: function ()...
            getPoint() {
                var x = 1,y = 10; 
                return {x, y};
            }
            * generatorFun(){
                yield &apos;hello world&apos;;
            }
        };

属性名表达式
    说明
        ES6允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。
        属性名表达式与简洁表示法，不能同时使用，会报错。
    范例
        let propKey = &apos;foo&apos;;
        let obj = {
            [propKey]: true,
            [&apos;a&apos; + &apos;bc&apos;]: 123,
            [&apos;h&apos;+&apos;ello&apos;]() {
                return &apos;hi&apos;;
            }
        };

方法的name属性
    说明
        函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
        如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。
        bind方法创造的函数，name属性返回“bound”加上原函数的名字。
        Function构造函数创造的函数，name属性返回“anonymous”。
    范例
        方法的name属性
            var person = {
                sayName() {
                    console.log(this.name);
                },
                get firstName() {
                    return &quot;Nicholas&quot;;
                }
            };
            person.sayName.name   // &quot;sayName&quot;
            person.firstName.name // &quot;get firstName&quot;
        方法是Symbol值
            const key1 = Symbol(&apos;description&apos;);
            const key2 = Symbol();
            let obj = {
                [key1]() {},
                [key2]() {},
            };
            obj[key1].name  // &quot;[description]&quot;
            obj[key2].name  // &quot;&quot;

Object.is()
    说明
        ES5中，相等(==)会自动转换类型，全等(===)NaN不等于自身。
        ES6中新增Object.is()方法，与全等类似，不同的是+0不等于-0，NaN等于自身。
    范例
        Object.is(&apos;foo&apos;, &apos;foo&apos;)    // true
        Object.is({}, {})          // false
        +0 === -0                  // true
        NaN === NaN                // false
        Object.is(+0, -0)          // false
        Object.is(NaN, NaN)        // true

Object.assign()
    说明
        Object.assign方法用于对象的合并。
        将源对象（source）的所有可枚举属性，复制到目标对象（target）。
        Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
        如果属性名相同，则后面的属性会覆盖前面的属性。
        如果参数不是对象，则会先转成对象。
        undefined和null无法转成对象，作为首参数会报错，作为非首参数参数跳过。
    注意
        Object.assign只拷贝源对象的自身属性，不拷贝继承属性和不可枚举的属性。
        Object.assign方法实行的是浅拷贝，而不是深拷贝。
        如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。
        对于这种嵌套的对象，遇到同名属性，Object.assign的处理方法是替换，而不是添加。
    范例
        同名属性
            var target = { a: 1, b: 1 };
            var source1 = { b: 2, c: 2 };
            var source2 = { c: 3 };
            Object.assign(target, source1, source2);
            target // {a:1, b:2, c:3}
        undefined,null情况
            Object.assign(undefined)               // 报错
            Object.assign()                        // 报错
            let obj = {a: 1};
            Object.assign(obj, undefined) === obj  // true
            Object.assign(obj, null) === obj       // true
        其他类型
            var v1 = &apos;abc&apos;;
            var v2 = true;
            var v3 = 10;
            var obj = Object.assign({}, v1, v2, v3);
            console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
        属性名为Symbol值的属性
            Object.assign({ a: &apos;b&apos; }, { [Symbol(&apos;c&apos;)]: &apos;d&apos; })
            // { a: &apos;b&apos;, Symbol(c): &apos;d&apos; }
        嵌套对象
            var target = { a: { b: &apos;c&apos;, d: &apos;e&apos; } }
            var source = { a: { b: &apos;hello&apos; } }
            Object.assign(target, source)
            // { a: { b: &apos;hello&apos; } }

属性的可枚举性
    说明
        ES6规定，所有Class的原型的方法都是不可枚举的。
        对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。
        Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
    范例
        Class的原型的方法不可枚举
            Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, &apos;foo&apos;).enumerable
            // false
        获取属性描述
            let obj = { foo: 123 };
            Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)
            // {value:123,writable:true,enumerable:true,configurable:true}

属性的遍历
    方法
        for...in
            循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。
        Object.keys(obj)
            返回数组，包括自身（不含继承）的所有可枚举属性（不含Symbol属性）。
        Object.getOwnPropertyNames(obj)
            返回数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）
        Object.getOwnPropertySymbols(obj)
            返回数组，包含对象自身的所有Symbol属性。
        Reflect.ownKeys(obj)
            返回数组，包含对象自身的所有属性，无论是否可枚举，包含Symbol属性。
    遍历顺序
        首先遍历所有属性名为数值的属性，按照数字排序。
        其次遍历所有属性名为字符串的属性，按照生成时间排序。
        最后遍历所有属性名为Symbol值的属性，按照生成时间排序
    范例
        Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
        // [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()]

原型
    __proto__ 
        用来读取或设置当前对象的prototype对象。
        该属性没有写入ES6的正文，而是写入了附录，因浏览器广泛支持，才被加入了ES6。
        标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署。
        新的代码最好认为这个属性是不存在的。
        无论从语义的角度，还是从兼容性的角度，都不要使用这个属性。
    Object.setPrototypeOf()
        用来设置一个对象的prototype对象。
        它是ES6正式推荐的设置原型对象的方法。
    Object.getPrototypeOf()
        该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。
    范例
        __proto__属性
            // es6的写法
            var obj = {
                method: function() { ... }
            };
            obj.__proto__ = someOtherObj;
            // es5的写法``
            var obj = Object.create(someOtherObj);
            obj.method = function() { ... };
        Object.setPrototypeOf
            let proto = {};
            let obj = { x: 10 };
            Object.setPrototypeOf(obj, proto);
            proto.y = 20;
            proto.z = 40;
            obj.x // 10
            obj.y // 20
            obj.z // 40
        Object.getPrototypeOf
            function Rectangle() {};
            var rec = new Rectangle();
            Object.getPrototypeOf(rec) === Rectangle.prototype   // true
            Object.setPrototypeOf(rec, Object.prototype);
            Object.getPrototypeOf(rec) === Rectangle.prototype   // false

Object.values()，Object.entries()
    说明
        这两个方法是ES7的提案。
        Object.values方法返回一个数组，成员是参数对象自身可遍历属性的值。
        Object.entries方法返回一个数组，成员是参数对象自身可遍历属性的键值对数组。
    范例
        Object.values
            var obj = { foo: &quot;bar&quot;, baz: 42 };
            Object.values(obj)    // [&quot;bar&quot;, 42]
            var obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };
            Object.values(obj)    // [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
            var obj = Object.create({}, {p: {value: 42}});
            Object.values(obj)    // []
            Object.values({ [Symbol()]: 123, foo: &apos;abc&apos; });  // [&apos;abc&apos;]
            Object.values(&apos;foo&apos;)  // [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;]
        Object.entries
            var obj = { foo: &apos;bar&apos;, baz: 42 };
            Object.entries(obj)
            // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
            var map = new Map(Object.entries(obj));
            map // Map { foo: &quot;bar&quot;, baz: 42 }

对象的扩展运算符
    说明
        这是ES7的一个提案。
        将Rest运算符（解构赋值），扩展运算符（...）引入对象。
        Babel转码器已经支持这项功能。
        如自定义属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。
        如自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。
        展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。
    范例
        解构赋值
            let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
            x // 1
            y // 2
            z // { a: 3, b: 4 }
        解构赋值报错
            let { x, y, ...z } = null;        // 运行时错误
            let { x, y, ...z } = undefined;   // 运行时错误
            let { ...x, y, z } = obj;         // 句法错误
            let { x, ...y, ...z } = obj;      // 句法错误
        解构赋值浅拷贝
            let obj = { a: { b: 1 } };
            let { ...x } = obj;
            obj.a.b = 2;
            x.a.b // 2
        解构赋值产生的变量只读取对象自身的属性
            var o = Object.create({ x: 1, y: 2 });
            o.z = 3;
            let { x, ...{ y, z } } = o;
            x // 1
            y // undefined
            z // 3
        结构赋值用作函数扩展
            function baseFunction({ a, b }) {
              // ...
            }
            function wrapperFunction({ x, y, ...restConfig }) {
              // 使用x和y参数进行操作
              // 其余参数传给原始函数
              return baseFunction(restConfig);
            }
        扩展运算符
            let z = { a: 3, b: 4 };
            let n = { ...z };
            n // { a: 3, b: 4 }
        扩展运算符用于合并对象
            let ab = { ...a, ...b };
            // 等同于
            let ab = Object.assign({}, a, b);

Object.getOwnPropertyDescriptors()
    说明
        Object.getOwnPropertyDescriptors方法是一个ES7的提案。
        返回指定对象所有自身属性（非继承属性）的描述对象。
        目的主要是为了解决Object.assign，无法正确拷贝get属性和set属性的问题。
        ES5中的Object.getOwnPropertyDescriptor方法，是返回某个对象属性的描述对象。
    范例
        const obj = {
          foo: 123,
          get bar() { return &apos;abc&apos; }
        };
        Object.getOwnPropertyDescriptors(obj)
        // { foo:
        //    { value: 123,
        //      writable: true,
        //      enumerable: true,
        //      configurable: true },
        //   bar:
        //    { get: [Function: bar],
        //      set: undefined,
        //      enumerable: true,
        //      configurable: true } }
</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><pre><code>概述
    说明
        ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。
        它是JavaScript语言的第七种数据类型。
        前六种是：Undefined、Null、Boolean、String、Number、Object。
        Symbol值通过Symbol函数生成。
        对象的属性名现在可以有两种类型，一种是字符串，另一种就是新增的Symbol类型。
        凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。
        Symbol函数前不能使用new命令，生成的Symbol是一个原始类型的值，不是对象。
        Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述。
        Symbol值不能与其他类型的值进行运算。
        Symbol值可以显式转为字符串，布尔值，但是不能转为数值。
    范例
        创建Symbol实例
            let s = Symbol();
            typeof s; // &quot;symbol&quot;
        描述参数
            var s1 = Symbol(&apos;foo&apos;);
            var s2 = Symbol(&apos;bar&apos;);
            s1  // Symbol(foo)
            s2  // Symbol(bar)
            s1.toString()  // &quot;Symbol(foo)&quot;
            s2.toString()  // &quot;Symbol(bar)&quot;
        唯一性
            var s1 = Symbol();
            var s2 = Symbol();
            s1 === s2 // false
            var s1 = Symbol(&quot;foo&quot;);
            var s2 = Symbol(&quot;foo&quot;);
            s1 === s2 // false
        无法参与运算
            var sym = Symbol(&apos;My symbol&apos;);
            &quot;your symbol is &quot; + sym   // TypeError
            `your symbol is ${sym}`   // TypeError
        转为字符串
            var sym = Symbol(&apos;My symbol&apos;);
            String(sym)    // &apos;Symbol(My symbol)&apos;
            sym.toString() // &apos;Symbol(My symbol)&apos;
        转为布尔值
            var sym = Symbol();
            Boolean(sym)  // true
            !sym          // false
            if (sym) {
              // ...
            }
            Number(sym)   // TypeError
            sym + 2       // TypeError

作为属性名的Symbol
    说明
        由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符。
        用于对象的属性名，可保证不会出现同名的属性。
        这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
    范例
        作为对象属性
            var mySymbol = Symbol();
            var a = {};
            a[mySymbol] = &apos;Hello!&apos;;
            var b = {
                [mySymbol]: &apos;Hello!&apos;
            };
            var c = {};
            Object.defineProperty(c, mySymbol, { value: &apos;Hello!&apos; });
            // 以上写法都得到同样结果
            a[mySymbol] // &quot;Hello!&quot;
        对象方法简洁写法
            let s = Symbol();
            let obj = {
                [s](arg) { ... }
            };
        定义一组常量
            log.levels = {
                DEBUG: Symbol(&apos;debug&apos;),
                INFO: Symbol(&apos;info&apos;),
                WARN: Symbol(&apos;warn&apos;)
            };
            log(log.levels.DEBUG, &apos;debug message&apos;);
            log(log.levels.INFO, &apos;info message&apos;);

实例：消除魔术字符串
    说明
        魔术字符串指在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。
        风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。

属性名的遍历
    说明
        Symbol作为属性名不会出现在for...in、for...of循环中。
        也不会被Object.keys()、Object.getOwnPropertyNames()返回。
        Object.getOwnPropertySymbols方法可以获取指定对象的所有Symbol属性名。
        Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。
    范例
        获取Symbol属性
            var obj = {};
            var foo = Symbol(&quot;foo&quot;);
            Object.defineProperty(obj, foo, {
                value: &quot;foobar&quot;,
            });
            for (var i in obj) {
                console.log(i); // 无输出
            }
            Object.getOwnPropertyNames(obj)    // []
            Object.getOwnPropertySymbols(obj)  // [Symbol(foo)]
        Reflect.ownKeys
            let obj = {
                [Symbol(&apos;my_key&apos;)]: 1,
                enum: 2,
                nonEnum: 3
            };
            Reflect.ownKeys(obj)
            // [Symbol(my_key), &apos;enum&apos;, &apos;nonEnum&apos;]

Symbol.for()，Symbol.keyFor()
    说明
        Symbol.for接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。
        有就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。
        Symbol.for生成的实例会被登记在全局环境中供搜索，Symbol不会。
        Symbol.keyFor方法返回一个已登记的Symbol类型值的key。
    范例
        Symbol.for
            var s1 = Symbol.for(&apos;foo&apos;);
            var s2 = Symbol.for(&apos;foo&apos;);
            s1 === s2 // true
        Symbol.keyFor
            var s1 = Symbol.for(&quot;foo&quot;);
            Symbol.keyFor(s1) // &quot;foo&quot;
            var s2 = Symbol(&quot;foo&quot;);
            Symbol.keyFor(s2)  // undefined

内置的Symbol值
    说明
        除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值。
        这些内置的Symbol值指向语言内部使用的方法。
    内置值
        Symbol.hasInstance
            指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。
        Symbol.isConcatSpreadable
            等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。
        Symbol.species
            指向一个方法。该对象作为构造函数创造实例时，会调用这个方法。即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的实例对象。
        Symbol.match
            指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。
        Symbol.replace
            指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。
        Symbol.search
            指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。
        Symbol.split
            指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。
        Symbol.iterator
            指向该对象的默认遍历器方法。
            对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器。
        Symbol.toPrimitive
            指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。
            Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式。
            一共有三种模式: Number,String,Default(可以转换字符串或数值)。
        Symbol.toStringTag
            指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。
        Symbol.unscopables
            指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。
    范例
        Symbol.hasInstance
            class Even {
              static [Symbol.hasInstance](obj) {
                return Number(obj) % 2 === 0;
              }
            }
            1 instanceof Even // false
            2 instanceof Even // true
            12345 instanceof Even // false
        Symbol.isConcatSpreadable
            let arr1 = [&apos;c&apos;, &apos;d&apos;];
            [&apos;a&apos;, &apos;b&apos;].concat(arr1, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]
            arr1[Symbol.isConcatSpreadable] // undefined
            let arr2 = [&apos;c&apos;, &apos;d&apos;];
            arr2[Symbol.isConcatSpreadable] = false;
            [&apos;a&apos;, &apos;b&apos;].concat(arr2, &apos;e&apos;) // [&apos;a&apos;, &apos;b&apos;, [&apos;c&apos;,&apos;d&apos;], &apos;e&apos;]
        Symbol.match
            String.prototype.match(regexp)
            // 等同于
            regexp[Symbol.match](this)
            class MyMatcher {
                [Symbol.match](string) {
                    return &apos;hello world&apos;.indexOf(string);
                }
            }
            &apos;e&apos;.match(new MyMatcher()) // 1
        Symbol.search
            String.prototype.search(regexp)
            // 等同于
            regexp[Symbol.search](this)
            class MySearch {
                constructor(value) {
                    this.value = value;
                }
                [Symbol.search](string) {
                    return string.indexOf(this.value);
                }
            }
            &apos;foobar&apos;.search(new MySearch(&apos;foo&apos;)) // 0
        Symbol.split
            String.prototype.split(separator, limit)
            // 等同于
            separator[Symbol.split](this, limit)
        Symbol.toPrimitive
            let obj = {
                [Symbol.toPrimitive](hint) {
                    switch (hint) {
                        case &apos;number&apos;:
                            return 123;
                        case &apos;string&apos;:
                            return &apos;str&apos;;
                        case &apos;default&apos;:
                            return &apos;default&apos;;
                        default:
                            throw new Error();
                    }
                }
            };
            2 * obj // 246
            3 + obj // &apos;3default&apos;
            obj == &apos;default&apos; // true
            String(obj) // &apos;str&apos;
        Symbol.toStringTag
            ({[Symbol.toStringTag]: &apos;Foo&apos;}.toString())
            // &quot;[object Foo]&quot;
            class Collection {
                get [Symbol.toStringTag]() {
                    return &apos;xxx&apos;;
                }
            }
            var x = new Collection();
            Object.prototype.toString.call(x) // &quot;[object xxx]&quot;
</code></pre><h2 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h2><pre><code>Proxy概述
    说明
        Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改。
        属于一种“元编程”（meta programming），即对编程语言进行编程。
    范例
        var proxy = new Proxy({}, {
            get: function(target, property) {
                return 35;
            }
        });
        proxy.time // 35
        proxy.name // 35

    拦截操作
        get(target, propKey, receiver)
        set(target, propKey, value, receiver)
        has(target, propKey)
        deleteProperty(target, propKey)
        ownKeys(target)
        getOwnPropertyDescriptor(target, propKey)
        defineProperty(target, propKey, propDesc)
        preventExtensions(target)
        getPrototypeOf(target)
        isExtensible(target)
        setPrototypeOf(target, proto)
        apply(target, object, args)
        construct(target, args)

Proxy.revocable()
    说明
        返回一个可取消的Proxy实例。
        Proxy.revocable方法返回一个对象，该对象包含proxy和revoke两个属性。
        proxy是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。
    范例
        let target = {};
        let handler = {};
        let {proxy, revoke} = Proxy.revocable(target, handler);
        proxy.foo = 123;
        proxy.foo // 123
        revoke();
        proxy.foo // TypeError: Revoked

Reflect概述
    说明
        将Object对象的一些明显属于语言内部的方法，放到Reflect对象上。
        修改某些Object方法的返回结果，让其变得更合理。
        让之前某些Object操作都变成函数行为。
        Reflect对象的方法与Proxy对象的方法一一对应。
        不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。
    范例
        var loggedObj = new Proxy(obj, {
            get(target, name) {
                console.log(&apos;get&apos;, target, name);
                return Reflect.get(target, name);
            },
            deleteProperty(target, name) {
                console.log(&apos;delete&apos; + name);
                return Reflect.deleteProperty(target, name);
            },
            has(target, name) {
                console.log(&apos;has&apos; + name);
                return Reflect.has(target, name);
            }
        });

Reflect对象的方法
    方法列表
        Reflect.apply(target,thisArg,args)
        Reflect.construct(target,args)
        Reflect.get(target,name,receiver)
        Reflect.set(target,name,value,receiver)
        Reflect.defineProperty(target,name,desc)
        Reflect.deleteProperty(target,name)
        Reflect.has(target,name)
        Reflect.ownKeys(target)
        Reflect.isExtensible(target)
        Reflect.preventExtensions(target)
        Reflect.getOwnPropertyDescriptor(target, name)
        Reflect.getPrototypeOf(target)
        Reflect.setPrototypeOf(target, prototype)
</code></pre><h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><pre><code>Set
    说明
        ES6提供了新的数据结构Set。类似于数组，但是成员的值都是唯一的，没有重复的值。
        Set本身是一个构造函数，用来生成Set数据结构。
        Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。
        向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。
        Set的遍历顺序就是插入顺序。对Set遍历key和value方法的行为完全一致。
    实例属性
        Set.prototype.constructor     构造函数，默认就是Set函数。
        Set.prototype.size            返回Set实例的成员总数。
    实例方法
        add(value)                    添加某个值，返回Set结构本身。
        delete(value)                 删除某个值，返回一个布尔值，表示删除是否成功。
        has(value)                    返回一个布尔值，表示该值是否为Set的成员。
        clear()                       清除所有成员，没有返回值。
    范例
        构造函数
            var s = new Set();
            [2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));
            for (let i of s) {
              console.log(i);
            }
            // 2 3 5 4
        通过数组初始化
            var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
            [...items]  // [1, 2, 3, 4, 5]
            items.size  // 5
        数组去重
            [...new Set(array)]
        Set转换为Array
            var items = new Set([1, 2, 3, 4, 5]);
            var array = Array.from(items);
        使用数组的map方法
            let set = new Set([1, 2, 3]);
            set = new Set([...set].map(x =&gt; x * 2));
            // 返回Set结构：{2, 4, 6}
        使用数组的filter方法
            let set = new Set([1, 2, 3, 4, 5]);
            set = new Set([...set].filter(x =&gt; (x % 2) == 0));
            // 返回Set结构：{2, 4}
        并集、交集和差集
            let a = new Set([1, 2, 3]);
            let b = new Set([4, 3, 2]);
            let union = new Set([...a, ...b]);
            // 并集 Set {1, 2, 3, 4}
            let intersect = new Set([...a].filter(x =&gt; b.has(x)));
            // 交集 set {2, 3}
            let difference = new Set([...a].filter(x =&gt; !b.has(x)));
            // 差集 Set {1}

WeakSet
    说明
        WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。
        首先，WeakSet的成员只能是对象，而不能是其他类型的值。
        WeakSet中的对象都是弱引用，垃圾回收机制不考虑WeakSet对该对象的引用。
        WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在。
        WeakSet没有size属性，没有办法遍历它的成员。
        WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
    方法
        WeakSet.prototype.add()     向WeakSet实例添加一个新成员
        WeakSet.prototype.delete()  清除WeakSet实例的指定成员
        WeakSet.prototype.has()     返回布尔值，表示某个值是否在实例之中
    范例
        创建
            var ws = new WeakSet();
            var obj = {};
            var foo = {};
            ws.add(window);
            ws.add(obj);
            ws.has(window); // true
            ws.has(foo);    // false
            ws.delete(window);
            ws.has(window);    // false
        遍历
            ws.size    // undefined
            ws.forEach // undefined
            ws.forEach(function(item){ console.log(item)})
            // TypeError: undefined is not a function

Map
    说明
        ES6提供了Map数据结构。它类似于对象，也是键值对的集合。
        Map的“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
        Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。
        Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。
        Map的遍历顺序就是插入顺序。
    实例属性
        size                   返回Map结构的成员总数
    实例方法
        set(key, value)        设置key所对应的值，存在则覆盖，返回整个Map结构。
        get(key)               读取key对应的键值，找不到返回undefined。
        has(key)               返回一个布尔值，表示某个键是否在Map数据结构中
        delete(key)            删除某个键，成功返回true。失败，返回false。
        clear()                清除所有成员，没有返回值。
    遍历
        keys()                 返回键名的遍历器。
        values()               返回键值的遍历器。
        entries()              返回所有成员的遍历器。
        forEach()              遍历Map的所有成员。
    范例
        基本使用
            var m = new Map();
            var o = {p: &apos;Hello World&apos;};
            m.set(o, &apos;content&apos;)
            m.get(o)     // &quot;content&quot;
            m.has(o)     // true
            m.delete(o)  // true
            m.has(o)     // false
        通过数组创建
            var m = new Map([
                [true, &apos;foo&apos;],
                [&apos;true&apos;, &apos;bar&apos;]
            ]);
            m.get(true)    // &apos;foo&apos;
            m.get(&apos;true&apos;)  // &apos;bar&apos;
        覆盖
            let map = new Map();
            map.set(1, &apos;aaa&apos;).set(1, &apos;bbb&apos;);
            map.get(1) // &quot;bbb&quot;
        基础类型作为键
            let map = new Map();
            map.set(NaN, 123);
            map.get(NaN)  // 123
            map.set(-0, 123);
            map.get(+0)   // 123
        转换为数组
            let map = new Map([
                [1, &apos;one&apos;],
                [2, &apos;two&apos;],
                [3, &apos;three&apos;],
            ]);
            [...map.keys()]      // [1, 2, 3]
            [...map.values()]    // [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]
            [...map.entries()]   // [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]
            [...map]             // [[1,&apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;]]

WeakMap
    说明
        WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名。
        键名是对象的弱引用，键名所指向的对象，不计入垃圾回收机制。
        当对象被回收后，WeakMap自动移除对应的键值对。
        WeakMap没有遍历方法和clear方法，也没有size属性。
        基本上WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。
    范例
        var wm = new WeakMap();
        var element = document.querySelector(&quot;.element&quot;);
        wm.set(element, &quot;Original&quot;);
        wm.get(element) // &quot;Original&quot;
        element.parentNode.removeChild(element);
        element = null;
        wm.get(element) // undefined
</code></pre><h2 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h2><pre><code>Iterator（遍历器）的概念
    说明
        它是一种接口，为各种不同的数据结构提供统一的访问机制。
        任何数据结构只要部署Iterator接口，就可以完成遍历操作。
        ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of使用。
        每一次调用next方法，都会返回一个包含value和done两个属性的对象。
        value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
    Iterator的遍历过程
        1. 创建一个指针对象，指向当前数据结构的起始位置。
        2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。
        3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
        4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置。

数据结构的默认Iterator接口
    说明
        当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。
        ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性.
        一个数据结构只要具有Symbol.iterator属性，就可以认为是可遍历的（iterable）。
        ES6中有三类数据结构原生具备Iterator接口：数组、类数组的对象、Set和Map结构。
    范例
        数组的Iterator接口
            let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
            let iter = arr[Symbol.iterator]();
            iter.next()  // { value: &apos;a&apos;, done: false }
            iter.next()  // { value: &apos;b&apos;, done: false }
            iter.next()  // { value: &apos;c&apos;, done: false }
            iter.next()  // { value: undefined, done: true }
        为对象添加Iterator接口
            let obj = {
                data: [&apos;hello&apos;, &apos;world&apos;],
                [Symbol.iterator]() {
                    const self = this;
                    let index = 0;
                    return {
                        next() {
                            if (index &lt; self.data.length) {
                                return {
                                    value: self.data[index++],
                                    done: false
                                };
                            } else {
                                return {
                                    value: undefined,
                                    done: true
                                };
                            }
                        }
                    };
                }
            };
        通过原型部署Iterator接口
            function Obj(value) {
                this.value = value;
                this.next = null;
            }
            Obj.prototype[Symbol.iterator] = function() {
                var iterator = {
                    next: next
                };
                var current = this;
                function next() {
                    if (current) {
                        var value = current.value;
                        current = current.next;
                        return {
                            done: false,
                            value: value
                        };
                    } else {
                        return {
                            done: true
                        };
                    }
                }
                return iterator;
            }
            var one = new Obj(1);
            var two = new Obj(2);
            var three = new Obj(3);
            one.next = two;
            two.next = three;
            for (var i of one) {
                console.log(i);
            }
            // 1
            // 2
            // 3
        为类似数组的对象添加Iterator接口
            NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
            // 或者
            NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];

调用Iterator接口的场合
    说明
        对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。
        扩展运算符（...）也会调用默认的iterator接口。
        yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。
        由于数组的遍历会调用遍历器接口，任何接受数组作为参数的场合，都调用了遍历器接口。
    范例
        解构赋值
            let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);
            let [x,y] = set;             // x=&apos;a&apos;; y=&apos;b&apos;
            let [first, ...rest] = set;  // first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;];
        扩展运算符
            var str = &apos;hello&apos;;
            [...str] //  [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]
            let arr = [&apos;b&apos;, &apos;c&apos;];
            [&apos;a&apos;, ...arr, &apos;d&apos;]
            // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;
        yield*
            let generator = function* () {
                yield 1;
                yield* [2,3,4];
                yield 5;
            };
            var iterator = generator();
            iterator.next() // { value: 1, done: false }
            iterator.next() // { value: 2, done: false }
            iterator.next() // { value: 3, done: false }
            iterator.next() // { value: 4, done: false }
            iterator.next() // { value: 5, done: false }
            iterator.next() // { value: undefined, done: true }

字符串的Iterator接口
    说明
        字符串是一个类似数组的对象，也原生具有Iterator接口。
    范例
        var someString = &quot;hi&quot;;
        typeof someString[Symbol.iterator]  // &quot;function&quot;
        var iterator = someString[Symbol.iterator]();
        iterator.next()  // { value: &quot;h&quot;, done: false }
        iterator.next()  // { value: &quot;i&quot;, done: false }
        iterator.next()  // { value: undefined, done: true }

Iterator接口与Generator函数
    说明
        Symbol.iterator方法的最简单实现是Generator函数。
    范例
        var myIterable = {};
        myIterable[Symbol.iterator] = function*() {
            yield 1;
            yield 2;
            yield 3;
        };
        [...myIterable] // [1, 2, 3]
        // 或者采用下面的简洁写法
        let obj = { * [Symbol.iterator]() {
                yield &apos;hello&apos;;
                yield &apos;world&apos;;
            }
        };
        for (let x of obj) {
            console.log(x);
        }
        // hello

遍历器对象的return()，throw()
    说明
        遍历器对象除了具有next方法，还可以具有return方法和throw方法。
        如果for...of循环提前退出（出错，break或continue），就会调用return方法。
        throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法。
    范例
        function readLinesSync(file) {
            return {
                next() {
                    if (file.isAtEndOfFile()) {
                        file.close();
                        return {
                            done: true
                        };
                    }
                },
                return () {
                    file.close();
                    return {
                        done: true
                    };
                },
            };
        }
        for (let line of readLinesSync(fileName)) {
            console.log(x);
            break;
        }

for...of循环
    说明
        一个数据结构只要部署了Symbol.iterator属性，就可以用for...of循环遍历它的成员。
        for...of循环内部调用的是数据结构的Symbol.iterator方法。
        for...of可以使用的范围包括数组、Set、Map、某些类似数组对象、Generator和字符串。
    范例
        数组
            let arr = [3, 5, 7];
            arr.foo = &apos;hello&apos;;
            for (let i in arr) {
                console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;
            }
            for (let i of arr) {
                console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;
            }
        Set和Map
            var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);
            for (var e of engines) {
                console.log(e);
            }
            // Gecko
            // Trident
            // Webkit
            var es6 = new Map();
            es6.set(&quot;edition&quot;, 6);
            es6.set(&quot;committee&quot;, &quot;TC39&quot;);
            es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);
            for (var [name, value] of es6) {
                console.log(name + &quot;: &quot; + value);
            }
            // edition: 6
            // committee: TC39
            // standard: ECMA-262
</code></pre><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><pre><code>简介
    说明
        Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。
        Generator函数是一个状态机，封装了多个内部状态,还是一个遍历器对象生成函数。
        返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。
        Generator函数一个普通函数，function关键字与函数名之间有一个星号。
        函数体内部使用yield语句，定义不同的内部状态（yield英语意思就是“产出”）。
        Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态。
        yield语句如果用在一个表达式之中，必须放在圆括号里面。
        yield语句用作函数参数或赋值表达式的右边，可以不加括号。
    函数内执行顺序
        遇到yield语句，暂停执行后面的操作，并将yield后面表达式的值作为返回对象的value值。
        下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。
        没有yield就一直运行到函数结束，直到return语句为止，把return的值作为value值。
        如果该函数没有return语句，则返回的对象的value属性值为undefined。
    范例
        基本使用
            function* helloWorldGenerator() {
                yield &apos;hello&apos;;
                yield &apos;world&apos;;
                return &apos;ending&apos;;
            }
            var hw = helloWorldGenerator();
            hw.next()   // { value: &apos;hello&apos;, done: false }
            hw.next()   // { value: &apos;world&apos;, done: false }
            hw.next()   // { value: &apos;ending&apos;, done: true }
            hw.next()   // { value: undefined, done: true }
        赋值给Symbol.iterator
            var myIterable = {};
            myIterable[Symbol.iterator] = function*() {
                yield 1;
                yield 2;
                yield 3;
            };
            [...myIterable]  // [1, 2, 3]

next方法的参数
    说明
        yield句本身没有返回值，或者说总是返回undefined。
        next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。
    范例
        function* foo(x) {
            var y = 2 * (yield(x + 1));
            var z = yield(y / 3);
            return (x + y + z);
        }
        var a = foo(5);
        a.next()   // Object{value:6, done:false}
        a.next()   // Object{value:NaN, done:false}
        a.next()   // Object{value:NaN, done:true}
        var b = foo(5);
        b.next()   // { value:6, done:false }
        b.next(12) // { value:8, done:false }
        b.next(13) // { value:42, done:true }

for...of循环
    说明
        for...of循环可以自动遍历Generator函数时生成的Iterator对象。
        一旦next方法的返回对象的done属性为true，for...of就会中止，且不包含该返回对象。
        扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。
    范例
        基本使用
            function *foo() {
                yield 1;
                yield 2;
                yield 3;
                yield 4;
                yield 5;
                return 6;
            }
            for (let v of foo()) {
                console.log(v);
            }
            // 1 2 3 4 5
        斐波那契数列
            function* fibonacci() {
                let [prev, curr] = [0, 1];
                for (;;) {
                    [prev, curr] = [curr, prev + curr];
                    yield curr;
                }
            }
            for (let n of fibonacci()) {
                if (n &gt; 1000) break;
                console.log(n);
            }
        通过Generator为原生对象添加Iterator接口
            function* objectEntries() {
                let propKeys = Object.keys(this);
                for (let propKey of propKeys) {
                    yield [propKey, this[propKey]];
                }
            }
            let jane = {
                first: &apos;Jane&apos;,
                last: &apos;Doe&apos;
            };
            jane[Symbol.iterator] = objectEntries;
            for (let [key, value] of jane) {
                console.log(`${key}: ${value}`);
            }
            // first: Jane
            // last: Doe
        解构赋值等
            function* numbers() {
                yield 1
                yield 2
                return 3
                yield 4
            }
            [...numbers()]            // [1, 2]
            Array.from(numbers())     // [1, 2]
            let [x, y] = numbers();   // x = 1  y = 2

Generator.prototype.throw()
    说明
        Generator函数返回的遍历器对象，都有一个throw方法。
        它可以在函数体外抛出错误，然后在Generator函数体内捕获。
        如果Generator函数内部没有部署try...catch，那么错误将被外部try...catch捕获。
        在Generator函数内部throw方法被捕获以后，会附带执行下一条yield语句。
        一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。
        如果此后还调用next方法，将返回 {value:undefined,done:true}。
    范例
        var g = function*() {
            try {
                yield;
            } catch (e) {
                console.log(&apos;内部捕获&apos;, e);
            }
        };
        var i = g();
        i.next();
        try {
            i.throw(&apos;a&apos;);
            i.throw(&apos;b&apos;);
        } catch (e) {
            console.log(&apos;外部捕获&apos;, e);
        }
        // 内部捕获 a
        // 外部捕获 b

Generator.prototype.return()
    说明
        Generator函数返回的遍历器对象，还有一个return方法。
        它可以返回给定的值，并且终结遍历Generator函数。
        如果return方法调用时，不提供参数，则返回值的value属性为undefined。
    范例
        function* gen() {
            yield 1;
            yield 2;
            yield 3;
        }
        var g = gen();
        g.next()          // { value: 1, done: false }
        g.return(&apos;foo&apos;)   // { value: &quot;foo&quot;, done: true }
        g.next()          // { value: undefined, done: true }

yield*语句
    说明
        如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。
        使用yield*语句，可以用来在一个Generator函数里面执行另一个Generator函数。
        如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号。
        yield*后面的Generator函数（没有return语句时），等同for...of循环。
        任何数据结构只要有Iterator接口，就可以被yield*遍历。
    范例
        基本使用
            function* inner() {
                yield &apos;hello!&apos;;
            }
            function* outer2() {
                yield &apos;open&apos;
                yield * inner()
                yield &apos;close&apos;
            }
            var gen = outer2()
            gen.next().value // &quot;open&quot;
            gen.next().value // &quot;hello!&quot;
            gen.next().value // &quot;close&quot;
        相当于for...of循环
            function* concat(iter1, iter2) {
                yield * iter1;
                yield * iter2;
            }
            // 等同于
            function* concat(iter1, iter2) {
                for (var value of iter1) {
                    yield value;
                }
                for (var value of iter2) {
                    yield value;
                }
            }
        用于数组
            function* gen() {
                yield * [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
            }
            gen().next() // { value:&quot;a&quot;, done:false }
        被代理的对象有return的情况
            function* genFuncWithReturn() {
                yield &apos;a&apos;;
                yield &apos;b&apos;;
                return &apos;The result&apos;;
            }
            function* logReturned(genObj) {
                let result = yield * genObj;
                console.log(result);
            }
            [...logReturned(genFuncWithReturn())]
            // The result
            // 值为 [ &apos;a&apos;, &apos;b&apos; ]

作为对象属性的Generator函数
    说明
        一个对象的属性可以是Generator函数。
    范例
        完整格式
            let obj = {
                myGeneratorMethod: function*() {
                    // ···
                }
            };
        简写
            let obj = {
                * myGeneratorMethod() {
                    // ···
                }
            };

Generator函数的this
    说明
        Generator函数总是返回一个遍历器。
        这个遍历器是Generator函数的实例，继承了Generator函数的prototype对象上的方法。
        Generator不是普通的构造函数，因为Generator返回的是遍历器对象，而不是this对象。
        Generator函数也不能跟new命令一起用，会报错。
    范例
        基本使用
            function* g() {}
            g.prototype.hello = function() {
                return &apos;hi!&apos;;
            };
            let obj = g();
            obj instanceof g // true
            obj.hello() // &apos;hi!&apos;
        this无效
            function* g() {
                this.a = 11;
            }
            let obj = g();
            obj.a // undefined
        模拟构造函数
            function* gen() {
                this.a = 1;
                yield this.b = 2;
                yield this.c = 3;
            }
            function F() {
                return gen.call(gen.prototype);
            }
            var f = new F();
            f.next(); // Object {value: 2, done: false}
            f.next(); // Object {value: 3, done: false}
            f.next(); // Object {value: undefined, done: true}
            f.a // 1
            f.b // 2
            f.c // 3

含义
    说明
        Generator是实现状态机的最佳结构。
        协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。
        协程既可以用单线程实现，也可以用多线程实现。
        前者是一种特殊的子例程，后者是一种特殊的线程。
        Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。
    范例
        状态机
            // ES5实现方式
            var ticking = true;
            var clock = function() {
                if (ticking)
                    console.log(&apos;Tick!&apos;);
                else
                    console.log(&apos;Tock!&apos;);
                ticking = !ticking;
            }
            // ES6实现方式
            var clock = function*() {
                while (true) {
                    console.log(&apos;Tick!&apos;);
                    yield;
                    console.log(&apos;Tock!&apos;);
                    yield;
                }
            };

应用
    说明
        Generator可以暂停函数执行，返回任意表达式的值。
        这种特点使得Generator有多种应用场景。
    异步操作的同步化表达
        Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面。
        等到调用next方法时再往后执行。
        异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。
    范例
        同步方式的Ajax
            function* main() {
                var result = yield request(&quot;http://some.url&quot;);
                var resp = JSON.parse(result);
                console.log(resp.value);
            }
            function request(url) {
                makeAjaxCall(url, function(response) {
                    it.next(response);
                });
            }
            var it = main();
            it.next();
        在任意对象上部署Iterator接口
            function* iterEntries(obj) {
                let keys = Object.keys(obj);
                for (let i = 0; i &lt; keys.length; i++) {
                    let key = keys[i];
                    yield [key, obj[key]];
                }
            }
            let myObj = {
                foo: 3,
                bar: 7
            };
            for (let [key, value] of iterEntries(myObj)) {
                console.log(key, value);
            }
            // foo 3
            // bar 7
</code></pre><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><pre><code>Promise的含义
    说明
        Promise是异步编程的一种解决方案，比传统的回调函数和事件更合理和更强大。
        ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。
        所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。
        从语法上说，Promise是一个对象，从它可以获取异步操作的消息。
        Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。
    特点
        对象的状态不受外界影响。
        Promise对象代表一个异步操作，有三种状态：Pending、Resolved和Rejected。
        只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
        一旦状态改变，就不会再变，任何时候都可以得到这个结果。
        状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。

基本用法
    说明
        ES6规定，Promise对象是一个构造函数，用来生成Promise实例。
        Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
        resolve和rejec是两个函数，由JavaScript引擎提供，不用自己部署。
        resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”。
        reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”。
        可以用then方法分别指定Resolved状态和Reject状态的回调函数。
        then方法可以接受两个回调函数作为参数。第二个函数是可选的。
    范例
        执行顺序
            let promise = new Promise(function(resolve, reject) {
                console.log(&apos;Promise&apos;);
                resolve();
            });
            promise.then(function() {
                console.log(&apos;Resolved.&apos;);
            });
            console.log(&apos;Hi!&apos;);
            // Promise
            // Hi!
            // Resolved
        封装Ajax
            var getJSON = function(url) {
                var promise = new Promise(function(resolve, reject) {
                    var client = new XMLHttpRequest();
                    client.open(&quot;GET&quot;, url);
                    client.onreadystatechange = handler;
                    client.responseType = &quot;json&quot;;
                    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
                    client.send();
                    function handler() {
                        if (this.readyState !== 4) {
                            return;
                        }
                        if (this.status === 200) {
                            resolve(this.response);
                        } else {
                            reject(new Error(this.statusText));
                        }
                    };
                });
                    return promise;
            };
            getJSON(&quot;/posts.json&quot;).then(function(json) {
                console.log(&apos;Contents: &apos; + json);
            }, function(error) {
                console.error(&apos;出错了&apos;, error);
            });

Promise.prototype.then()
    说明
        Promise实例具有then方法，作用是为Promise实例添加状态改变时的回调函数。
        then方法返回的是一个新的Promise实例。
        因此可以采用链式写法，即then方法后面再调用另一个then方法。
        如果第一个then方法指定的回调函数，返回的是另一个Promise对象。
        第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。
    范例
        getJSON(&quot;/post/1.json&quot;).then(function(post) {
            return getJSON(post.commentURL);
        }).then(function funcA(comments) {
            console.log(&quot;Resolved: &quot;, comments);
        }, function funcB(err) {
            console.log(&quot;Rejected: &quot;, err);
        });

Promise.prototype.catch()
    说明
        Promise.prototype.catch方法是.then(null, rejection)的别名。
        用于指定发生错误时的回调函数。
        then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。
        如果Promise状态已经变成Resolved，再抛出错误是无效的。
        Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。
        如果没有使用catch方法，Promise对象抛出的错误不会传递到外层代码(Chrome不遵守)。
        Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。
        catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。
    范例
        作为Reject回调
            getJSON(&quot;/posts.json&quot;).then(function(posts) {
                // ...
            }).catch(function(error) {
                // 处理 getJSON 和 前一个回调函数运行时发生的错误
                console.log(&apos;发生错误！&apos;, error);
            });
        处理错误
            var promise = new Promise(function(resolve, reject) {
                throw new Error(&apos;test&apos;);
            });
            promise.catch(function(error) {
                console.log(error);
            });
            // Error: test
        错误冒泡
            getJSON(&quot;/post/1.json&quot;).then(function(post) {
                return getJSON(post.commentURL);
            }).then(function(comments) {
                // some code
            }).catch(function(error) {
                // 处理前面三个Promise产生的错误
            });
        Node.js的unhandledRejection事件
            process.on(&apos;unhandledRejection&apos;, function (err, promise) {
                console.error(err.stack)
            });

Promise.all()
    说明
        Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。
        Promise.all方法的参数必须具有Iterator接口，且返回每个成员都是Promise实例。
        参数内的成员状态都变为Resolved，Promise.all返回的Promise的状态为Resolved。
        参数内的成员有一个状态为Rejected，Promise.all返回的Promise的状态为Rejected。
    范例
        var promises = [2, 3, 5, 7, 11, 13].map(function(id) {
            return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;);
        });
        Promise.all(promises).then(function(posts) {
            // ...
        }).catch(function(reason) {
            // ...
        });

Promise.race()
    说明
        Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。
        参数内的成员只要有一个改变状态，Promise.race返回的状态便跟随改变。
        那个率先改变的Promise实例的返回值，就传递给p的回调函数。
    范例
        var p = Promise.race([
            fetch(&apos;/resource-that-may-take-a-while&apos;),
            new Promise(function(resolve, reject) {
                setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)
            })
        ])
        p.then(response =&gt; console.log(response))
        p.catch(error =&gt; console.log(error))

Promise.resolve()
    说明
        有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。
        参数是Promise实例，那么将不做任何修改、原封不动地返回这个实例。
        参数是thenable对象，那么将转换thenable对象为Promise，并执行对象的then方法。
        参数不是具有then方法的对象，或不是对象，则返回一个新Promise，状态为Resolved。
        不带有任何参数，直接返回一个Resolved状态的Promise对象。
    范例
        转换Jquery的Ajax
            var jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;));
        参数是一个thenable对象
            let thenable = {
                then: function(resolve, reject) {
                    resolve(42);
                }
            };
            let p1 = Promise.resolve(thenable);
            p1.then(function(value) {
                console.log(value);
            });
            // 42
        参数不是具有then方法的对象，或不是对象
            var p = Promise.resolve(&apos;Hello&apos;);
            p.then(function(s) {
                console.log(s)
            });
            // Hello

Promise.reject()
    说明
        Promise.reject(reason)方法会返回一个新的Promise实例。
        该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。
    范例
        var p = Promise.reject(&apos;出错了&apos;);
        // 等同于
        var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))
        // 观察状态
        p.then(null, function(s) {
            console.log(s)
        });
        // 出错了

两个有用的附加方法
    说明
        ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。
        下面是如何部署两个不在ES6之中、但很有用的方法。
        done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。
        finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。
    范例
        done方法
            Promise.prototype.done = function (onFulfilled, onRejected) {
               this.then(onFulfilled, onRejected)
                 .catch(function (reason) {
                   // 抛出一个全局错误
                   setTimeout(() =&gt; { throw reason }, 0);
                 });
            };
            asyncFunc().then(f1).catch(r1).then(f2).done();
        finally方法
            Promise.prototype.finally = function(callback) {
                let P = this.constructor;
                return this.then(
                    value =&gt; P.resolve(callback()).then(() =&gt; value),
                    reason =&gt; P.resolve(callback()).then(() =&gt; {
                        throw reason
                    })
                );
            };
            server.listen(0).then(function () {
                // run test
            }).finally(server.stop);
</code></pre><h2 id="异步操作和Async函数"><a href="#异步操作和Async函数" class="headerlink" title="异步操作和Async函数"></a>异步操作和Async函数</h2><pre><code>Thunk函数
    求值策略
        传值调用: 进入函数体之前，就计算参数内表达式的值，再将这个值传入函数。C采取吃策略。
        传名调用: 将参数中的表达式传入函数，在用到它的时候求值。Haskell语言采用这种策略。
    Thunk函数概念
        编译器的传名调用实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。
        这个临时函数就叫做Thunk函数。
    JavaScript中的Thunk
        JavaScript语言是传值调用，它的Thunk函数含义有所不同。
        在JavaScript语言中，Thunk函数替换的不是表达式。
        而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。
        Thunk函数真正的威力，在于可以自动执行Generator函数。
    范例
        Thunk函数的编译器实现
            function f(m) {
                return m * 2;
            }
            f(x + 5);
            // 等同于
            var thunk = function() {
                return x + 5;
            };
            function f(thunk) {
                return thunk() * 2;
            }
        JavaScript的Thunk实现
            // 正常版本的readFile（多参数版本）
            fs.readFile(fileName, callback);
            // Thunk版本的readFile（单参数版本）
            var readFileThunk = Thunk(fileName);
            readFileThunk(callback);
            var Thunk = function(fileName) {
                return function(callback) {
                    return fs.readFile(fileName, callback);
                };
            };

co模块
    说明
        co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具。
        用于Generator函数的自动执行。
        co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。
        使用co的前提是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。
        co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。
    范例
        基于Promise的Generator自动执行器
            var fs = require(&apos;fs&apos;);
            var readFile = function(fileName) {
                return new Promise(function(resolve, reject) {
                    fs.readFile(fileName, function(error, data) {
                        if (error) return reject(error);
                        resolve(data);
                    });
                });
            };
            var gen = function*() {
                var f1 = yield readFile(&apos;/etc/fstab&apos;);
                var f2 = yield readFile(&apos;/etc/shells&apos;);
                console.log(f1.toString());
                console.log(f2.toString());
            };
            // 手动执行
            var g = gen();
            g.next().value.then(function(data) {
                g.next(data).value.then(function(data) {
                    g.next(data);
                });
            });
            // 自动执行
            function run(gen) {
                var g = gen();
                    function next(data) {
                    var result = g.next(data);
                    if (result.done) return result.value;
                    result.value.then(function(data) {
                        next(data);
                    });
                }
                    next();
            }
            run(gen);
        co处理并发的异步操作
            // 数组的写法
            co(function*() {
                var res = yield [
                    Promise.resolve(1),
                    Promise.resolve(2)
                ];
                console.log(res);
            }).catch(onerror);
            // 对象的写法
            co(function*() {
                var res = yield {
                    1: Promise.resolve(1),
                    2: Promise.resolve(2),
                };
                console.log(res);
            }).catch(onerror);

async函数
    说明
        ES7提供了async函数，使得异步操作变得更加方便。它是Generator函数的语法糖。
        async函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。
        async语法是将Generator函数的星号（*）替换成async，将yield替换成await。
        async返回一个Promise对象。
        async内部return语句返回的值，会成为then方法回调函数的参数。
        async内部抛出错误，会导致返回的Promise对象变为reject状态。
        async返回的Promise对象，等到内部所有await命令的Promise对象执行完，才改变状态。
        如果await命令后面不是一个Promise对象，会被转成一个立即resolve的Promise对象。
        只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。
        如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。
    范例
        返回值
            async function f() {
                return &apos;hello world&apos;;
            }
            f().then(v =&gt; console.log(v))
            // &quot;hello world&quot;
        抛出错误
            async function f() {
                throw new Error(&apos;出错了&apos;);
            }
            f().then(
                v =&gt; console.log(v),
                e =&gt; console.log(e)
            )
            // Error: 出错了
        状态改变
            async function getTitle(url) {
                let response = await fetch(url);
                let html = await response.text();
                return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];
            }
            getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log)
            // &quot;ECMAScript 2017 Language Specification&quot;
        await后不是Promise对象
            async function f() {
                return await 123;
            }
            f().then(v =&gt; console.log(v))
            // 123
        await后面的异步操作出错
            async function f() {
                await new Promise(function(resolve, reject) {
                    throw new Error(&apos;出错了&apos;);
                });
            }
            f().then(v =&gt; console.log(v)).catch(e =&gt; console.log(e))
            // Error：出错了
        async函数的实现
            async function fn(args) {
                // ...
            }
            // 等同于
            function fn(args) {
                return spawn(function*() {
                    // ...
                });
            }
            function spawn(genF) {
                return new Promise(function(resolve, reject) {
                    var gen = genF();
                    function step(nextF) {
                        try {
                            var next = nextF();
                        } catch (e) {
                            return reject(e);
                        }
                        if (next.done) {
                            return resolve(next.value);
                        }
                        Promise.resolve(next.value).then(function(v) {
                            step(function() {
                                return gen.next(v);
                            });
                        }, function(e) {
                            step(function() {
                                return gen.throw(e);
                            });
                        });
                    }
                    step(function() {
                        return gen.next(undefined);
                    });
                });
            }
        async用法
            function timeout(ms) {
                return new Promise((resolve) =&gt; {
                    setTimeout(resolve, ms);
                });
            }
            async function asyncPrint(value, ms) {
                await timeout(ms);
                console.log(value)
            }
            asyncPrint(&apos;hello world&apos;, 50);
        不同写法对比
            // Promise写法
            function chainAnimationsPromise(elem, animations) {
                // 变量ret用来保存上一个动画的返回值
                var ret = null;
                // 新建一个空的Promise
                var p = Promise.resolve();
                // 使用then方法，添加所有动画
                for (var anim of animations) {
                    p = p.then(function(val) {
                        ret = val;
                        return anim(elem);
                    });
                }
                // 返回一个部署了错误捕捉机制的Promise
                return p.catch(function(e) {
                    /* 忽略错误，继续执行 */
                }).then(function() {
                    return ret;
                });
            }
            // Generator写法
            function chainAnimationsGenerator(elem, animations) {
                return spawn(function*() {
                    var ret = null;
                    try {
                        for (var anim of animations) {
                            ret = yield anim(elem);
                        }
                    } catch (e) {
                        /* 忽略错误，继续执行 */
                    }
                    return ret;
                });
            }
            // Async写法
            async function chainAnimationsAsync(elem, animations) {
                var ret = null;
                try {
                    for (var anim of animations) {
                        ret = await anim(elem);
                    }
                } catch (e) {
                    /* 忽略错误，继续执行 */
                }
                return ret;
            }

异步遍历器
    说明
        Iterator中next方法是同步的，只要调用就必须立刻返回值。
        对于异步操作解决方法是，Generator函数里面的异步操作返回Thunk函数或者Promise。
        即value属性是一个Thunk函数或者Promise对象，但done属性则还是同步产生的。
        目前，有一个提案，为异步操作提供原生的遍历器接口。
        即value和done这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。
        异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个Promise对象。
        对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。
        for await...of 则是用于遍历异步的Iterator接口。
        异步Generator函数可返回一个异步遍历器对象。
    范例
        语法
            asyncIterator.next().then(({value,done}) =&gt; {/* ... */});
        遍历
            for await (const line of readLines(filePath)) {
                console.log(line);
            }
        异步Generator
            async function* readLines(path) {
                let file = await fileOpen(path);
                try {
                    while (!file.EOF) {
                        yield await file.readLine();
                    }
                } finally {
                    await file.close();
                }
            }
</code></pre><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><pre><code>Class基本语法
    说明
        ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。
        通过class关键字，可以定义类。
        类中定义的方法不需要function关键字，也不需要逗号分隔，类中定义的方法是不可枚举的。
        使用时，直接对类使用new命令，不使用new是没法当作函数调用，会报错。
        类的所有方法都定义在类的prototype属性上面，新方法可以添加在prototype对象上面。
        类的属性名，可以采用表达式。
        Class不存在变量提升（hoist），这一点与ES5完全不同。
        类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式
    constructor方法
        constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。
        类必须有constructor方法，如果没有显式定义，会默认添加一个空的constructor方法。
        constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。
    范例
        基本使用
            let methodName = &quot;methodName&quot;;
            class Point {
                constructor() {
                    this.x = x;
                    this.y = y;
                }
                toString() {
                    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;
                }
                toValue() {
                    // ...
                }
                [methodName]() {
                    // ...
                }
            }
            Object.assign(Point.prototype, {
                otherMethodName(){}
            });
            let point = new Point(2,3);
            console.log(Object.keys(Point.prototype));
            // [ &apos;otherMethodName&apos; ]
            var p1 = new Point(2,3);
            var p2 = new Point(3,2);
            p1.__proto__ === p2.__proto__
            //true
            p1.__proto__.printName = function () { return &apos;Oops&apos; };
            p1.printName() // &quot;Oops&quot;
            p2.printName() // &quot;Oops&quot;
        不存在变量提升
            new Foo(); // ReferenceError
            class Foo {}
        Class表达式（Me只能在类的内部使用）
            const MyClass = class Me {
                getClassName() {
                    return Me.name;
                }
            };
            let inst = new MyClass();
            inst.getClassName() // Me
            Me.name // ReferenceError: Me is not defined
        Class表达式省略类名
            const MyClass = class { /* ... */ };
        立即执行的class
            let person = new class {
                constructor(name) {
                    this.name = name;
                }
                sayName() {
                    console.log(this.name);
                }
            }(&apos;张三&apos;);
            person.sayName(); // &quot;张三&quot;
        利用外部函数实现私有方法
            class Widget {
                foo(baz) {
                    bar.call(this, baz);
                }
            }
            function bar(baz) {
                return this.snaf = baz;
            }
        利用Symbol实现私有方法
            const bar = Symbol(&apos;bar&apos;);
            const snaf = Symbol(&apos;snaf&apos;);
            export default class myClass {
                // 公有方法
                foo(baz) {
                    this[bar](baz);
                }
                // 私有方法
                [bar](baz) {
                    return this[snaf] = baz;
                }
            };

Class的继承
    说明
        Class之间可以通过extends关键字实现继承，这比通过修改原型链实现继承更加清晰方便。
        在类中super指向父类的构造函数，如果不调用super方法，子类就得不到this对象。
        子类必须在constructor方法中调用super方法，否则新建实例时会报错。
        因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。
        在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。
        ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。
        ES6的继承，实质是先创造父类的实例对象this，然后再用子类的构造函数修改this。
        如果子类没有定义constructor方法，这个方法会被默认添加。。
    super
        作为函数调用时（即super(...args)），super代表父类的构造函数。
        作为对象调用时（即super.prop或super.method()），super代表父类。
        作为对象调用时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。
    原型
        子类的__proto__属性，表示构造函数的继承，总是指向父类。
        子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype。
        作为一个对象，子类的原型（__proto__属性）是父类；
        作为一个构造函数，子类的原型（prototype属性）是父类的实例。
    Extends的继承目标
        extends关键字后面可以跟多种类型的值。
        只要目标是一个有prototype属性的函数，就能被B继承。
    范例
        基本使用
            class Point {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                }
            }
            class ColorPoint extends Point {
                constructor(x, y, color) {
                    super(x, y);
                    this.color = color;
                }
            }
            let cp = new ColorPoint(25, 8, &apos;green&apos;);
            cp instanceof ColorPoint // true
            cp instanceof Point      // true
        __proto__属性
            class A {}
            class B extends A {}
            B.__proto__ === A // true
            B.prototype.__proto__ === A.prototype // true
        继承
            // 继承自Object
            class A extends Object {}
            A.__proto__ === Object // true
            A.prototype.__proto__ === Object.prototype // true
            // A作为一个基类（即不存在任何继承）
            class A {}
            A.__proto__ === Function.prototype // true
            A.prototype.__proto__ === Object.prototype // true
            // 子类继承null
            class A extends null {}
            A.__proto__ === Function.prototype // true
            A.prototype.__proto__ === undefined // true

原生构造函数的继承
    说明
        生构造函数是指语言内置的构造函数，通常用来生成数据结构。
        之前，这些原生构造函数是无法继承的。
        因为ES5是先新建子类的实例对象this，再将父类的属性添加到子类上。
        由于父类的内部属性无法获取，导致无法继承原生的构造函数。
        ES6允许继承原生构造函数定义子类。
        因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this。
        ES6中，如果Object方法不是通过new Object形式调用，Object构造函数会忽略参数。
    原生构造函数
        Boolean(), Number(), String(), Array(), Date(), Function(), RegExp(), Error(), Object()
    范例
        ES5无法继承原生构造函数
            function MyArray() {
                Array.apply(this, arguments);
            }
            MyArray.prototype = Object.create(Array.prototype, {
                constructor: {
                    value: MyArray,
                    writable: true,
                    configurable: true,
                    enumerable: true
                }
            });
            var colors = new MyArray();
            colors[0] = &quot;red&quot;;
            colors.length // 0
            colors.length = 0;
            colors[0] // &quot;red&quot;
        ES6继承原生构造函数定义子类
            class MyArray extends Array {
                constructor(...args) {
                    super(...args);
                }
            }
            var arr = new MyArray();
            arr[0] = 12;
            arr.length // 1
            arr.length = 0;
            arr[0] // undefined
        自定义数据结构
            class VersionedArray extends Array {
                constructor() {
                    super();
                    this.history = [[]];
                }
                commit() {
                    this.history.push(this.slice());
                }
                revert() {
                    this.splice(0, this.length, ...this.history[this.history.length - 1]);
                }
            }
            var x = new VersionedArray();
            x.push(1);
            x.push(2);
            x               // [1, 2]
            x.history       // [[]]
            x.commit();
            x.history       // [[], [1, 2]]
            x.push(3);
            x               // [1, 2, 3]
            x.revert();
            x               // [1, 2]
        继承Object的子类的行为差异
            class NewObj extends Object {
                constructor() {
                    super(...arguments);
                }
            }
            var o = new NewObj({
                attr: true
            });
            console.log(o.attr === true); // false

Class的取值函数（getter）和存值函数（setter）
    说明
        在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数。
        存值函数和取值函数是设置在属性的descriptor对象上的。
    范例
        class MyClass {
            constructor() {
            }
            get prop() {
                return &apos;getter&apos;;
            }
            set prop(value) {
                console.log(&apos;setter: &apos; + value);
            }
        }
        let inst = new MyClass();
        inst.prop = 123;
        // setter: 123
        inst.prop
        // &apos;getter&apos;
        var descriptor = Object.getOwnPropertyDescriptor(MyClass.prototype, &quot;prop&quot;);
        &quot;get&quot; in descriptor   // true
        &quot;set&quot; in descriptor   // true

Class的Generator方法
    说明
        如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。
    范例
        class Foo {
            constructor(...args) {
                this.args = args;
            }
            * [Symbol.iterator]() {
                for (let arg of this.args) {
                    yield arg;
                }
            }
        }
        for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) {
            console.log(x);
        }
        // hello
        // world

Class的静态方法
    说明
        类相当于实例的原型，所有在类中定义的方法，都会被实例继承。
        如果在一个方法前，加上static关键字，表示该方法为静态方法。
        静态方法不会被实例继承，而是直接通过类来调用。
        父类的静态方法，可以被子类继承。
    范例
        class Foo {
            static classMethod() {
                return &apos;hello&apos;;
            }
        }
        class Bar extends Foo {
            static classMethodToo() {
                return super.classMethod() + &apos;, too&apos;;
            }
        }
        Foo.classMethod()      // &apos;hello&apos;
        Bar.classMethod()      // &apos;hello&apos;
        console.log(Bar.classMethodToo());  // &apos;hello, too&apos;
        var foo = new Foo()
        foo.classMethod()
        // TypeError: foo.classMethod is not a function

Class的静态属性和实例属性
    说明
        静态属性指的是Class本身的属性，即Class.propname。
        而不是定义在实例对象（this）上的属性。
        ES6明确规定，Class内部只有静态方法，没有静态属性。
        要实现静态属性只能手动给类添加属性。
        ES7有一个静态属性的提案，目前Babel转码器支持。
    范例
        ES6静态属性
            class Foo {}
            Foo.prop = 1;
            Foo.prop // 1
        ES7实例属性
            class MyClass {
                myProp = 42;
                constructor() {
                    console.log(this.myProp); // 42
                }
            }
        ES7静态属性
            class MyClass {
                static myStaticProp = 42;
                constructor() {
                    console.log(MyClass.myProp); // 42
                }
            }

new.target属性
    说明
        ES6为new命令引入了一个new.target属性，返回new命令作用于的那个构造函数。
        如果构造函数不是通过new命令调用的，new.target会返回undefined。
        这个属性可以用来确定构造函数是怎么调用的。
        子类继承父类时，new.target会返回子类。
    范例
        构造函数中使用
            function Person(name) {
                if (new.target === Person) {
                    this.name = name;
                } else {
                    throw new Error(&apos;必须使用new生成实例&apos;);
                }
            }
            var person = new Person(&apos;张三&apos;); // 正确
            var notAPerson = Person.call(person, &apos;张三&apos;); // 报错
        类中使用
            class Rectangle {
                constructor(length, width) {
                    console.log(new.target === Rectangle);
                    this.length = length;
                    this.width = width;
                }
            }
            var obj = new Rectangle(3, 4); // 输出 true

Mixin模式的实现
    说明
        Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。
    范例
        function mix(...mixins) {
            class Mix {}
            for (let mixin of mixins) {
                copyProperties(Mix, mixin);
                copyProperties(Mix.prototype, mixin.prototype);
            }
            return Mix;
        }
        function copyProperties(target, source) {
            for (let key of Reflect.ownKeys(source)) {
                if (key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot;) {
                    let desc = Object.getOwnPropertyDescriptor(source, key);
                    Object.defineProperty(target, key, desc);
                }
            }
        }
        class DistributedEdit extends mix(Loggable, Serializable) {
          // ...
        }
</code></pre><h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><pre><code>类的修饰
    说明
        修饰器（Decorator）是一个函数，用来修改类的行为。
        这是ES7的一个提案，目前Babel转码器已经支持。
        修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。
        这意味着，修饰器能在编译阶段运行代码。
        修饰器函数的第一个参数，就是所要修饰的目标类。
    范例
        基本使用
            function testable(target) {
                target.isTestable = true;
            }
            @testable
            class MyTestableClass {}
            console.log(MyTestableClass.isTestable) // true
        改变修饰器行为
            function testable(isTestable) {
                return function(target) {
                    target.isTestable = isTestable;
                }
            }
            @testable(true)
            class MyTestableClass {}
            MyTestableClass.isTestable // true
            @testable(false)
            class MyClass {}
            MyClass.isTestable // false
        添加实例属性
            function testable(target) {
                target.prototype.isTestable = true;
            }
            @testable
            class MyTestableClass {}
            let obj = new MyTestableClass();
            obj.isTestable // true

方法的修饰
    说明
        修饰器不仅可以修饰类，还可以修饰类的属性。
        此时，修饰器函数一共可以接受三个参数。
        参数分别为: 修饰的目标对象，所要修饰的属性名，该属性的描述对象。
        如果同一个方法有多个修饰器，先从外到内进入，然后由内向外执行。
        修饰器还能用来类型检查。从长期来看，它将是JavaScript代码静态分析的重要工具。
    范例
        修饰为只读
            function readonly(target, name, descriptor) {
                descriptor.writable = false;
                return descriptor;
            }
            readonly(Person.prototype, &apos;name&apos;, descriptor);
            class Person {
                @readonly
                name() {
                    return `${this.first} ${this.last}`
                }
            }
        添加日志
            class Math {
                @log
                add(a, b) {
                    return a + b;
                }
            }
            function log(target, name, descriptor) {
                var oldValue = descriptor.value;
                descriptor.value = function() {
                    console.log(`Calling &quot;${name}&quot; with`, arguments);
                    return oldValue.apply(null, arguments);
                };
                return descriptor;
            }
            const math = new Math();
            math.add(2, 4);

为什么修饰器不能用于函数？
    说明
        修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。

core-decorators.js
    说明
        core-decorators.js是一个第三方模块，提供了几个常见的修饰器。
        @autobind修饰器使得方法中的this对象，绑定原始对象。
        @readonly修饰器使得属性或方法不可写。
        @override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。
        @deprecate或@deprecated修饰器在控制台显示一条警告，表示该方法将废除。
        @suppressWarnings修饰器抑制decorated修饰器导致的console.warn()调用。

Mixin
    说明
        在修饰器的基础上，可以实现Mixin模式。
        Mixin模式就是对象继承的一种替代方案，意为在一个对象之中混入另外一个对象的方法。
    范例
        通过原型实现
            export function mixins(...list) {
                return function (target) {
                    Object.assign(target.prototype, ...list);
                };
            }
            import { mixins } from &apos;./mixins&apos;;
            const Foo = {
                foo() { console.log(&apos;foo&apos;) }
            };
            @mixins(Foo)
            class MyClass {}
            let obj = new MyClass();
            obj.foo() // &quot;foo&quot;
        通过类继承实现
            let Mixin1 = (superclass) =&gt; class extends superclass {
                foo() {
                    console.log(&apos;foo from Mixin1&apos;);
                    if (super.foo) super.foo();
                }
            };
            let Mixin2 = (superclass) =&gt; class extends superclass {
                foo() {
                    console.log(&apos;foo from Mixin2&apos;);
                    if (super.foo) super.foo();
                }
            };
            class S {
                foo() {
                    console.log(&apos;foo from S&apos;);
                }
            }
            class C extends Mixin1(Mixin2(S)) {
                foo() {
                    console.log(&apos;foo from C&apos;);
                    super.foo();
                }
            }
            new C().foo()
            // foo from C
            // foo from Mixin1
            // foo from Mixin2
            // foo from S

Trait
    说明
        Trait也是一种修饰器，效果与Mixin类似，但是提供更多功能。
        如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。
        traits-decorator这个第三方模块提供的traits修饰器。可接受对象和类作为参数。
        混入时出现同名方法会报错，可通过别名和排除方法来解决，具体可参照模块的说明文档。
    范例
        import { traits } from &apos;traits-decorator&apos;;
        class TFoo {
            foo() { console.log(&apos;foo&apos;) }
        }
        const TBar = {
            bar() { console.log(&apos;bar&apos;) }
        };
        @traits(TFoo, TBar)
        class MyClass { }
        let obj = new MyClass();
        obj.foo() // foo
        obj.bar() // bar

Babel转码器的支持
    说明
        目前，Babel转码器已经支持Decorator。
        首先，安装babel-core和babel-plugin-transform-decorators。
        由于后者包括在babel-preset-stage-0之中，所以安装babel-preset-stage-0亦可。
    范例
        $ npm install babel-core babel-plugin-transform-decorators
        // 配置文件改为
        {
          &quot;plugins&quot;: [&quot;transform-decorators&quot;]
        }
        // 脚本中打开的命令为
        babel.transform(&quot;code&quot;, {plugins: [&quot;transform-decorators&quot;]})
</code></pre><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><pre><code>概述
    说明
        在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。
        CommonJS用于服务器，AMD用于浏览器。
        ES6在语言规格的层面上，实现了模块功能，可以取代现有的CommonJS和AMD规范。
        ES6模块的设计思想是尽量的静态化，使编译时就能确定模块的依赖关系和输入和输出的变量。
        CommonJS和AMD模块，都只能在运行时确定这些东西。
    ES6模块的优点
        静态分析，能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验。
        不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。
        将来浏览器的新API就能用模块格式提供，不需做成全局变量或者navigator对象的属性。
        不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
    范例
        CommonJS模块
            let { stat, exists, readFile } = require(&apos;fs&apos;);
            // 等同于
            let _fs = require(&apos;fs&apos;);
            let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;
        ES6模块
            import { stat, exists, readFile } from &apos;fs&apos;;
        浏览器使用ES6模块
            &lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;

严格模式
    说明  
        ES6的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。
    严格模式限制
        变量必须声明后再使用
        函数的参数不能有同名属性，否则报错
        不能使用with语句
        不能对只读属性赋值，否则报错
        不能使用前缀0表示八进制数，否则报错
        不能删除不可删除的属性，否则报错
        不能删除变量delete prop，会报错，只能删除属性delete global[prop]
        eval不会在它的外层作用域引入变量
        eval和arguments不能被重新赋值
        arguments不会自动反映函数参数的变化
        不能使用arguments.callee
        不能使用arguments.caller
        禁止this指向全局对象
        不能使用fn.caller和fn.arguments获取函数调用的堆栈
        增加了保留字（比如protected、static和interface）

export命令
    说明
        export命令用于规定模块的对外接口。
        一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。
        如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。
        通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。
        export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。
        export命令可以出现在模块的任何位置，只要处于模块顶层就可以。
    范例
        输出变量
            export var firstName = &apos;Michael&apos;;
            export var lastName = &apos;Jackson&apos;;
            export var year = 1958;
        统一输出
            var firstName = &apos;Michael&apos;;
            var lastName = &apos;Jackson&apos;;
            var year = 1958;
            export {firstName, lastName, year};
        输出函数或类
            export function multiply(x, y) {
                return x * y;
            };
        重新命名
            function v1() { ... }
            function v2() { ... }
            export {
                v1 as streamV1,
                v2 as streamV2,
                v2 as streamLatestVersion
            };
        动态更新（500ms后foo的值变化）
            export var foo = &apos;bar&apos;;
            setTimeout(() =&gt; foo = &apos;baz&apos;, 500);

import命令
    说明
        import命令用于输入其他模块提供的功能。
        import命令会执行所加载的模块。
        import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。
        大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。
        as关键字可将输入的变量重命名。
        import命令具有提升效果，会提升到整个模块的头部，首先执行。
        ES7有一个提案，简化先输入后输出的写法，拿掉输出时的大括号。
    范例
        导入模块中的变量
            import {firstName, lastName, year} from &apos;./profile&apos;;
        重命名
            import { lastName as surname } from &apos;./profile&apos;;
        ES7简写
            // 提案的写法
            export v from &apos;mod&apos;;
            // 现行的写法
            export {v} from &apos;mod&apos;;
        先输入后输出同一个模块
            export { es6 as default } from &apos;./someModule&apos;;
            // 等同于
            import { es6 } from &apos;./someModule&apos;;
            export default es6;

模块的整体加载
    说明
        除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象。
        所有输出值都加载在这个对象上面。
    范例
        // circle.js
        export function area(radius) {
            return Math.PI * radius * radius;
        }
        export function circumference(radius) {
            return 2 * Math.PI * radius;
        }
        // 逐一加载
        import { area, circumference } from &apos;./circle&apos;;
        console.log(&apos;圆面积：&apos; + area(4));
        console.log(&apos;圆周长：&apos; + circumference(14));
        // 整体加载
        import * as circle from &apos;./circle&apos;;
        console.log(&apos;圆面积：&apos; + circle.area(4));
        console.log(&apos;圆周长：&apos; + circle.circumference(14));

export default命令
    说明
        export default命令用于指定模块的默认输出。
        一个模块只能有一个默认输出，因此export deault命令只能使用一次。
        他模块加载该模块时，import命令可以为该默认加载的变量指定任意名字。
        导入带有默认输出的模块时，import命令后面，不使用大括号。
        export default其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。
    范例
        基本使用
            // export-default.js
            export default function() {
                console.log(&apos;foo&apos;);
            }
            // import-default.js
            import customName from &apos;./export-default&apos;;
            customName(); // &apos;foo&apos;
        用于非匿名函数
            function foo() {
                console.log(&apos;foo&apos;);
            }
            export default foo;
        后面不能跟变量声明语句
            // 正确
            export var a = 1;
            // 正确
            var a = 1;
            export default a;
            // 错误
            export default var a = 1;
        同时输入默认方法和其他变量
            import customName, { otherMethod } from &apos;./export-default&apos;;
        输出类
            // MyClass.js
            export default class { ... }
            // main.js
            import MyClass from &apos;MyClass&apos;;
            let o = new MyClass();

模块的继承
    说明
        模块之间也可以继承。
        export * 表示再输出指定模块的所有属性和方法。
        export * 会忽略指定模块的default方法。
    范例
        circleplus模块继承circle模块
            // circleplus.js
            export * from &apos;circle&apos;;
            export var e = 2.71828182846;
            export default function(x) {
                return Math.exp(x);
            }
            // main.js
            import * as math from &apos;circleplus&apos;;
            import exp from &apos;circleplus&apos;;
            console.log(exp(math.e));
        改名再输出
            export { area as circleArea } from &apos;circle&apos;;

ES6模块加载的实质
    说明
        ES6模块加载的机制，与CommonJS模块完全不同。
        CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。
        CommonJS一旦输出一个值，模块内部的变化就影响不到这个值。
        ES6模块的运行机制遇到import命令时，只生成一个动态的只读引用。
        ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。
        ES6输入的模块变量是“符号连接”，这个变量指向的地址是只读的，对它进行重新赋值会报错。
        export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。
    范例
        CommonJS模块机制
            // lib.js
            var counter = 3;
            function incCounter() {
                counter++;
            }
            module.exports = {
                counter: counter,
                incCounter: incCounter,
            };
            // main.js
            var mod = require(&apos;./lib&apos;);
            console.log(mod.counter); // 3
            mod.incCounter();
            console.log(mod.counter); // 3
        ES6模块机制
            // lib.js
            export let counter = 3;
            export function incCounter() {
                counter++;
            }
            // main.js
            import { counter, incCounter } from &apos;./lib&apos;;
            console.log(counter); // 3
            incCounter();
            console.log(counter); // 4
        对变量赋值
            // lib.js
            export let obj = {};
            // main.js
            import { obj } from &apos;./lib&apos;;
            obj.prop = 123; // OK
            obj = {}; // TypeError
        不同的脚本加载同一模块
            // mod.js
            function C() {
                this.sum = 0;
                this.add = function() {
                    this.sum += 1;
                };
                this.show = function() {
                    console.log(this.sum);
                };
            }
            export let c = new C();
            // x.js
            import {c} from &apos;./mod&apos;;
            c.add();
            // y.js
            import {c} from &apos;./mod&apos;;
            c.show();
            // main.js
            import &apos;./x&apos;;
            import &apos;./y&apos;;
            // 输出1

循环加载
    说明
        循环加载指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。
        通常，循环加载表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行。
    CommonJS加载原理
        CommonJS的一个模块，就是一个脚本文件。
        require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。
        即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。
        CommonJS模块无论加载多少次，都只会在第一次加载时运行一次。
    CommonJS循环加载
        CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。
        一旦出现某个模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出。
    ES6循环加载
        ES6处理“循环加载”与CommonJS有本质的不同，ES6模块是动态引用。
        使用import从一个模块加载变量，变量不会被缓存，而是成为一个指向被加载模块的引用。
        需要开发者自己保证，真正取值的时候能够取到值。
    范例
        CommonJS循环加载
            // a.js如下
            exports.done = false;
            var b = require(&apos;./b.js&apos;);
            console.log(&apos;在 a.js 之中，b.done = %j&apos;, b.done);
            exports.done = true;
            console.log(&apos;a.js 执行完毕&apos;);
            // b.js
            exports.done = false;
            var a = require(&apos;./a.js&apos;);
            console.log(&apos;在 b.js 之中，a.done = %j&apos;, a.done);
            exports.done = true;
            console.log(&apos;b.js 执行完毕&apos;);
            // main.js
            var a = require(&apos;./a.js&apos;);
            var b = require(&apos;./b.js&apos;);
            console.log(&apos;在 main.js 之中, a.done=%j, b.done=%j&apos;, a.done, b.done);
            // 命令行执行main.js
            在 b.js 之中，a.done = false
            b.js 执行完毕
            在 a.js 之中，b.done = true
            a.js 执行完毕
            在 main.js 之中, a.done=true, b.done=true
        ES6循环加载
            // a.js如下
            import {bar} from &apos;./b.js&apos;;
            console.log(&apos;a.js&apos;);
            console.log(bar);
            export let foo = &apos;foo&apos;;
            // b.js
            import {foo} from &apos;./a.js&apos;;
            console.log(&apos;b.js&apos;);
            console.log(foo);
            export let bar = &apos;bar&apos;;
            // 命令行执行a.js
            $ babel-node a.js
            b.js
            undefined
            a.js
            bar

跨模块常量
    说明
        const声明的常量只在当前代码块有效。
        如果想设置跨模块的常量（即跨多个文件），可以采用下面的写法。
    范例
        // constants.js 模块
        export const A = 1;
        export const B = 3;
        export const C = 4;
        // test1.js 模块
        import * as constants from &apos;./constants&apos;;
        console.log(constants.A); // 1
        console.log(constants.B); // 3
        // test2.js 模块
        import {A, B} from &apos;./constants&apos;;
        console.log(A); // 1
        console.log(B); // 3

ES6模块的转码
    说明
        浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。
        除了Babel可以用来转码之外，ES6 module transpiler和SystemJS也可以用来转码。
    ES6 module transpiler
        ES6 module transpiler是square公司开源的一个转码器。
        可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。
    SystemJS
        SystemJS是一个垫片库（polyfill），可以在浏览器内加载ES6、AMD和CommonJS模块。
        SystemJS将模块转为ES5格式。它在后台调用的是Google的Traceur转码器。
        System.import使用异步加载，返回一个Promise对象，可以针对这个对象编程。
    范例
        ES6 module transpiler
            // 安装
            $ npm install -g es6-module-transpiler
            // 将ES6模块文件转码
            $ compile-modules convert file1.js file2.js
            // -o参数可以指定转码后的文件名
            $ compile-modules convert -o out.js file1.js
        SystemJS
            // 先在网页内载入system.js文件。
            &lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt;
            // app/es6-file.js:
            export class q {
              constructor() {
                this.es6 = &apos;hello&apos;;
              }
            }
            // 使用System.import方法加载模块文件。
            &lt;script&gt;
            System.import(&apos;app/es6-file&apos;).then(function(m) {
                console.log(new m.q().es6); // hello
            });
            &lt;/script&gt;
</code></pre><h2 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h2><pre><code>ArrayBuffer对象
    说明
        ArrayBuffer对象代表储存二进制数据的一段内存。
        它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写。
        视图的作用是以指定格式解读二进制数据。
        ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。
        ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。
        如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存）。
        ArrayBuffer实例的slice方法，可内存区域的一部分，拷贝生成一个新的ArrayBuffer。
        ArrayBuffer有一个静态方法isView，返回指定参数是否为ArrayBuffer的视图实例。
    范例
        生成32位内存区域
            var buf = new ArrayBuffer(32);
            buffer.byteLength
            // 32
        通过DataView读取ArrayBuffer
            var buf = new ArrayBuffer(32);
            var dataView = new DataView(buf);
            dataView.getUint8(0) // 0
        检查是否分配成功
            if (buffer.byteLength === n) {
                // 成功
            } else {
                // 失败
            }
        slice
            var buffer = new ArrayBuffer(8);
            var newBuffer = buffer.slice(0, 3);
        ArrayBuffer.isView
            var buffer = new ArrayBuffer(8);
            ArrayBuffer.isView(buffer) // false
            var v = new Int32Array(buffer);
            ArrayBuffer.isView(v) // true

TypedArray视图
    说明
        ArrayBuffer对象作为内存区域，可以存放多种类型的数据。
        同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。
        ArrayBuffer有两种视图，一种是TypedArray视图，另一种是DataView视图。
        前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。
        目前，TypedArray视图一共包括9种类型，每一种视图都是一种构造函数。
    类型
        Int8Array          (1 byte)     8位有符号整数
        Uint8Array         (1 bytes)    8位无符号整数
        Uint8ClampedArray  (1 bytes)    8位无符号整数，溢出处理不同
        Int16Array         (2 bytes)    16位有符号整数
        Uint16Array        (2 bytes)    16位无符号整数
        Int32Array         (4 bytes)    32位有符号整数
        Uint32Array        (4 bytes)    32位无符号整数
        Float32Array       (4 bytes)    32位浮点数
        Float64Array       (8 bytes)    64位浮点数
    和数组相同点
        这9个构造函数生成的数组，统称为TypedArray视图。
        它们很像普通数组，都有length属性，都能用方括号运算符（[]）获取单个元素。
        所有数组的方法，在它们上面都能使用。
        TypedArray部署了Iterator接口，所以可以被遍历。
    和数组差异
        TypedArray数组的所有成员，都是同一种类型。
        TypedArray数组的成员是连续的，不会有空位。
        TypedArray数组成员的默认值为0。
        TypedArray数组只是一层视图，本身不储存数据，数据都储存在底层的ArrayBuffer中。
        TypedArray要获取底层对象必须使用buffer属性。
    字节序
        字节序指的是数值在内存中的表示方式，分为小端字节序和大端字节序。
        所有个人电脑几乎都是小端字节序，所以TypedArray数组内部也采用小端字节序读取数据。
        很多网络设备和特定的操作系统采用的是大端字节序。
        有一个占据四个字节的16进制数0x12345678。
        小端字节序将最不重要的字节排在前面，储存顺序就是78563412。
        大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。
        如果一段数据是大端字节序，TypedArray数组将无法正确解析，因为它只能处理小端字节序。
        为了解决这个问题，JavaScript引入DataView对象，可以设定字节序，下文会详细介绍。
    属性和
        BYTES_PER_ELEMENT             构造器属性，表示所占据的字节数
        .prototype.BYTES_PER_ELEMENT  表示所占据的字节数
        .prototype.byteLength         返回TypedArray数组占据的内存长度(字节)
        .prototype.byteOffset         返回TypedArray在ArrayBuffer对象的偏移
        .prototype.length             表示TypedArray数组含有多少个成员
    实例方法
        .prototype.set()              用于复制数组，将一段内容完全复制到另一段内存。
        .prototype.subarray()         对于TypedArray数组的一部分，新建一个新视图。
        .prototype.slice()            返回一个指定位置的新的TypedArray实例。
        TypedArray.of()
    静态方法
        TypedArray.of()               将参数转为一个TypedArray实例。
        TypedArray.from()             把一个可遍历的数据结构转换为TypedArray。
    范例
        构造函数生成视图
            // 创建一个8字节的ArrayBuffer
            var b = new ArrayBuffer(8);
            // 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾
            var v1 = new Int32Array(b);
            // 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾
            var v2 = new Uint8Array(b, 2);
            // 创建一个指向b的Int16视图，开始于字节2，长度为2
            var v3 = new Int16Array(b, 2, 2);
        不通过ArrayBuffer对象生成视图
            //生成包含8个成员的Float64Array数组，长度为64位
            var f64a = new Float64Array(8);
            f64a[0] = 10;
            f64a[1] = 20;
            f64a[2] = f64a[0] + f64a[1];
        复制其他视图（内存不同）
            var x = new Int8Array([1, 1]);
            var y = new Int8Array(x);
            x[0] // 1
            y[0] // 1
            x[0] = 2;
            y[0] // 1
        复制其他视图（内存相同）
            var x = new Int8Array([1, 1]);
            var y = new Int8Array(x.buffer);
            x[0] // 1
            y[0] // 1
            x[0] = 2;
            y[0] // 2
        转换为普通数组
            var normalArray = Array.prototype.slice.call(typedArray);
        字节序
            // 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]
            var buffer = new ArrayBuffer(4);
            var v1 = new Uint8Array(buffer);
            v1[0] = 2;
            v1[1] = 1;
            v1[2] = 3;
            v1[3] = 7;
            var uInt16View = new Uint16Array(buffer);
            // 计算机采用小端字节序
            // 所以头两个字节等于258
            if (uInt16View[0] === 258) {
                console.log(&apos;OK&apos;); // &quot;OK&quot;
            }
            // 赋值运算
            uInt16View[0] = 255;    // 字节变为[0xFF, 0x00, 0x03, 0x07]
            uInt16View[0] = 0xff05; // 字节变为[0x05, 0xFF, 0x03, 0x07]
            uInt16View[1] = 0x0210; // 字节变为[0x05, 0xFF, 0x10, 0x02]
        字符串转换
            // ArrayBuffer转为字符串，参数为ArrayBuffer对象
            function ab2str(buf) {
                return String.fromCharCode.apply(null, new Uint16Array(buf));
            }
            // 字符串转为ArrayBuffer对象，参数为字符串
            function str2ab(str) {
                var buf = new ArrayBuffer(str.length * 2); // 每个字符占用2个字节
                var bufView = new Uint16Array(buf);
                for (var i = 0, strLen = str.length; i &lt; strLen; i++) {
                    bufView[i] = str.charCodeAt(i);
                }
                return buf;
            }
        溢出
            var uint8 = new Uint8Array(1);
            uint8[0] = 256;  // 100000000
            uint8[0]         // 0
            uint8[0] = -1;   // 11111111
            uint8[0]         // 255

复合视图
    说明
        在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。
    范例  
        var buffer = new ArrayBuffer(24);
        var idView = new Uint32Array(buffer, 0, 1);
        var usernameView = new Uint8Array(buffer, 4, 16);
        var amountDueView = new Float32Array(buffer, 20, 1);

DataView视图
    说明
        如果一段数据包括多种类型，除复合视图以外，还可以通过DataView视图进行操作。
        DataView视图提供更多操作选项，而且支持设定字节序。
        TypedArray视图是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序。
        DataView视图是用来处理网络设备传来的数据，所以可以自行设定字节序。
        DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图
        读取内存和写入内存的方法可在第二个参数指定字节序。
    格式
        DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);
    实例属性
        DataView.prototype.buffer        返回对应的ArrayBuffer对象
        DataView.prototype.byteLength    返回占据的内存字节长度
        DataView.prototype.byteOffset    返回当前视图从对应的ArrayBuffer对象
    实例方法-读取内存
        getInt8                          读取1个字节，返回一个8位整数
        getUint8                         读取1个字节，返回一个无符号的8位整数
        getInt16                         读取2个字节，返回一个16位整数
        getUint16                        读取2个字节，返回一个无符号的16位整数
        getInt32                         读取4个字节，返回一个32位整数
        getUint32                        读取4个字节，返回一个无符号的32位整数
        getFloat32                       读取4个字节，返回一个32位浮点数
        getFloat64                       读取8个字节，返回一个64位浮点数
    实例方法-写入内存
        setInt8                          写入1个字节的8位整数
        setUint8                         写入1个字节的8位无符号整数
        setInt16                         写入2个字节的16位整数
        setUint16                        写入2个字节的16位无符号整数
        setInt32                         写入4个字节的32位整数
        setUint32                        写入4个字节的32位无符号整数
        setFloat32                       写入4个字节的32位浮点数
        setFloat64                       写入8个字节的64位浮点数
    范例
        创建视图
            var buffer = new ArrayBuffer(24);
            var dv = new DataView(buffer);
        读取内存
            var buffer = new ArrayBuffer(24);
            var dv = new DataView(buffer);
            // 从第1个字节读取一个8位无符号整数
            var v1 = dv.getUint8(0);
            // 从第2个字节读取一个16位无符号整数
            var v2 = dv.getUint16(1);
            // 从第4个字节读取一个16位无符号整数
            var v3 = dv.getUint16(3);
        写入内存
            // 在第1个字节，以大端字节序写入值为25的32位整数
            dv.setInt32(0, 25, false);
            // 在第5个字节，以大端字节序写入值为25的32位整数
            dv.setInt32(4, 25);
            // 在第9个字节，以小端字节序写入值为2.5的32位浮点数
            dv.setFloat32(8, 2.5, true);

二进制数组的应用
    说明
        大量的Web API用到了ArrayBuffer对象和它的视图对象。
    AJAX
        XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。
        如果明确知道返回的二进制数据类型，可以把esponseType设为arraybuffer。
        如果不知道，就设为blob。
    Canvas
        网页Canvas元素输出的二进制像素数据，就是TypedArray数组。
        uint8ClampedArray的视图类型是一种针对Canvas元素的专有类型。
        这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数(0~255)。
        而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。
    WebSocket
        WebSocket可以通过ArrayBuffer，发送或接收二进制数据。
    File API
        如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象。
    范例
        Ajax
            var xhr = new XMLHttpRequest();
            xhr.open(&apos;GET&apos;, someUrl);
            xhr.responseType = &apos;arraybuffer&apos;;
            xhr.send();
            xhr.onreadystatechange = function() {
                if (req.readyState === 4) {
                    var arrayResponse = xhr.response;
                    var dataView = new DataView(arrayResponse);
                    var ints = new Uint32Array(dataView.byteLength / 4);
                }
            }
        Canvas
            var canvas = document.getElementById(&apos;myCanvas&apos;);
            var ctx = canvas.getContext(&apos;2d&apos;);
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var uint8ClampedArray = imageData.data;
        WebSocket
            var socket = new WebSocket(&apos;ws://127.0.0.1:8081&apos;);
            socket.binaryType = &apos;arraybuffer&apos;;
            // Wait until socket is open
            socket.addEventListener(&apos;open&apos;, function(event) {
                // Send binary data
                var typedArray = new Uint8Array(4);
                socket.send(typedArray.buffer);
            });
            // Receive binary data
            socket.addEventListener(&apos;message&apos;, function(event) {
                var arrayBuffer = event.data;
                // ···
            });
        Fetch API
            fetch(url)
            .then(function(request) {
                return request.arrayBuffer()
            })
            .then(function(arrayBuffer) {
                // ...
            });
        File API
            var fileInput = document.getElementById(&apos;fileInput&apos;);
            var file = fileInput.files[0];
            var reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = function () {
                var arrayBuffer = reader.result;
                // ···
            };
</code></pre><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><pre><code>概述
    说明
        SIMD是(Single Instruction/Multiple Data)的缩写，意为“单指令，多数据”。
        它是JavaScript操作CPU对应指令的接口，你可以看做这是一种不同的运算执行模式。
        与它相对的是SISD(Single Instruction/Single Data)，即“单指令，单数据”。
        SIMD的含义是使用一个指令，完成多个数据的运算。
        SISD的含义是使用一个指令，完成单个数据的运算，这是JavaScript的默认运算模式。
        SIMD的执行效率要高于SISD，被广泛用于3D图形运算、物理模拟等运算量超大的项目之中。
        一次SIMD运算，可以处理多个数据，这些数据被称为“通道”（lane）。
    范例
        SISD
            var a = [1, 2, 3, 4];
            var b = [5, 6, 7, 8];
            var c = [];
            c[0] = a[0] + b[0];
            c[1] = a[1] + b[1];
            c[2] = a[2] + b[2];
            c[3] = a[3] + b[3];
            c // Array[6, 8, 10, 12]
        SIMD
            var a = SIMD.Float32x4(1, 2, 3, 4);
            var b = SIMD.Float32x4(5, 6, 7, 8);
            var c = SIMD.Float32x4.add(a, b); // Float32x4[6, 8, 10, 12]

数据类型
    说明
        SIMD提供12种数据类型，总长度都是128个二进制位。
        每种数据类型被x符号分隔成两部分，前面表示通道的宽度和类型，后面表示通道数。
        每个通道之中，可以放置四种数据。Float，Int，Uint(无符号整数)，Bool。
        每种SIMD的数据类型都是一个函数方法，可以传入参数，生成对应的值。
        注意，这些数据类型方法都不是构造函数，前面不能加new，否则会报错。
    数据类型
        Float32x4      四个32位浮点数
        Float64x2      两个64位浮点数
        Int32x4        四个32位整数
        Int16x8        八个16位整数
        Int8x16        十六个8位整数
        Uint32x4       四个无符号的32位整数
        Uint16x8       八个无符号的16位整数
        Uint8x16       十六个无符号的8位整数
        Bool32x4       四个32位布尔值
        Bool16x8       八个16位布尔值
        Bool8x16       十六个8位布尔值
        Bool64x2       两个64位布尔值
    范例
        var a = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);

静态方法：数学运算
    实例方法
        abs()           将它的每个通道都转成绝对值，返回一个新的SIMD值
        neg()           将它的每个通道都转成负值，返回一个新的SIMD值
        add()           将两个SIMD值的每个通道相加，返回一个新的SIMD值
        addSaturate()   和add作用一致，但溢出时返回该数据类型的最大值，add遗弃溢出值
        sub()           将两个SIMD值的每个通道相减，返回一个新的SIMD值。
        subSaturate()   和sub作用一致，但溢出时返回该数据类型的最小值，sub遗弃溢出值
        mul()           将两个SIMD值的每个通道相乘，返回一个新的SIMD值。
        div()           将两个SIMD值的每个通道相除，返回一个新的SIMD值。
        sqrt()          求出每个通道的平方根，返回一个新的SIMD值。
        reciprocalApproximation()      求出每个通道的倒数，返回一个新的SIMD值。
        reciprocalSqrtApproximation()  求出每个通道的平方根的倒数（1 / (x^0.5)）

静态方法：通道处理
    方法
        check()         检查一个值是否为当前类型的SIMD值。是则返回这个值，否则报错
        extractLane()   用于返回给定通道的值，它接受两个参数，分别是SIMD值和通道编号
        replaceLane()   替换指定通道的值，并返回一个新的SIMD值
        load()          从二进制数组读入数据，生成一个新的SIMD值
        load1()         load方法的变种，只加载一个通道
        load2()         load方法的变种，加载两个通道
        load3()         load方法的变种，加载三个通道
        store()         将一个SIMD值，写入一个二进制数组
        splat()         返回一个新的SIMD值，该值的所有通道都会设成同一个预先给定的值
        swizzle()       重新排列原有的SIMD值的通道顺序
        shuffle()       从两个SIMD值之中取出指定通道，返回一个新的SIMD值

静态方法：比较运算
    方法
        equal()              比较每个通道是否相等，返回一个新的Bool32x4
        notEqual()           比较每个通道是否不相等，返回一个新的Bool32x4
        greaterThan()        比较每个通道的大小，判断是否大于，返回一个新的Bool32x4
        greaterThanOrEqual() 比较每个通道的大小，判断是否大于等于，返回新的Bool32x4
        lessThan()           比较每个通道的大小，判断是否小于，返回一个新的Bool32x4
        lessThanOrEqual()    比较每个通道的大小，判断是否小于等于，返回新的Bool32x4
        select()             通过掩码生成一个新的SIMD值。
        allTrue()            返回一个布尔值，表示该SIMD值的所有通道是否都为true
        anyTrue()            只要有一个通道为true，就返回true，否则返回false
        min()                将两个SIMD的每个通道的最小值组成一个新的SIMD返回
        minNum()             与min区别是，一个数为NaN，min返回NaN，minNum返回另外值
        max()                将两个SIMD的每个通道的最大值组成一个新的SIMD返回
        maxNum()             与max区别是，一个数为NaN，max返回NaN，maxNum返回另外值

静态方法：位运算
    方法
        and()       返回两个SIMD每个通道进行二进制AND运算（&amp;）后得到的新的SIMD值
        or()        返回两个SIMD每个通道进行二进制OR运算（|）后得到的新的SIMD值
        xor()       返回两个SIMD每个通道进行二进制异或运算（^）后得到的新的SIMD值
        not()       返回两个SIMD每个通道进行二进制否运算（~）后得到的新的SIMD值

静态方法：数据类型转换
    说明
        SIMD提供以下方法，用来将一种数据类型转为另一种数据类型。
        带有Bits后缀的方法，会原封不动地将二进制位拷贝到新的数据类型。
        不带后缀的方法，则会进行数据类型转换。
    方法
        fromFloat32x4()
        fromFloat32x4Bits()
        fromFloat64x2Bits()
        fromInt32x4()
        fromInt32x4Bits()
        fromInt16x8Bits()
        fromInt8x16Bits()
        fromUint32x4()
        fromUint32x4Bits()
        fromUint16x8Bits()
        fromUint8x16Bits()

实例方法
    说明
        toString方法返回一个SIMD值的字符串形式。
    范例
        var a = SIMD.Float32x4(11, 22, 33, 44);
        a.toString() // &quot;SIMD.Float32x4(11, 22, 33, 44)&quot;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/Javascript-设计模式/" itemprop="url">
                  Javascript-设计模式.md
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-11T11:47:52+08:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h2><pre><code>说明
    单体(Singleton)模式的思想在于保证一个特性的类仅有一个实例。
    实现的方式有多种方案，主要思路为判断实例是否存在，下面是其中两种常见的方式。
    第一种是通过类的静态属性保存实例，缺点是静态属性可改写。
    第二种是通过闭包内的局部变量存储实例，缺点是会带来闭包的格外开销。
范例
    类属性方式
        function Person(){
            // 判断是否类的静态属性instance是否存在
            if(typeof Person.instance === &quot;object&quot;){
                return Person.instance;
            }
            this.name = &quot;Jack&quot;;
            this.age = 18;
            // 通过构造函数创建实例时，把实例的引用保存在Person的静态属性中
            Person.instance = this;
        }
        var p1 = new Person;
        var p2 = new Person;
        p1===p2;  //true
    闭包方式
        var Person = (function () {
            var instance;
            var Person = function Person() {
                if(instance){
                    return instance;
                }
                this.name = &quot;Jack&quot;;
                this.age = 18;
                instance = this;
            }
            return Person
        }())
        Person.prototype.nothing = true;
        var p1 = new Person;
        Person.prototype.everything = true;
        var p2 = new Person;
        p1===p2;  //true
        p1.nothing &amp;&amp; p2.nothing &amp;&amp; p1.everything &amp;&amp; p2.everything //true
        p1.name //&quot;Jack&quot;
        p1.constructor === Person //true
</code></pre><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code>说明
    工厂模式的目的主要为了创建对象，通常在类的静态方法中实现。
    许多类型对象的创造需要一系列的步骤，比如设置属性，位置，选择为哪个子类的实例等。 
    这一系列的重复操作类似类似工厂一样。
    可以给类添加一个工厂方法，只需要一个参数，便能完成这些不同类型的实例的设置。
    全局Object构造函数就是一个工厂模式的例子，可以通过传递不同的参数生成不同类型的实例。
    工厂模式又区分简单工厂模式和抽象工厂模式，下面范例为抽象工厂模式。

范例
    // Vehicle为父类用来派生子类
    var Vehicle = function(){};
    Vehicle.prototype.drive = function () {
        console.log(&quot;I have &quot; + this.doors + &quot; doors&quot;);
    }
    // 定义工厂方法
    Vehicle.factory = function(type){
        var newcar;
        // 如果不存在对应的之类则抛出错误
        if(typeof Vehicle[type] !== &quot;function&quot;){
            throw{
                name:&quot;Error&quot;,
                message:type + &quot;doesn&apos;s exist&quot;
            }
        };
        // 用于给子类设置原型为父类的实例，并只设置一次
        if(typeof Vehicle[type].prototype !== &quot;function&quot;){
            Vehicle[type].prototype = new Vehicle();
        };
        // 创建一个新的实例
        newcar = new Vehicle[type]();
        // 可以做一些其他操作并返回...
        return newcar;
    }
    // 下面是特定类型的实例的构造函数
    Vehicle.Micro = function(){
        this.doors = 2;
    };
    Vehicle.Compact = function(){
        this.doors = 4;
    };
    Vehicle.SUV = function(){
        this.doors = 8;
    };
    // 通过工厂方法创建实例
    var micro = Vehicle.factory(&quot;Micro&quot;);
    micro.drive();    //I have 2 doors
    var compact = Vehicle.factory(&quot;Compact&quot;);
    compact.drive();  //I have 4 doors
    var suv = Vehicle.factory(&quot;SUV&quot;);
    suv.drive();      //I have 8 doors
</code></pre><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><pre><code>说明
    迭代器模式中，通常有一个包含某种数据集合的对象。
    该数据可在存储在一个复杂数据结构的内部，需要提供一个简单的方法来访问数据中的每个元素。
    对象的使用者不需要知道对象内部如何组织数据，仅需要使用对象提供的方法取出数据使用。
    通常对象需要提供一个next方法，依次调用next()必须返回下一个连续的元素。
    在特定的数据结构中，next方法所返回的&quot;下一个&quot;元素可由您来使用。

范例
    var generator = (function(){
        var index = 0,
            data = [1,2,3,4,5],
            length = data.length;
        return {
            // 取出下一个元素
            next: function(){
                var element;
                if(!this.hasNext()){
                    return null;
                }
                element = data[index];
                index ++;
                return element;
            },
            // 检测是否到最后一个元素
            hasNext: function(){
                return index &lt; length
            },
            // 重置指针到初始位置
            rewind: function(){
                index = 0;
            },
            // 返回当前元素
            current: function(){
                return data[index &lt; length ? index : length - 1];
            }
        }
    }());
    var arr = [];
    while(generator.hasNext()){
        arr.push(generator.next());
    }
    arr  // [1,2,3,4,5]
    generator.current()) // 5
    generator.rewind()
    generator.current()) // 1
</code></pre><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><pre><code>说明
    在装饰者模式中，可以在运行时动态添加附件功能到对象中。
    因JavaScript的对象是可边的，添加功能到对象的过程非常容易。

范例
    // 货币的构造函数
    function Money(amount){
        this.amount = amount || 100;
        this.decoratorsList = [];
    }
    // 装饰方法
    Money.prototype.decorate = function(decorater){
        this.decoratorsList.push(decorater)
    };
    // 获取处理后的金额
    Money.prototype.getAmount = function(){
        var amount = this.amount,
            name;
        for(var i = 0; i &lt; this.decoratorsList.length; i++){
            var key = this.decoratorsList[i];
            amount = Money.decorators[key].getAmount(amount) ;
        }
        return amount;
    };
    // 装饰者列表
    Money.decorators = {}
    // 货币转换
    Money.decorators.toUSD = {
        getAmount: function(amount){
            return amount * 0.8;
        }
    }
    // 加上额外的货币转换手续费
    Money.decorators.addTax = {
        getAmount: function(amount){
            return amount * 1.01;
        }
    }
    // 使用
    var m = new Money(100);
    m.decorate(&quot;toUSD&quot;);
    m.decorate(&quot;addTax&quot;);
    m.getAmount(); // 80.8
</code></pre><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><pre><code>说明
    策略模式支持在运行时选择算法。目的是把程序的接口和算法解耦。
    常见的例子是表单验证的方法，可根据数据类型的不同选择不同的验证规则。

范例
    var validator = {
        // 对不同数据的验证配置
        config: {
            name: &quot;isNonEmpty&quot;,
            age: &quot;isNumber&quot;,
            email: &quot;isEmail&quot;
        },
        // 验证后的错误信息列表
        messages: [],
        // 验证方法
        types: {
            isNonEmpty: {
                validate: function(value){
                    return value !== &quot;&quot;;
                },
                errMsg:&quot;the value cannot be empty&quot;
            },
            isNumber: {
                validate: function(value){
                    return !isNaN(value);
                },
                errMsg:&quot;the value can only be a number&quot;
            },
            isEmail: {
                validate: function(value){
                    var reg = /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
                    return reg.test(value)
                },
                errMsg:&quot;the value can only be a email&quot;
            }
        },
        // 验证方法
        validate: function(data){
            var i, msg, type, checker, resultOk;
            // 重置所有消息
            this.messages = [];
            // 对所有字段进行校验
            for(i in data){
                type = this.config[i];
                checker = this.types[type];
                resultOk = checker.validate(data[i]);
                if(!resultOk){
                    msg = checker.errMsg;
                    this.messages.push(msg)
                }
            }
            return this.hasError();
        },
        // 数据是否有错误
        hasError: function(){
            return this.messages.length !== 0;
        }
    };
    var data = {
        name: &quot;&quot;,
        age: &quot;err&quot;,
        email: &quot;name@gamil.com&quot;
    }
    var hasError = validator.validate(data);
    console.log(hasError) //true
    console.log(validator.messages.join(&quot;,&quot;))
    //&quot;the value cannot be empty,the value can only be a number&quot;
</code></pre><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><pre><code>说明
    通过把常用方法包装到一个新的方法中，从而提供一个更为便利的API。

范例
    var event = {
        // ...
        stop: function (e) {
            e.preventDefault();
            e.stopPropagation();
        }
        // ...
    };
</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><pre><code>说明
    在代理模式中，一个对象充当另外一个对象的接口。
    代理介于对象的客户端和对象本身之间，并且对该对象的访问提供保护。
    代理模式可用于服务器请求的合并，降低服务器压力。
    下面的例子中taskProxy用来作为doTask的代理，积累1S内的任务统一执行。

范例
    // 执行任务的方法
    var doTask = function(msg){
        console.log(&quot;doTask: &quot; + msg);
    }
    // 中间代理
    var taskProxy = (function(){
        // 代发送的消息列表
        var msgList = [];
        // 任务队列是否已经开始积累任务
        var taskQueueStart = false;
        var task = function(msg){
            msgList.push(msg);
            if(!taskQueueStart){
                setTimeout(function(){
                    doTask(msgList.join(&quot;, &quot;));
                    msgList = [];
                    taskQueueStart = false;
                }, 1000);
            }
            taskQueueStart = true;
        }
        return task
    }());
    // 同时执行三个任务
    taskProxy(&quot;msg-1&quot;);
    taskProxy(&quot;msg-2&quot;);
    taskProxy(&quot;msg-3&quot;);
    // doTask: msg-1, msg-2, msg-3
</code></pre><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><pre><code>说明
    多个对象间相互并不直接通信，而是仅通过中介者对象进行通信，从而促进形成松散耦合。

范例
    // 创建数据模型
    function Model(){
        this.data = [];
    }
    Model.prototype.getNumber = function(){
        console.log(this.data.join(&quot;,&quot;));
    }
    // 构造两个实例，分别用来收集单数和偶数
    var oddModel = new Model(),
        evenModel = new Model();
    // 中介者
    var mediator = function(){
        arr = [].slice.call(arguments);
        for (var i = 0; i &lt; arr.length; i++) {
            if(arr[i] % 2 === 1){
                oddModel.data.push(arr[i])
            }else{
                evenModel.data.push(arr[i])
            }
        }
    }
    mediator(1,2,3,4,5,6,7,8,9,0)
    oddModel.getNumber();   // 1,3,5,7,9
    evenModel.getNumber();  // 2,4,6,8,0
</code></pre><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><pre><code>说明
    观察者模式广泛应用于客户端JavaScript编程中，所有的浏览器事件都是该模式的例子。
    它的另外一个名字称为自定义事件，也可称为订阅/发布模式。
    该模式的实现是通过创建可观察的对象，发生事件时将事件通知给所有观察者，从而形成松耦合。

范例
    // 通用的发布者对象
    var publisher = {
        // 存放不同事件类型订阅者数组的对象
        subscribers: {
            any: []  //any事件类型
        },
        // 订阅
        subscribe: function(fn, type) {
            // 默认为any事件
            type = type || &quot;any&quot;;
            // 当事件不存在时在subscribers里面添加
            if(typeof this.subscribers[type] === &quot;undefined&quot;){
                this.subscribers[type] = [];
            }
            this.subscribers[type].push(fn)
        },
        // 取消订阅
        unsubscribe: function(fn, type){
            this.visitSubscribers(&quot;unsubscribe&quot;,fn,type);
        },
        // 发布事件
        publish: function(publication, type){
            this.visitSubscribers(&quot;publish&quot;,publication,type);
        },
        // 这个方法的内部用来发布或取消订阅
        visitSubscribers: function(action, arg, type){
            var pubtype = type || &quot;any&quot;,
                subscribers = this.subscribers[pubtype];
            for (var i = 0; i &lt; subscribers.length; i++) {
                if(action === &quot;publish&quot;){
                    subscribers[i](arg);
                }else{
                    if(subscribers[i] === arg){
                        subscribers.splice(i,1);
                    }
                }
            }

        }
    }
    // 可将通用发布者对象的方法拷贝到指定对象中
    function makePublisher(o){
        var i;
        for (i in publisher) {
            if(publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === &quot;function&quot;){
                o[i] = publisher[i];
            }
        }
        o.subscribers = {any:[]};
    }
    // 实现paper对象，它可以发布日报和月刊
    var paper = {
        daily: function(){
            this.publish(&quot;big news today&quot;);
        },
        monthly: function(){
            this.publish(&quot;interesting analysis&quot;,&quot;monthly&quot;);
        }
    }
    makePublisher(paper);
    // 实现订阅者
    var joe = {
        drinkCoffee: function(paper){
            console.log(&quot;Just read &quot; + paper);
        },
        sundayPreNap: function(monthly){
            console.log(&quot;About to fall asleep reading this &quot; + monthly);
        }
    }
    // paper注册joe
    paper.subscribe(joe.drinkCoffee);
    paper.subscribe(joe.sundayPreNap,&quot;monthly&quot;);
    // 发布
    paper.daily();    // Just read big news today
    paper.daily();    // Just read big news today
    paper.monthly();  // About to fall asleep reading this interesting analysis
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Cao Zheng" />
          <p class="site-author-name" itemprop="name">Cao Zheng</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cao Zheng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
