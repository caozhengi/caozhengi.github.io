<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Uiideas Blog">
<meta property="og:url" content="http://blog.uiideas.com/index.html">
<meta property="og:site_name" content="Uiideas Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Uiideas Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Uiideas Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?559798d21c881907a6a2339e025bbc03";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Uiideas Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章列表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/20/iOS-多线程网络/" itemprop="url">
                  iOS-多线程网络
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-20T15:47:52+08:00" content="2016-11-20">
              2016-11-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><pre><code>进程
    说明
        进程是指在系统中正在运行的一个应用程序
        每个进程间是独立的，每个进程均运行在其专用且受保护的内存空间内

线程
    说明
        一个进程要执行任务，必须有线程（每一个进程至少要一个线程）
        一个进程（程序）的所有人物都在线程中执行
        线程是进程中的一条执行路径

线程的串行
    说明
        一个线程里面任务的执行顺序是串行的
        如果要子1个线程中执行多个任务，那么只能一个一个的按照顺序执行这些任务

主线程
    说明
        一个iOS程序运行后，默认会开启一条线程，称为 主线程 或 UI线程
        iOS中的和UI相关的所有操作必须在主线程中执行
    作用
        显示\刷新UI界面
        处理UI事件(比如点击事件,滚动事件,拖拽事件)
    使用注意
        不要将比较耗时的操作放倒主线程中
        耗时操作会阻塞主线程，严重影响UI的流畅度，给用户一种卡的体验
        可将耗时操作放在子线程中执行

子线程
    说明
        iOS中除了主线程之外的线程都是子线程
        子线程也称为(后台线程，非主线程)

多线程
    说明
        一个进程中可以开启多条线程，每个线程可以并行执行不同的任务
    原理
        同一时间，CPU只能处理一条线程，只有1条线程在执行
        多线程的并发执行，其实是CPU快速的在多条线程之间调度(切换)
        如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
    优点
        能适当提高程序的执行效率
        能适当的提高资源的利用率(CPU,内存的利用率)
    缺点
        创建线程是有开销的，iOS下主要成本包括:
            内核数据结构(大约1KB)
            栈空间(子线程512KB,主线程1MB,可使用-setStackSize设置，最小16K)
            创建线程答曰需要90毫秒的时间
        如果开启大量的线程，会降低程序的性能
        线程越多，CPU在调度线程上的开销就越大
        程序设计更佳复杂，比如线程之间的通信，多线程的数据共享
    资源共享
        一块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源
        多个线程访问同一个对象，同一个变量，同一个文件
    安全隐患
        当多个线程访问同一块资源时，很容易引发数据错乱和安全问题
        可用 @synchronized 加入互斥锁来解决此问题

进程和线程的比较
    线程是CPU调用(执行任务)的最小单位。
    进程是CPU分配资源和调度的单位
    一个程序可以对应多个线程，一个进程中可以有多个线程，但至少有一个线程
    同一个进程内的线程共享进程的资源
</code></pre><h2 id="线程在iOS中的使用"><a href="#线程在iOS中的使用" class="headerlink" title="线程在iOS中的使用"></a>线程在iOS中的使用</h2><pre><code>iOS中多线程实现方案
    pthread
        C语言API，由程序员管理生命周期
        通用的多线程API
        适用于Unix\Linux\Window等系统
        跨平台可移植，使用难度大
    NSThread
        OC语言API，程序员负责生命周期中的创建系统处理释放
        面向对象的API
        使用简单，可直接操作线程对象
    GCD
        C语言API，生命周期系统自动管理
        旨在替代NSThread等线程技术
        充分利用CPU的多核
    NSOperation
        OC语言API，生命周期系统自动管理
        基于GCD (底层是GCD)
        比GCD多了一些更简单实用的功能
        使用更面相对象

pthread
    说明
        使用需导入 pthread.h 头文件
        iOS较少使用
    函数
        pthread_create                    创建线程
        pthread_equal                     判断两条线程是否相等
        pthread_detach                    分离线程
        pthread_exit                      退出线程
    范例
        pthread_t thread;
        pthread_create(&amp;thread, NULL, task, NULL);
        void *task(void *param){
            return NULL;
        }

NSThread
    说明
        iOS中线程的类
        一个NSThread对象代表一条线程
        线程number属性为1时，该线程为主线程
    生命周期
        当线程内的任务执行完毕后，线程自动释放
        当线程死亡后无法执行任务
    状态
        新建状态-New             通过initWithTarget方法创建后
        就绪状态-Runnable        调用start方法后，会放入可调度线程池
        运行状态-Running         当CPU调度到线程中的任务执行时
        阻塞状态-Blocked         调用了sleep方法\等待同步锁
        死亡状态-Dead            当线程执行结束或意外退出
    互斥锁
        说明
            互斥锁能有效的防止因多线程抢夺资源造成的数据安全问题
            缺点是需要消耗大量CPU资源
            加锁是需注意加锁的位置
            加锁会造成 线程同步(多条线程在同一线上按顺序执行任务)
        格式
            @synchronized(锁对象){ //需要锁定的代码 };
    原子和非原子属性
        atomic     原子属性，为setter方法加锁，默认为atomic
        noatomic   非原子属性，不会为setter方法加锁
    线程间通信
        performSelectorOnMainThread       回到主线程继续执行任务
        performSelector:onThread:         转到指定线程执行任务
    类方法
        mainThread                        获取主线程
        currentThread                     获取当前线程
        isMainThread                      当前线程是否是主线程
        detachNewThreadSelector           分离出来子线程
        sleepUntilDate                    睡到指定时间再继续执行,进入阻塞状态
        sleepForTimeInterval              暂定指定的时间,让线程进入阻塞状态
        exit                              终止线程,死亡状态
    对象方法
        start                             启动线程，线程进行就绪状态
        isMainThread                      判断该线程对象是否是主线程对象
    对象属性
        name                              线程的名称
        threadPriority                    线程优先级,0.0-1.0之间,默认0.5
    范例
        创建线程,init方式
            NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(task:) object:@&quot;ABC&quot;];
            [thread start];
            -(void)task:(NSString *)param{
                NSLog(@&quot;%@&quot;,param);
            }
        创建线程方法2
            [NSThread detachNewThreadSelector:@selector(task:) toTarget:self withObject:@&quot;ABC&quot;];
            -(void)task:(NSString *)param{
                NSLog(@&quot;%@&quot;,param);
            }
        创建线程方式3
            [self performSelectorInBackground:@selector(task) withObject:self];
            -(void)task{
                NSLog(@&quot;%@&quot;,param);
            }

GCD
    说明
        全程是 Grand Central Dispatch，可译为中央调度器
        纯C语言，提供了很多强大的函数
    GCD的优势
        GCD是苹果公司为多核的并行运算提供的解决方法
        GCD会自动利用更多的CPU内核
        GCD会自动管理线程的生命周期，包括创建，调度，销毁
        程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码
    任务和队列
        GCD有两个非常核心的概念
        任务: 执行的操作
        队列: 用来存放任务，任务的取出遵循FIFO原则(先进先出)。
    队列类型
        并发队列 (Concurrent Dispatch Queue)
            可以让多个任务并发执行，自动开启多个线程同时执行任务
            多个任务时，并非每个任务都开启一个线程
            并发功能只有在异步函数(dispatch_async)下才有效
            创建队列时候参数为:DISPATCH_QUEUE_SERIAL
        串行队列 (Serial Dispatch Queue)
            让任务一个一个接着执行，一个任务执行完毕才执行下一个
            创建队列时候参数为:DISPATCH_QUEUE_SERIAL
    主队列
        主队列是GCD自带的一种特殊的串行队列
        放在主队列中的任务都会放到主线程中执行
        使用 dispatch_get_main_queue() 获得主队列
    队列优先级
        DISPATCH_QUEUE_PRIORITY_HIGH         高优先级
        DISPATCH_QUEUE_PRIORITY_DEFAULT      默认优先级
        DISPATCH_QUEUE_PRIORITY_LOW          低优先级
        DISPATCH_QUEUE_PRIORITY_BACKGROUND   后台优先级，最低
    使用步骤
        1.定制任务
        2.将任务添加到队列中
    函数
        dispatch_queue_create        创建队列，可指定标识和队列类型
        dispatch_sync                用同步的方式执行任务，不开启新线程
        dispatch_async               用异步的方式执行任务，开启新线程执行任务
        dispatch_async_f             和dispatch_async的区别是用函数执行任务
        dispatch_get_global_queue    获取全局并发队列
        dispatch_get_main_queue      获取主队列
        dispatch_after               延迟执行指定任务，可指定队列和延迟时间
        dispatch_source_timer        定时器，比NSTimer更加精准，不受RunLoop影响
        dispatch_once                一次性代码，整个应用程序运行中只执行一次
        dispatch_barrier_async       栅栏，可控制并发队列的顺序(不能使用全局并发队列)
        dispatch_apply               快速迭代，异步并发执行指定的代码(只能并发队列)
        dispatch_group_create        创建队列组
        dispatch_group_async         把任务添加到异步队列，并在完成后通知队列组
        dispatch_group_notify        当队列组中所有任务执行完成后，执行指定block
        dispatch_group_wait          当队列组的任务执行指定的时间后执行后面的代码
        dispatch_group_enter         在该函数后面的任务会被纳入到队列组
        dispatch_group_leave         任务执行成功后通知队列组
    范例
        异步并行队列: 开多条线程，并发执行
            dispatch_queue_t queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);
            dispatch_async(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
        异步串行队列: 开一条线程，串行执行
            dispatch_queue_t queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_SERIAL);
            dispatch_async(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
        同步串行队列: 不开线程，串行执行
            dispatch_queue_t queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_SERIAL);
            dispatch_sync(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
        异步函数和主队列: 不开线程，串行执行
            dispatch_queue_t queue = dispatch_get_main_queue();
            dispatch_async(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
        同步函数和主队列: 无法执行，造成死锁
            dispatch_queue_t queue = dispatch_get_main_queue();
            dispatch_sync(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
        获取全局并发队列
            dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        快速迭代: 子线程和主线程一起完成并发任务
            dispatch_queue_t queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);
            dispatch_apply(10, queue, ^(size_t index) {
                NSLog(@&quot;%ld----%@&quot;,index,[NSThread currentThread]);
            });
        队列组
            dispatch_queue_t queue = dispatch_queue_create(&quot;asyncConcurrent&quot;, DISPATCH_QUEUE_CONCURRENT);
            dispatch_group_t group = dispatch_group_create();
            dispatch_async(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
            dispatch_async(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
            dispatch_async(queue, ^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            });
            dispatch_group_notify(group, queue, ^{
                NSLog(@&quot;All task success&quot;);
            });
        GCD定时器定时执行任务: 需保持timer的引用才会执行
            @property (nonatomic, strong) dispatch_source_t timer;
            dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0));
            dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);
            dispatch_source_set_event_handler(timer, ^{
                //需要执行的任务
            });
            dispatch_resume(timer);
            self.timer = timer;

NSOperation
    说明
        基于GCD的OC语言API，使用更面相对象。
        NSOperation和NSOperationQueue配合使用可实现多线程编程
        NSOperation是抽象类，并不具备封装操作的能力，需使用其子类
    使用步骤
        1. 将要执行的操作封装到一个NSOperation对象中
        2. 然后将NSOperation对象添加到NSOperationQueue中
        3. 系统会自动将NSOperationQueue中的操作放到一条新线程中执行
    自定义NSOperation
        可在自定义继承自NSOperation的类重写-(void)main方法来封装任务
        NSOperationQueue对象的addOperation方法会调用自定义对象的start方法
        NSOperation对象的start方法内部会调用main方法
    子类
        NSInvocationOperation
        NSBlockOperation             通过Block的方式封装任务            
    NSBlockOperation对象方法
        addExecutionBlock            追加任务，如果对象内的任务大于1会开多线程并发
        start                        开始任务
        addDependency                添加依赖，指定某个操作完成后才执行
        completionBlock              当所有任务执行完成后执行的Block
    NSOperationQueue
        属性
            maxConcurrentOperationCount  最大并发数量,设置为1时串行执行
            suspended                    暂停或恢复
        类方法
            mainQueue                    获取主队列，串行队列，主线程中执行
        对象方法
            init                         同时具备并发和串行队列，默认并发非主队列
            addOperation                 把任务添加到队列中
            cancelAllOperations          取消队列中所有操作
            setSuspended                 设置暂停或恢复
    范例
        NSInvocationOperation基本使用
            NSInvocationOperation *op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task:) object:@&quot;param&quot;];
            [op start];
            -(void)task:(NSString *)param{
                NSLog(@&quot;%@-----%@&quot;,param,[NSThread currentThread]);
            }
        NSBlockOperation基本使用
            NSBlockOperation *bop = [NSBlockOperation blockOperationWithBlock:^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            }];
            [bop addExecutionBlock:^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            }];
            [bop start];
        通过队列执行NSInvocationOperation操作
            NSInvocationOperation *op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task:) object:@&quot;param&quot;];
            NSInvocationOperation *op2 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task:) object:@&quot;param&quot;];
            NSOperationQueue *queue = [[NSOperationQueue alloc]init];
            [queue addOperation:op1];
            [queue addOperation:op2];
        通过队列执行NSBlockOperation操作
            NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            }];
            NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            }];
            NSOperationQueue *queue = [[NSOperationQueue alloc]init];
            [queue addOperation:op1];
            [queue addOperation:op2];
        队列添加任务的简洁操作
            NSOperationQueue *queue = [[NSOperationQueue alloc]init];
            [queue addOperationWithBlock:^{
                NSLog(@&quot;%@&quot;,[NSThread currentThread]);
            }];
</code></pre><h2 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h2><pre><code>说明
    NSCache是苹果官方提供的缓存类，使用和NSDictionary类似
    NSCache在系统内存很低时，会自动释放对象(模拟器中不会)
    NSCache是线程安全的，在多线程操作中，不需要对NSCache加锁
    NSCache的key只是对对象的Strong引用，而不是靠谱

属性
    name                 名称
    delegate             代理对象
    totlaCostLimit       缓存空间的总成本，超出会自动回收前面的对象，默认为0表示无限制
    countLimit           能够缓存的对象的最大数量，默认为0，表示无限制

代理方法
    willEvictObject      即将回收对象时调用

范例
    基本操作
        NSCache *cache = [[NSCache alloc]init];
        [cache setObject:@&quot;value&quot; forKey:@&quot;key&quot;];
        [cache objectForKey:@&quot;key&quot;];
        [cache removeAllObjects];
    设置成本
        NSCache *cache = [[NSCache alloc]init];
        cache.totalCostLimit = 5;
        for (int i = 0; i &lt; 10; i++) {
            [cache setObject:[NSString stringWithFormat:@&quot;value-%d&quot;,i] forKey:[NSString stringWithFormat:@&quot;key-%d&quot;,i] cost:1];
        };
        for (int i = 0; i &lt; 10; i++) {
            NSString *str = [cache objectForKey:[NSString stringWithFormat:@&quot;key-%d&quot;,i]];
            NSLog(@&quot;%@&quot;,str);
        };
</code></pre><h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><pre><code>说明
    运行循环，是一个永远不会结束的死循环
    如果没有Runloop，程序会在main函数执行完成后退出
    RunLoop是在UIApplicationMain中开启的
    UIApplicationMain因为启动了RunLoop，所以一直没有返回值，始终运行状态
    iOS中有两套API访问RunLoop，分别是 Foundation 框架中的 NSRunLoop 类
    和 Core Foundation 框架中的 CFRunLoopRef (Ref 为 reference 缩写)
    NSRunLoop 是基于 CFRunLoopRef 的一层OC的包装

基本作用
    保持程序的持续运行
    处理App中的各种事件，如触摸事件，定时器事件，Selector事件
    节省CPU资源，提高程序性能。该做事情时做事，该休息时休息

官方资料
    [苹果官方文档][https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html]
    [CFRunLoopRef开源地址][http://opensource.apple.com/source/CF/CF-1151.16/]

RunLoop模式
    在RunLoop中有多个运行模式，但是RunLoop只能选择一种模式运行
    Mode里面至少要有一个 Timer或Source

RunLoop与线程
    每条线程都有唯一的一个与之对应的RunLoop对象
    RunLoop在第一次获取时创建，在线程结束时销毁
    主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建

RunLoop与自动释放池
    当启动的时候创建自动释放池
    当RunLoop即将睡眠的时候销毁之前的释放池，并重新创建新的释放池
    当RunLoop退出的时候最后一次销毁释放池

NSRunLoop
    说明
        在子线程中调用 [NSRunLoop currentRunLoop] 会自动创建对应的RunLoop
    类方法
        currentRunLoop             获取当前线程的RunLoop对象
        mainRunLoop                获取主线程的RunLoop对象
    对象方法
        run                        开启RunLoop
        runMode                    开启RunLoop，指定运行模式和时间
        runUntilDate               开启RunLoop，指定时间
    对象属性
        currentMode                当前RunLoop的运行模式
    范例
        创建一个不自动退出的子线程
            //创建线程
            self.thread = [[NSThread alloc]initWithTarget:self selector:@selector(task1) object:nil];
            [self.thread start];
            -(void)task
            {
                //获得子线程对应的runloop
                NSRunLoop *runloop = [NSRunLoop currentRunLoop];
                //保证runloop不退出
                [runloop addPort:[NSPort port] forMode:NSDefaultRunLoopMode];
                //开启RunLoop,默认是没有开启
                [runloop run];
            }
            执行
            [self performSelector:@selector(otherTask) onThread:self.thread withObject:nil waitUntilDone:YES];

CFRunLoopRef
    函数
        CFRunLoopGetCurrent();     获得当前线程的RunLoop对象
        CFRunLoopGetMain();        获取主线程的RunLoop对象

CFRunLoopModeRef
    说明
        CFRunLoopModeRef代表RunLoop的运行模式
        一个RunLoop包含若干个Mode，每个Mode又包含若干个Source/Timer/Observer
        每次RunLoop启动时，只能指定其中一个Mode，这个Mode被称为CurrentMode
        如果需要切换Mode，只能退出RunLoop，再重新指定一个Mode进入
        这样做主要是为了分离开不同组的Source/Timer/Observer，使其互不影响
    系统默认注册的5个Mode
        kCFRunLoopDefaultMode
            App的默认Mode，通常主线程是在这个Mode下运行
        UITrackingRunLoopMode
            界面跟踪Mode，用于ScrollView追踪触摸滑动，
            保证界面滑动时不受其他Mode影响
        UIInitializationRunLoopMode
            在刚启动App时进入的第一个Mode，启动完成后就不再使用
        GSEventReceiveRunLoopMode
            接受系统事件的内部Mode，通常用不到
        kCFRunLoopCommonMode
            这是一个占位用的Mode，不是真正的Mode
            addTimer时如果forMode为kCFRunLoopCommonMode相当于把定时器同时添加到kCFRunLoopDefaultMode和UITrackingRunLoopMode中
            凡是添加到NSRunLoopCommonModes中的事件都会被同时添加到打上common标签的运行模式上

CFRunLoopSourceRef
    说明
        事件源，输入源相关的类
    以前的分类方式
        Port-Based Sources                 基于端口的事件
        Cuntom Input Sources               自定义事件
        Cocoa Perform Selector Sources     performSelector事件
    目前的分类方式(依据函数调用栈区分)
        Sources0                           非基于Port的，用户触发的消息事件
        Sources1                           基于Port的，系统内部的消息事件
    函数调用栈
        可在Xcode中，通过断点调试的方式查看函数调用栈

CFRunLoopTimerRef
    说明
        定时器事件类，本质上就是NSTimer

CFRunLoopObserverRef
    说明
        观察者，能够监听RunLoop的状态变化
    可监听的时间点
        kCFRunLoopEntry         = (1UL &lt;&lt; 0),    即将进入Loop
        kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1),    即将处理Timer
        kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),    即将处理Source
        kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),    即将进入休眠
        kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6),    刚从休眠中唤醒
        kCFRunLoopExit          = (1UL &lt;&lt; 7),    即将退出Loop
    范例
        CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), 0, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
            //状态改变的回调
        });
        CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);
</code></pre><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><pre><code>HTTP方案
    苹果元生
        NSURLConnection    用法简单，最古老经典直接的一种方案
        NSURLSession       2103年推出，比NSURLConnection强大，苹果目前推荐
        CFNetWork          NSURL*的底层，C语言
    第三方框架
        ASIHttpRequest     外号HTTP终结者，功能强大，已停止更新
        AFNetworking       简单易用，提供了基本够用的功能，维护者众多
        MKNetworkkit       简单易用，印度人维护，维护和使用者少

相关类
    NSURL                  URL相关类
    NSURLRequest           请求对象，一个NSURLRequest对象代表一个请求
    NSMutableURLRequest    NSURLRequest的子类，可变
    NSURLConnection        负责建立连接，发送请求，接收相应数据
    NSURLHTTPResponse      相应头对象，用来接收服务器响应头信息

NSMutableURLRequest
    对象属性
        HTTPMethod         请求方法
        HTTPBody           请求体
        timeoutInterval    请求超时时间
    对象方法
        setValue:forHTTPHeaderField:   设置请求头信息

NSURLHTTPResponse
    说明
        NSURLResponse的子类，用来接收服务器响应头信息
    属性
        statusCode         响应的HTTP状态码

中文转码
    说明
        GET请求中的URL如果包含中文呢需要进行转码
        POST中请求的请求体在调用dataUsingEncoding时不需要再次转码
        可通过分类方式重写NSDictionary的descriptionWithLocale方法来解决系统输出乱码
    范例
        NSString *urlStr = @&quot;http://120.25.226.186:32812/login?username=用户名&amp;pwd=密码&quot;;
        urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        NSURL *url = [NSURL URLWithString:urlStr];

JSON解析
    第三方框架
        JSONKit,SBJson,TouchJSON（性能从左到右越差）
    苹果原生
        NSJSONSerialization（性能最好）

NSJSONSerialization
    说明
        苹果官方提供的JSON序列化反序列化工具，相对第三方框架性能最好
        并不是所有的OC对象都可以转换为JOSN,详情见isValidJSONObject注释
    类方法
        JSONObjectWithData         JSON转换为OC对象
        dataWithJSONObject         OC对象转化为JSON数据
        isValidJSONObject          判断指定的对象是否能转换为JSON
    范例
        OC对象转换为JSON
            NSDictionary *dict = @{
                @&quot;name&quot;:@&quot;jack&quot;,
                @&quot;age&quot;:@12,
                @&quot;num&quot;:@[@1,@2,@3],
            };
            NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];
            NSString *jsonStr = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
        JSON转换成OC对象
            NSString *jsonStr = @&quot;{\&quot;error\&quot;:\&quot;用户名不存在\&quot;,\&quot;code\&quot;:999,\&quot;arr\&quot;:[1,3,5]}&quot;;
            NSData *jsonData = [jsonStr dataUsingEncoding:NSUTF8StringEncoding];
            NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:nil];

NSURLConnection
    说明
        苹果官方的HTTP请求类，使用简单，目前已过期
        当通过代理的方式发起请求时，connectionWithRequest方法内部会将NSURLConnection对象作为一个source添加到当前的RunLoop中，并指定运行模式为默认
        在子线程中调用connectionWithRequest方法需要手动开启RunLoop
        调用start方法时，如果当前RunLoop会自动获取当前线程的RunLoop并开启
    使用步骤
        1. 创建一个NSURL对象，设置请求路径
        2. 创建NSURLRequest请求对象，并设置请求地址，请求头，请求体
        3. 使用NSURLConnection发送请求
    类方法
        sendSynchronousRequest        发送同步请求
        sendAsynchronousRequest       发送异步请求
        connectionWithRequest         通过代理的方式发送网络请求
    对象方法
        initWithRequest               通过代理的方式发送网络请求
        start                         开始发送请求
        cancel                        取消当前请求
        setDelegateQueue              设置代理方法在哪个线程调用，无法设置主队列
    NSURLConnectionDataDelegate代理方法
        didReceiveResponse            接收到服务器响应时调用
        didReceiveData                接收到服务器返回数据时调用，可能多次
        didFailWithError              当请求失败时调用
        connectionDidFinishLoading    请求结束时调用
    范例
        同步GET请求
            //设置URL
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON&quot;];
            //初始化请求对象
            NSURLRequest *request = [[NSURLRequest alloc]initWithURL:url];
            //定义接收相应头的对象
            NSURLResponse *response = nil;
            //发送请求并获取响应体
            NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:nil];
            NSString *responseStr = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
        异步GET请求
            //设置URL
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON&quot;];
            //初始化请求对象
            NSURLRequest *request = [[NSURLRequest alloc]initWithURL:url];
            //发送请求并获取响应体
            [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
                //请求完成的回调
                NSLog(@&quot;响应头:%@,相应体:%@&quot;,response,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);
            }];
        代理方式GET请求
            -(NSData *)responseData{
                if(_responseData == nil){
                    _responseData = [[NSMutableData alloc]init];
                }
                return _responseData;
            }
            -(void)delegateRequest{
                //设置URL
                NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=520it&amp;pwd=520it&amp;type=JSON&quot;];
                //初始化请求对象
                NSURLRequest *request = [[NSURLRequest alloc]initWithURL:url];
                [NSURLConnection connectionWithRequest:request delegate:self];
            }
            //当受到服务器响应时调用
            -(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response{
            }
            //接收到服务器返回数据时调用，可能多次
            -(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data{
                [self.responseData appendData:data];
            }
            //当请求失败时调用
            -(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error{
            }
            //请求结束时调用
            -(void)connectionDidFinishLoading:(NSURLConnection *)connection{
                NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:self.responseData encoding:NSUTF8StringEncoding]);
            }
        POST异步请求
            //设置URL
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];
            //创建可变请求对象
            NSMutableURLRequest *request = [[NSURLRequest alloc]initWithURL:url];
            //修改请求方法
            request.HTTPMethod = @&quot;POST&quot;;
            //设置请求体
            request.HTTPBody = [@&quot;username=520it&amp;pwd=520it&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding];
            //发送请求并获取响应体
            [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
                //请求完成的回调
                NSLog(@&quot;响应头:%@,相应体:%@&quot;,response,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);
            }];

NSURLSession
    说明
        目前苹果官网推荐的请求类
        当使用代理时，NSURLSession对象会存在一个强引用，这个引用是不会被释放的
        当NSURLSession不用时需要手动释放，否则会有内存泄漏问题
        使用代理方式发送请求和上传文件时时需遵守NSURLSessionDataDelegate协议
        使用代理方式下载文件时需遵守NSURLSessionDownloadDelegate协议
    使用步骤
        1. 使用NSURLSession创建Task
        2. 执行Task
    Task类
        NSURLSessionTask                抽象类，其他类继承此类
        NSURLSessionDataTask            用来传输数据，例如POST请求GET请求
        NSURLSessionUploadTask          上传任务的类，继承NSURLSessionDataTask
        NSURLSessionDownloadTask        处理下载任务的类
    NSURLSessionConfiguration
        说明
            NSURLSession的配置信息类，用法和
        类方法
            defaultSessionConfiguration     默认配置信息
            ephemeralSessionConfiguration   不会做持久性缓存
            backgroundSessionConfigurationWithIdentifier  创建后台会话
        属性
            HTTPAdditionalHeaders       请求头部信息
            allowsCellularAccess        是否允许蜂窝访问
            networkServiceType          网络服务类型
            timeoutIntervalForRequest   请求超时时间
    类方法
        sharedSession                   获取共享的NSURLSession对象
        sessionWithConfiguration        自定义NSURLSession对象，可设置代理
    对象方法
        dataTaskWithURL                 通过NSURL直接发送请求，只能发送GET请求
        dataTaskWithRequest             以request对象方式创建task
        downloadTaskWithURL             通过URL创建下载任务
        downloadTaskWithRequest         通过Request创建下载任务
        downloadTaskWithResumeData      通过恢复数据创建下载任务
        invalidateAndCancel             释放NSURLSession对象 
        finishTasksAndInvalidate        释放NSURLSession对象
    代理方法
        didReceiveResponse              接收到服务器的响应时调用
        didReceiveData                  接收到服务器数据时调用，会调用多次
        didCompleteWithError            请求结束或者失败时调用
        didWriteData                    下载文件正在写入数据时调用
        didResumeAtOffset               恢复文件下载时调用
        didFinishDownloadingToURL       下载完成时调用
        didSendBodyData                 上传数据时重复调用，可用来计算进度
        didReceiveChallenge             可用来安装SSL证书
    Task对象方法
        resume                          发送网络请求，默认是暂停的 
        suspend                         暂停
        cancel                          取消
        cancelByProducingResumeData     可恢复的取消
    范例
        异步GET请求
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=123&amp;pwd=456&amp;type=JSON&quot;];
            NSURLRequest *request = [NSURLRequest requestWithURL:url];
            NSURLSession *session = [NSURLSession sharedSession];
            NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);
            }];
            [dataTask resume];
        异步发送POST请求
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];
            NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
            request.HTTPMethod = @&quot;POST&quot;;
            request.HTTPBody = [@&quot;username=123&amp;pwd=456&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding];
            NSURLSession *session = [NSURLSession sharedSession];
            NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);
            }];
            [dataTask resume];
        下载文件
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;];
            NSURLRequest *request = [NSURLRequest requestWithURL:url];
            NSURLSession *session = [NSURLSession sharedSession];
            NSURLSessionDownloadTask *downTask = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                //设置目标文件路径
                NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];
                filePath = [filePath stringByAppendingPathComponent:[url lastPathComponent]];
                //location为文件下载的位置
                [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil];
                NSLog(@&quot;%@&quot;,filePath);
            }];
            [downTask resume];
        上传文件
            //fromData参数需要严格按照格式拼接字符串
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/upload&quot;];
            NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
            request.HTTPMethod = @&quot;POST&quot;;
            [request setValue:@&quot;multipart/form-data; boundary=----WebKitFormBoundaryBT24noDCZdQWr8JQ&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];
            NSURLSession *session = [NSURLSession sharedSession];

            NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:[NSData data] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            }];
            [uploadTask resume];
        代理方法安装SSL证书
            -(void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler{
                if(![challenge.protectionSpace.authenticationMethod isEqualToString:@&quot;NSURLAuthenticationMethodServerTrust&quot;]){
                    return;
                }
                NSURLCredential *credential = [[NSURLCredential alloc]initWithTrust:challenge.protectionSpace.serverTrust];
                completionHandler(NSURLSessionAuthChallengeUseCredential,credential);
            }

AFNetworking
    说明
        使用普遍的HTTP请求框架，内部基于NSURLSession实现
        使用时需导入AFNetworking头文件，其内部会导入其他头文件
    AFHTTPSessionManager
        说明
            HTTP请求管理者
            发送请求时参数为字典方式
            默认响应数据会序列化JSON数据为OC对象
            在成功回调的task任务对象中包含了相应头信息
            发送网络请求是在子线程中处理的，框架内部会自动处理RunLoop相关工作
        类方法
            manager                     创建请求管理者对象，非单例
        对象方法
            GET                         发送GET请求，请求参数为Dict类型
            POST                        发送POST请求，请求参数为Dict类型
            downloadTaskWithRequest     通过Request方式下载文件
            downloadTaskWithResumeData  恢复下载
            uploadTaskWithRequest       通过request上传文件
        对象属性
            responseSerializer          可设置数据解析方式，可解析类型等
    AFNetworkReachabilityManager
        说明
            网络状态监测管理者
        类方法
            sharedManager                     获取单例对象
        对象方法
            setReachabilityStatusChangeBlock  监测网络状态
            startMonitoring                   开始监听
            stopMonitoring                    结束监听
        网络状态
            AFNetworkReachabilityStatusUnknown            未知网络
            AFNetworkReachabilityStatusNotReachable       无网络
            AFNetworkReachabilityStatusReachableViaWWAN   蜂窝网络
            AFNetworkReachabilityStatusReachableViaWiFi   WiFi
    范例
        发送GET请求
            //创建会话管理者
            AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
            //发送GET请求
            [manager GET:@&quot;http://120.25.226.186:32812/login&quot; parameters:@{@&quot;username&quot;:@&quot;user&quot;,@&quot;pwd&quot;:@&quot;123&quot;} progress:^(NSProgress * _Nonnull downloadProgress) {
                //进度的回调
            } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                //成功的回调
                NSLog(@&quot;%@&quot;,responseObject);
                NSLog(@&quot;%@&quot;,task.response);
            } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                //失败的回调
            }];
        发送POST请求
            //创建会话管理者
            AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
            //发送GET请求
            [manager POST:@&quot;http://120.25.226.186:32812/login&quot; parameters:@{@&quot;username&quot;:@&quot;user&quot;,@&quot;pwd&quot;:@&quot;123&quot;} progress:^(NSProgress * _Nonnull uploadProgress) {
                //进度的回调
            } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                //成功的回调
                NSLog(@&quot;%@&quot;,responseObject);
                NSLog(@&quot;%@&quot;,task.response);
            } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                //失败的回调
            }];
        下载文件
            //创建会话管理者
            AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
            //创建request请求对象
            NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/videos/minion_01.mp4&quot;];
            NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
            NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) {
                //进度回调
                NSLog(@&quot;%f&quot;,1.0 * downloadProgress.completedUnitCount/downloadProgress.totalUnitCount);
            } destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
                //指定目标位置的回调，targetPath为临时文件路径，response为响应头信息
                NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];
                filePath = [filePath stringByAppendingPathComponent:response.suggestedFilename];
                return [NSURL fileURLWithPath:filePath];
            } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {
                //下载完成的毁掉，filePath为最终文件路径
            }];
            //执行下载任务
            [downloadTask resume];
        文件上传
            AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
            [manager POST:@&quot;http://120.25.226.186:32812/upload&quot; parameters:@{@&quot;name&quot;:@&quot;username&quot;} constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt;  _Nonnull formData) {
                //拼接用来上传的文件数据
                [formData appendPartWithFileURL:[NSURL URLWithString:@&quot;/User/xxx/xxx.png&quot;] name:@&quot;file&quot; error:nil];
            } progress:^(NSProgress * _Nonnull uploadProgress) {
                NSLog(@&quot;%f&quot;,1.0 * uploadProgress.completedUnitCount/uploadProgress.totalUnitCount);
            } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
                //成功回调
            } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
                //失败回调
            }];
        网络状态检测
            AFNetworkReachabilityManager *manger = [AFNetworkReachabilityManager sharedManager];
            [manger setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
                NSLog(@&quot;%ld&quot;,status);
            }];
            [manger startMonitoring];
</code></pre><h2 id="编码和加密"><a href="#编码和加密" class="headerlink" title="编码和加密"></a>编码和加密</h2><pre><code>BASE64
    NSData的对象方法
        base64EncodedStringWithOptions   对NSData进行Base64编码，返回字符串
        base64EncodedDataWithOptions     对NSData进行Base64编码，返回NSData
        initWithBase64EncodedData        对Base64的NSData进行解码
        initWithBase64EncodedString      对Base64的字符串解码
    范例 
        编码
            NSString *str = @&quot;ABC&quot;;
            NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
            NSString *base64 = [data base64EncodedStringWithOptions:0];
        解码
            NSString *base64Str = @&quot;QUJD&quot;;
            NSData *data = [[NSData alloc]initWithBase64EncodedString:base64Str options:0];
</code></pre><h2 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h2><pre><code>结构说明
    SDWebImageManager               其他类的管理类
    SDImageCache                    处理缓存的类
    SDWebImageDownloader            处理图片下载的工具类
    SDWebImageDownloaderOpertion    具体图片下载任务的类

框架细节
    最大并发数默认为6
    缓存问价的命名为图片URL的MD5散列之后的值
    框架内部通过监听内存警告通知来清空缓存
    框架内部通过NSCache来处理患处
    框架内部通过图片的二进制数据中第一个字节来判断图片类型
    框架内部通过NSURLConnection发送网络请求来下载图片
    框架内部的请求超时时间为15S

设置UIImageView图片
    说明
        方法内部会对图片做 内存缓存 + 磁盘缓存
        需包涵 UIImageView+WebCache.h 头文件
    范例
        [self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://xxx.xxx.jpg&quot;] placeholderImage:nil options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) {

        } completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {
        }];

下载图片(缓存)
    说明
        默认方法内部会对图片做 内存缓存 + 磁盘缓存
        缓存方案可通过options参数修改
        需包涵 SDWebImageManager.h 头文件
    范例
        [[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:@&quot;http://xxx.xxx.jpg&quot;] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) {
        } completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
        }];

下载图片(不做缓存)
    说明
        不做缓存，单纯下载图片
        completed 中的Block是在子线程中处理的
        需包涵 SDWebImageDownloader.h 头文件
    范例
        [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:@&quot;http://xxx.xxx.jpg&quot;] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) {
        } completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) {
        }];

播放GIF图片
    说明
        需要引入 UIImage+GIF.h 头文件
        图片名不需要gif后缀
    范例
        UIImage *image = [UIImage sd_animatedGIFNamed:@&quot;imageName&quot;];

清空缓存
    cleanDisk
        说明
            清除过期缓存，过期时间默认7天
            计算当前缓存大小，和设置的最大缓存比较，如果操作会继续删除
            删除按照文件创建的删除顺序
        范例
            [[SDWebImageManager sharedManager].imageCache cleanDisk];
    clearDisk
        说明
            直接删除缓存目录下的文件，然后重新创建缓存文件夹
        范例
            [[SDWebImageManager sharedManager].imageCache clearDisk];

取消当前所有操作
    说明
        可在内存警告时使用
    范例
        [[SDWebImageManager sharedManager] cancelAll];
</code></pre><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><pre><code>图片下载框架
    [SDWebImage][https://github.com/rs/SDWebImage]
文件压缩解压框架
    [ZipArchive][https://github.com/ZipArchive/ZipArchive]
HTTP请求框架
    [AFNetworking][https://github.com/AFNetworking/AFNetworking]
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/03/frp-内网穿透/" itemprop="url">
                  frp-内网穿透
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-03T15:47:52+08:00" content="2016-11-03">
              2016-11-03
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>最近电信分配的IP变成了内网IP，导致之前在家里树莓派上开放的服务在外网无法连接。偶然看到frp项目，配置和使用非常简单，只需要一个外网的vps作为代理即可。虽然这样绕了一大圈速度比之前慢了很多，总算可以使用。</p>
<h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><pre><code>[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)
[下载地址](https://github.com/fatedier/frp/releases)
</code></pre><h2 id="外网安装"><a href="#外网安装" class="headerlink" title="外网安装"></a>外网安装</h2><pre><code>下载
    wget .../frp_0.8.1_linux_amd64.tar.gz

解压
    tar -zxvf frp_0.8.1_linux_amd64.tar.gz

移动到/usr/local/
    mv frp_0.8.1_linux_amd64/ /usr/local/opt/frp 

编辑 frps.ini
    [common]
    bind_port = 7000
    dashboard_port = 7500
    log_file = /var/log/frps.log
    log_level = info
    log_max_days = 3
    [ssh]
    listen_port = 6000
    auth_token = 123

创建systemd service
    vi /etc/systemd/system/frps.service

配置文件内容
    [Unit]
    Description=Start or stop the frps
    After=network.target
    Wants=network.target
    [Service]
    ExecStart=/usr/local/opt/frp/frps -c /usr/local/opt/frp/frps.ini
    Restart=1
    [Install]
    WantedBy=multi-user.target

启动并设置开机启动
    systemctl enable frps
    systemctl start frps

备注
    frps.service的目的是通过systemd管理服务，如开机启动，进程关闭自动重启等。
    如果遇到无法启动，可查看/var/log/frps.log文件的输出内容，如端口占用等。
    配置文件和启动文件依个人习惯也可分别移动到/etc/和/usr/local/bin/目录。
</code></pre><h2 id="内网机器配置"><a href="#内网机器配置" class="headerlink" title="内网机器配置"></a>内网机器配置</h2><pre><code>下载
    wget .../frp_0.8.1_linux_amd64.tar.gz

解压
    tar -zxvf frp_0.8.1_linux_amd64.tar.gz

移动到/usr/local/
    mv frp_0.8.1_linux_amd64/ /usr/local/opt/frp 

编辑 frpc.ini
    [common]
    server_addr = x.x.x.x
    server_port = 7000
    log_file = /var/log/frpc.log
    log_level = info
    log_max_days = 3
    auth_token = 123
    [ssh]
    local_port = 22

创建systemd service
    vi /etc/systemd/system/frpc.service

配置文件内容
    [Unit]
    Description=Start or stop the frps
    After=network.target
    Wants=network.target
    [Service]
    ExecStart=/usr/local/opt/frp/frpc -c /usr/local/opt/frp/frpc.ini
    Restart=1
    [Install]
    WantedBy=multi-user.target

启动并设置开机启动
    systemctl enable frpc
    systemctl start frpc
</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>SSH通过外网主机连接到内网主机
    ssh root@xx.xx.xx.xx -p 6000

查看内网主机日志
    tail -f /var/log/frpc.log

查看外网主机日志
    tail -f /var/log/frps.log

查看内网服务状态
    systemctl status frpc

查看外网服务状态
    systemctl status frps
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/iOS-UI框架-笔记/" itemprop="url">
                  iOS-UI框架-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-21T11:47:52+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><pre><code>相关框架
    UIKit             创建管和管理应用程序的用户界面
    QUartzCore        提供动画特效以及通过硬件进行渲染的能力
    CoreGraphics      提供2D绘制的基于C的API
    CoreLocation      使用GPS和WIFI获取位置信息
    MapKit            为应用程序提供内嵌地图的接口
    AVFoundation      音频处理

Xcode中创建项目时字段说明
    Product Name              产品名称
    Organization Name         公司名称
    Organization Identifier   公司唯一标示，通常为域名的反写，如 com.uiideas
    Bundle Identifier         产品唯一标识符，自动生成（公司唯一标识符＋产品名称）
    Language                  使用的语言，包含OC和Swift
    Devices                   设备，Universal指通用
    Use Core Data             封装了SQLite数据库
    Include Unit Tests        包含单元测试工具
    Include UI Tests          包含UI测试工具

模拟器操作
    回到首页
        Command + Shift + H
    切换物理和模拟键盘
        Command + Shift + K
    缩放模拟器
        Command + 1,2,3,4,5
    说放手势
        按住option键可开启多指缩放，同时按住shift键可移动手指位置

MVC
    UIView  
        界面由UIView组成，每一个控件都是一个UIView
    UIViewController
        负责创建，显示，销毁UIView，负责监听UIView的事件
        内部有个UIView属性，是它所负责的UIView对象

程序启动流程
    1.加载一个storyboard（在Main interface中指定）
    2.加载箭头指向的Controller
    3.加载Controller中的View展示给用户

IB(Interface Builder)
    IBAction
        从返回值角度上看，相当于void
        只有返回值声明为IBAction的方法，才能和storyboard中的控件进行连线
    IBOutlet
        只有声明为IBOutlet的属性，才能和storyboard中的控件进行连线
</code></pre><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><pre><code>概述
    每一个控件启示都是一个容器
        可以将其它控件放到该控件的内部
        比较常见的还是将UIView作为容器
    可以将A控件放入B控件
        A控件是B控件的子控件
        B控件是A控件的父控件
    每一个控制器都有一个UIView
        控制器本身是不可见的
        能够看到的是控制器的View
        每一个控制器都有一个UIView属性
        控制器中管理的所有子控件都是该控件的子控件

常见控件
    UIImageView           图片显示控件
    UISlider              滑块
    UIProgressView        进度条
    UIButton              按钮
    UILable               文本标签
    UITextField           文本输入框
    UITextView            多行可滚动的输入框
    UISwitch              开关
    UIDatePicker          日期控件
    UIPickerView          选择器控件
    UIScollView           滑动控件
    UIPageControl         分页控件
    UITableView           表格
    UICollectionView      九宫格
    UIWebView             网页显示控件
    UItoolbar             工具条
    UISegmentControl      选项卡
    UIActivityIndicator   转圈圈
    UIAlertView           Alert弹框（ios8弃用）
    UIActionSheet         底部弹框

UIView
    说明
        所有UI控件都继承自UIView。
        UI控件的共有属性都定义在UIView中，如frame，center
    常见属性
        superview   父控件
        subviews    子控件数组，顺序
        tag         每个控件的标识，可通过tag查找子控件，不同的空间tag可相同
        transform   控件形变属性（可设置旋转角度，比例缩放，平移等）
        frame       控件所在矩形框在父控件中的位置和尺寸（父控件左上角为原点）
        bounds      控件所在矩形框的位置和尺寸（以自己左上角为原点，通常xy为0）
        center      控件中心点的位置（父控件左上角为原点）
    常见方法
        addSubview            添加子控件
        removeFromSuperview   把自己从父控件中移除
        viewWithTag           根据tag找出对应的控件（一般是子控件）

UIlabel
    常见属性
        text              显示的文字
        font              字体
        textColor         文字颜色
        textAlignment     对齐方式
        numbersOfLines    文字行数
        lineBreakMode     换行模式

UIImageView
    加载图片
        两种方式
            imageName
                指向它的指针被销毁，该资源不会从内存中干掉
            imageWithContentOfFile
                指向它的指针被销毁，该资源会从内存中干掉
        Assets.xcasset中的图片
            打包后成为Assets.car
            无法拿到路径
            只能通过imageName方式加载
            无法通过imageWithContentOfFile方式获取图片
            图片默认有缓存，通常放置经常使用的资源
        放置项目目录下
            可以通过NSBundle获取路径
            可以通过imageName方式获取图片
            也可以通过imageWithContentOfFile方式获取图片
            图片无缓存，通常放置不经常用的图片和占用空间较大的资源
    图片拉伸
        resizableImageWithCapInsets
            说明
                对象方法，需要指定上下左右保护区域的大小
                返回一个四周区域收保护的图片
        stretchableImageWithLeftCapWidth
            说明
                对象方法，需要指定上面和左边受保护区域的大小
                右边和下边制动根据左边和上边减1
                返回一个指定区域受到保护的图片

UIButton
    说明
        按钮，既能显示文字，也可以显示图片
    按钮状态
        normal        默认状态
        highlighted   高亮状态，当手按上去还没有抬起时的状态
        disable       失效状态
    修改按钮内图片和文字位置
        方法一
            //新建继承UIButton的类，重写如下两个方法
            #import &quot;customButton.h&quot;
            @implementation customButton
            -(CGRect)titleRectForContentRect:(CGRect)contentRect{
                return CGRectMake(0, 0, 40, 40);
            }
            -(CGRect)imageRectForContentRect:(CGRect)contentRect{
                return CGRectMake(0, 50, 40, 40);
            }
            @end
        方式二
            //重写layoutSubviews方法
            #import &quot;customButton.h&quot;
            @implementation customButton
            -(void)layoutSubviews{
                [super layoutSubviews];
                self.titleLabel.frame = CGRectMake(0, 0, 100, 40);
                self.imageView.frame = CGRectMake(100, 0, 40, 40);
            }
            @end
    设置内边距
        button.imageEdgeInsets     设置图片内边距
        button.contentEdgeInsets   设置内容内边距
        button.titleEdgeInsets     设置文字内边距

Xib &amp; storyboard
    对比
        共同点
            都用来描述软件界面
            都用Interface Builder工具来编辑
            本质都是转换成代码去创建控件
        不同点
            Xib是轻量级的,用来描述局部的UI界面
            Storyboard是重量级的,用来描述整个软件的多个界面,并可展示多个界面之间的跳 转关系
    Xib的加载
        说明
            xib的包文件扩展名nib，可用Nib的方式加载
            xib的加载后返回一个数组，因为xib内可能有多个文件
            当xib和class关联后，可把加载xib的逻辑放在view中
        View从xib中加载注意
            xib无法通过 alloc init 和 initWithFrame 的方式创建
            不会调用init和initWithFrame方法
            如果子控件是从xib中创建的，是处于未唤醒状态
            在view中用代码添加子控件，需在initWithCoder和awakeFromNib中创建
        方法一
            NSArray *views = [[NSBundle mainBundle] loadNibNamed:@&quot;xib文件名&quot; owner:nil options:nil]
        方法二
            UINib *nib = [UINib nibWithNibName:@&quot;xib文件名&quot; bundle:nil]; NSArray *views = [nib instantiateWithOwner:nil options:nil];
    相关方法
        awakeFromNib    当xib被加载时调用，在XXXView.m文件中有效

渐变动画
    方式一
        [UIView beginAnimations:nil context:nil];
        [UIView setAnimationDuration:1.0];
        //动画相关代码
        [UIView commitAnimations];
    方式二
        [UIView animateWithDuration:2.0 animations:^{
            //code
        }];
    方式三
        [UIView animateWithDuration:(NSTimeInterval) animations:^{
            //code
        } completion:^(BOOL finished) {
            //code
        }];
    方式四
        [UIView animateWithDuration:(NSTimeInterval) delay:(NSTimeInterval) options:(UIViewAnimationOptions) animations:^{
            //code
        } completion:^(BOOL finished) {
            //code
        }]

UIScrollView
    说明
        一个能够滚动的视图控件，可以用来展示大量内容，可通过滚动查看所有内容
        超出UIScrollView的内容会被隐藏
        UIScrollView的subviews中出了内容还包含两个滚动条的UIImageView
    常见属性
        contentSize                 滚动区域的范围
        contentOffset               内容显示的偏移量
        contentInset                内容的内边距，设置后默认偏移量不包含内边距
        scrollEnabled               是否可滚动，默认YES
        userInteractionEnabled      是否与用户交互相应用户操作，默认YES
        bounces                     滚动到边界的弹簧效果，默认YES
        alwaysBounceVertical        无论内容区域大小，强制垂直方向弹簧效果，默认NO
        alwaysBounceHorizontal      无论内容区域大小，强制水平方向弹簧效果，默认NO
        pagingEnabled               开启分页功能，以UIScrollView的宽度为分页标准
        showsHorizontalScrollIndicator  显示水平滚动条，默认YES
        showsVerticalScrollIndicator    显示垂直滚动条，默认YES
    代理（delegate）
        说明
            当UIScrollView发生滚动时，会自动通知它的delegate对象，给代理发送消息
            如果想要监听UIScrollView的滚动操作，需先给UIScrollView设置个代理对象
            通过代理获取UIScrollView的滚动过程
            代理对象需遵守UIScrollViewDelegate协议
            当发生特定操作时，会调用delegate对象的特定方法
        步骤
            1.通过UIScrollView的delegate属性指定代理对象
            2.代理对象遵守UIScrollViewDelegate协议（可在类扩展中遵守）
            3.在代理对象中设置特定行为事件对应的代理方法
        注意
            任何OC都可作为UIScrollView的代理，一般是控制器
            当指定的代理对象是一个新独立文件的类时，需在.h中遵守协议
            UIScrollView对代理对象的引用为弱引用，指定的代理对象需被强引用
        常见代理方法
            scrollViewDidScroll                   滚动时调用
            scrollViewDidZoom                     缩放时调用
            scrollViewWillBeginDragging           即将开始拖拽时调用
            scrollViewWillEndDragging             即将结束拖拽时调用
            scrollViewDidEndDragging              停止拖拽时调用
            scrollViewWillBeginDecelerating       开始减速时候调用
            scrollViewDidEndDecelerating          减速完毕停止滚动时调用
    常见控件事件监听
        当控件继承自UIControl，可通过addTarget监听事件
        点击控制器的view时系统会自动调用控制器的touchesBegan方法
    内容缩放
        设置viewForZoomingInScrollView代理方法，返回需要缩放的UIView
        设置UIScrollView的maximumZoomScale或minimumZoomScale属性设置说放比例

UIPageControl
    说明
        提供分页功能
    属性
        pageIndicatorTintColor           圆点的颜色
        currentPageIndicatorTintColor    当前页的圆点颜色
        numberOfPages                    一共的页码
        currentPage                      当前页码
        hidesForSinglePage               当页面只有一页时隐藏
    设置图标
        通过KVC设置current和other两个属性

UITableView
    说明
        表格控件，继承至UIScrollView。
        UITableView的每一行都是一个UITableViewCell。
        代理需遵守UITableViewDelegate协议
    UITableView样式
        UITableViewStylePlain           每个cell紧密贴在一起，滑动时标题固定顶部
        UITableViewStyleGrouped         每个分组间有间距
    dataSource
        UITableView的数据源,指定后通过协议方法定义显示的内容
        作为dataSource的对象需遵守UITableViewDataSource协议
    常见属性
        rowHeight                      行高，默认44
        sectionFooterHeight            每一组的头部高度
        sectionFooterHeight            每一组的尾部高度
        sectionIndexColor              索引条文字颜色
        sectionIndexBackgroundColor    索引条背景颜色
        estimatedRowHeight             设置估算高度
        editing                        编辑模式，cell左滑后editing值为YES
        indexPathsForSelectedRows      当前用户选中的cell的索引 
        allowsMultipleSelectionDuringEditing  编辑模式下可以多选
    方法
        reloadData                     刷新列表，重新调用数据源方法
        reloadRowsAtIndexPaths         刷新列表中局部数据（必须保证数组个数不变）
        insertRowsAtIndexPaths         插入一条cell
        deleteRowsAtIndexPaths         删除一条cell
        setEditing                     修改编辑模式，另有带动画的设置方法
    dataSource协议方法
        numberOfSectionsInTableView    共有多少个数据组，不实现默认1组
        numberOfRowsInSection          设置每个组有多少行数据
        cellForRowAtIndexPath          设置每一行的数据
        titleForHeaderInSection        每组的头部标题
        titleForFooterInSection        每组的尾部标题
        separatorColor                 分割线颜色
        separatorStyle                 分割线样式
        tableHeaderView                整张表的头部控件
        tableFooterView                整张表的尾部控件
        sectionIndexTitlesForTableView 显示索引条
    代理方法
        didSelectRowAtIndexPath        选中某一行调用的方法
        didDeselectRowAtIndexPath      取消选中某一行调用的方法
        heightForHeaderInSection       可设置不同的组不同头部高度  
        heightForFooterInSection       可设置不同的组不同尾部高度
        heightForRowAtIndexPath        可设置每个cell不同的行高
        viewForHeaderInSection         返回每组的尾部控件
        viewForFooterInSection         返回每组的头部控件
        commitEditingStyle             增加左滑删除功能
        editActionsForRowAtIndexPath   增加多按钮的左滑功能
        titleForDeleteConfirmationButtonForRowAtIndexPath 修改左滑动删除文字
    性能优化
        取消表格中没有数据行的分割线，两种方式:
            1. 修改表格样式为UITableViewStyleGrouped
            2. tableView.tableFooterView = [[UIView alloc]init];
        cell懒加载
            苹果的方式
                每当一个cell即将进入视野范围内，才调用方法创建cell
                当一个cell离开视野后，再次进入视野时，会重新创建cell
                这样会频繁的创建和销毁cell，分配内存很耗性能
            优化思路
                当存在dequeueReusableCellWithIdentifier时，
                离开视野的cell，系统会自动放入缓存池中。
                当缓存池内的cell在此进入视野内，直接从缓存池读取而不重新创建
            范例
                -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
                    static NSString *ID = @&quot;idname&quot;;
                    //去缓存池中取是否有指定标识的cell
                    UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:ID];
                    if(cell == nil){
                        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
                        //TODO 写入不同的cell都相同的设置
                    }
                    //TODO 写入不同的cell不同的设置
                    cell.textLabel.text = @&quot;测试&quot;;
                    return cell;
        缓存池注册class的另外两个方法
            [self.tableView registerClass:[CustomCell class] forCellReuseIdentifier:ID];
            [self.tableView registerNib:[UINib nibWithNibName:NSStringFromClass([CustomCell class]) bundle:nil] forCellReuseIdentifier:ID];
        可变高度Cell（Self Sizing Cells）
            // 告诉tableView所有cell的真实高度是自动计算的(根据设置的约束)
            self.tableView.rowHeight = UITableViewAutomaticDimension;
            // 设置估算高度，和上面代码结合使用会开启IOS8之后的Self Sizing Cells
            self.tableView.estimatedRowHeight = 44;
        heightForRowAtIndexPath调用次数
            系统展示tableView时需计算contentSize的和滚动条的大小。
            此时会多次调用heightForRowAtIndexPath代理方法。
            设置估算高度estimatedRowHeight来优化性能。
            减少heightForRowAtIndexPath的调用

UITableViewCell
    说明
        UITableView的每一行都是一个UITableViewCell。
        Cellyou两种类型，Dynamic和Static。
        Dynamic为显示数量和内容依照数据源来决定的。
        Static的数量和内容是在storyboard中固定的。
    样式
        UITableViewCellStyleDefault    默认样式，没有描述
        UITableViewCellStyleValue1     描述在下面
        UITableViewCellStyleValue2     描述在右边
        UITableViewCellStyleSubtitle   描述较大，没有图片
    常见属性
        imageView                      contentView的子控件，左侧的图片
        textLabel                      contentView的子控件，文字
        detailTextLabel                contentView的子控件，描述
        contentView                    UITableViewCell的子控件
        accessoryType                  cell右边图标样式
        accessoryView                  可自定义右边显示的控件
        selectionStyle                 选中时的样式
        selectedBackgroundView         设置选中时的背景View
        backgroundColor                背景颜色
        backgroundView                 可给背景设置控件

UITextView
    说明
        文本输入框控件
        代理需遵守UITextFieldDelegate协议
    代理方法
        textViewShouldBeginEditing          是否允许开始编辑
        textViewShouldEndEditing            是否允许结束编辑
        textViewDidBeginEditing             开始编辑时调用
        textViewDidEndEditing               结束编辑时调用
        shouldChangeTextInRange             是否允许改变文本框内容

UIPickView
    说明
        滑动选择控件
        数据源需遵守UIPickerViewDataSource协议
        代理需遵守UIPickerViewDelegate协议
    常见方法
        selectRow                         选中指定的列和行
        reloadComponent                   刷新指定的列
        selectedRowInComponent            返回指定的列选中的行
    协议方法
        numberOfComponentsInPickerView    返回列数
        numberOfRowsInComponent           返回没一列的行数
    代理方法
        widthForComponent                 返回每一列的宽度
        rowHeightForComponent             每一列的高度
        titleForRow                       设置每一行的内容
        attributedTitleForRow             设置每一条数据的大小颜色阴影描边
        viewForRow                        设置每条数据显示的view
        didSelectRow                      当前选中的列和行

UIWebView
    说明
        UIWebView是iOS内置的浏览器控件
        系统自带的Safari浏览器就是通过UIWebView实现的
        UIWebView不但可以加载网页，还能加载多数常见文件
        使用代理方法需遵守UIWebViewDelegate协议
    对象方法
        loadRequest                   加载资源
        reload                        重新加载(刷新)
        stopLoading                   停止加载
        goBack                        后退
        goForward                     前进
        scalesPageToFit               是否对网页进行自动缩放
        dataDetectorTypes             数据自动识别，包括电话号码,URL,地址等
        canGoBack                     是否可以后退
        canGoForward                  是否可以前进
    代理方法
        shouldStartLoadWithRequest    即将开始加载request时调用
        webViewDidStartLoad           开始加载网页时调用
        webViewDidFinishLoad          网页加载完成时调用
        didFailLoadWithError          网页加载失败时调用
    范例
        加载网页
            //初始化webView
            NSURL *url = [NSURL URLWithString:@&quot;https://m.taobao.com/#index&quot;];
            NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
            [self.webView loadRequest:request];
            //设置边距
            self.webView.scrollView.contentInset = UIEdgeInsetsMake(20, 20, 20, 20);
        加载本地文件
            NSURL *url = [NSURL fileURLWithPath:@&quot;/user/xxx/xxx&quot;];
            [self.webView loadRequest:[NSURLRequest requestWithURL:url]];
</code></pre><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><pre><code>多控制器
    说明
        一个iOS的app很少只有一个控制器组成，除非这个App非常简单
        当App有多个控制器时，我们需要对这些控制器进行管理
        可以用1个控制器去管理多个控制器
        为了便于管理控制器，iOS提供了两个比较特殊的控制器:
        UINavigationController 和 UITabBarController

UINavigationController
    说明
        导航控制器
        利用UINavigationController可轻松管理多个控制器
        轻松完成多个控制器的切换，如系统自带的 &quot;设置&quot;
        创建控制器时包含了：导航条，栈定控制器的view
    使用步骤
        初始化UINavigationController
        设置UIWindow的rootViewController为UINavigationController
        根据具体情况，通过push方法添加对应个数的子控制器
    属性
        viewControllers                  子控制器的数组
        childViewControllers             子控制器的数组（只读）
    方法
        pushViewController               添加子控制器至栈中
        popViewControllerAnimated        将栈顶的控制器移除
        popToViewController              回到指定的控制器
        popToRootViewControllerAnimated  回到根控制器
        appearance                       获取导航条标识
    栈顶控制器(当前显示的控制器)
        navigationItem属性
            backBarButtonItem       左上角的返回按钮
            titleView               中间的标题视图
            title                   中间的标题文字
            eftBarButtonItem        左上角的视图
            rightBarButtonItem      右上角的视图
        范例
            设置标题
                self.navigationItem.title = @&quot;设置标题&quot;;
            设置标题试图
                self.navigationItem.titleView = [UIButton buttonWithType:UIButtonTypeInfoDark];
            设置左侧按钮
                self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;左按钮&quot; style:0 target:self action:@selector(leftButton)];

UITabBarController
    说明
        标签控制器。
        控制器中在底部有一个UITabBar导航条。
        有多少个子控制器，UITabBar中就有多少个UITabBarButton。
        UITabBarController可以轻松管理多个控制器。
        添加的多个控制器对平分屏幕底下的UITabBar导航条。
        当前选中的控制器的tabBarItem属性可设置UITabBarButton显示内容
    使用步骤
        初始化UITabBarController
        设置UIWindow的rootViewController为UITabBarController
        根据具体情况，通过addChildViewController方法添加对应个数的子控制器
    常见属性
        viewControllers                  子控制器的数组
        childViewControllers             子控制器的数组（只读）
        selectedIndex                    通过索引指定选中显示的子控制器
    常见方法
        addChildViewController           添加子控制器
    当前控制器设置UITabBarButton
        vc.tabBarItem.title              设置标题
        vc.tabBarItem.badgeValue         设置提示数字
        vc.tabBarItem.image              设置图片

Controller生命周期
    viewDidLoad                 当控制器加载完毕时调用
    viewWillAppear              当控制器View即将显示时调用
    viewDidAppear               当控制器View显示完毕时调用
    viewWillLayoutSubviews      当控制器View将要布局子控件时调用
    viewDidLayoutSubviews       当控制器View布局子控件完毕时调用
    viewWillDisappear           当控制器View即将消失时调用
    viewDidDisappear            当控制器View消失完毕时调用

UITableViewController
    说明
        继承自UIViewController。
        内部引用了一个UITableView。
        内部view属性和tableView属性指向同一个UITableView。
        遵守了UITableViewDelegate和UITableViewDataSource协议
        内部UITableView的dataSource和delegate指向当前UITableViewController
    属性
        automaticallyAdjustsScrollViewInsets   是否自动设置偏移量

UIAlertController
    说明
        弹出框
    弹框样式
        UIAlertControllerStyleActionSheet     屏幕底部上拉弹出样式
        UIAlertControllerStyleAlert           弹框样式
    按钮样式
        UIAlertActionStyleDefault             默认样式(蓝色)
        UIAlertActionStyleCancel              取消样式(蓝色,单独显示)
        UIAlertActionStyleDestructive         危险操作(红色)
    使用步骤
        1. 创建控制器（指定样式和标题）
        2. 创建按钮
        3. 添加按钮
        4. 显示弹框
    范例
        //创建控制器
        UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;确定要退出嘛？&quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];
        //创建按钮
        UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
            NSLog(@&quot;点击了取消&quot;);
        }];
        UIAlertAction *confirmAction = [UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) {
            NSLog(@&quot;点击了确认&quot;);
        }];
        //添加按钮
        [alertVC addAction:confirmAction];
        [alertVC addAction:cancelAction];
        //显示弹框
        [self presentViewController:alertVC animated:YES completion:nil];
</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code>响应者对象
    在iOS中不是任何对象都能处理事件。
    只有继承了UIReaponder的对象才能接受并处理事件，我们称之为响应者对象。
    UIApplication,UIViewController,UIView都继承自UIReaponder。

触摸事件 (Multitouch Event)
    UITouch
        说明
            当用户一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象。
            一个手指对应一个UITouch对象。
            UITouch保存着喝手指相关的信息，比如触摸的位置，时间，阶段。
            当手指移动时，系统会更新同一个UITouch对象。
        属性
            window                     触摸产生时的窗口
            view                       触摸产生时所在的视图
            tapCount                   短时间内触摸的次数
            timestamp                  触摸事件的时间，单位是秒
            phase                      触摸事件的状态
        方法
            locationInView             触摸的位置
            previousLocationInView     上一个触摸点的位置
    UIEvent
        说明
            UIEvent称为事件对象，记录产生事件的时间和类型
            每一个事件都会产生一个UIEvent对象
        属性
            type                       事件类型
            subtype
            timestamp                  事件产生的时间
    事件传递
        说明
            事件对列为堆的结构
            触摸事件的传递是从父控件传递至子控件的。
        事件处理过程
            当发生触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中
            UIApplication会从事件队列中取出最前面的事件，并将事件分发下去处理。
            通常先发送事件给应用程序的主窗口(Window)
            主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。
            找到合适的视图控件后，就会调用视图控件的touches方法来做具体的事件处理。
            如果touches方法未实现，事件会顺着响应者链条向上传递
        响应者链条
            是由多个响应者对象链接起来的链条
            作用是能清楚的看见每个响应者之间的关系，并且让一个事件多个处理对象
            如果当前view是控制器的view，那么他的上一个响应者是控制器
            如果当前view不是控制器的view，那么他的上一个响应者是父控件
            Window的上一个响应者是Application
        无法接受事件
            说明
                如果父控件不能接受事件，则子控件不能接受事件。
                UIImageView默认userInteractionEnabled为NO，无法接受事件。
                如果子控件无法接受事件。则父控件相应事件
                当一个控件隐藏时，它的子控件也随之隐藏。
                当一个控件透明时，它的子控件也随之透明。
            三种情况
                userInteractionEnabled = NO;     不接收用户交互
                hidden = YES;                    隐藏
                alpha = 0.0 ~ 0.01               透明
        hitTest
            系统调用hitTest方法用来寻找最适合的view。
            当一个事件传递给当前view时调用。
            可重写此方法来直接指定相应事件的view。
        pointInside
            系统调用用来判断当前点是否在当前View上面
            是在系统调用hitTest方法中调用的
            point点必须要和它方法调用者在同一个坐标系里面
    事件方法（系统自动调用）
        touchesBegan                   开始触摸
        touchesMoved                   触摸时移动
        touchesEnded                   结束触摸
        touchesCancelled               触摸时被其他系统事件打断(如电话,关机)
    UIGeStureRecognizer
        说明
            要完成手势识别，必须借助手势识别器-UIGeStureRecognizer
            利用UIGeStureRecognizer，能轻松识别用户在某个View上面的常见手势
            UIGeStureRecognizer是一个抽象类，定义了所有手势的基本行为。
            使用UIGeStureRecognizer的子类才可以处理具体的手势
            可设置代理，需遵守UIGestureRecognizerDelegate协议
        子类
            UITapGestureRecognizer             tap手势
            UIPinchGestureRecognizer           捏合，用于缩放
            UIPanGestureRecognizer             拖拽
            UISwipeGestureRecognizer           轻扫
            UIRotationGestureRecognizer        旋转
            UILongPressGestureRecognizer       长按（移动时会持续调用方法）
        代理方法
            shouldReceiveTouch                 是否允许接受手指
            shouldRecognizeSimultaneouslyWithGestureRecognizer  是否允许同时支持多个手势
        范例
            - (void)viewDidLoad {
                [super viewDidLoad];
                //创建手势识别器
                UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tap:)];
                //添加手势
                [self.image addGestureRecognizer:tap];
            }
            //实现手势方法
            -(void)tap:(UITapGestureRecognizer *)tap{
                NSLog(@&quot;%s&quot;,__func__);
            }
加速计事件 (Accelerometer Event)
远程控制事件 (Remote Control Event)
</code></pre><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><pre><code>Quartz2D
    说明
        Quartz2D是一个二维绘图引擎，同时支持iOS和Mac系统
        可用于绘制图形，剪切图片，制作报表等
    功能
        绘制图形: 线条\三角形\矩形\圆\弧
        绘制文字
        绘制\生成图片
        读取\生成PDF
        截图\裁剪图片
        自定义UI控件
    图形上下文
        说明
            图形上下文(Graphies Context): 是一个CGContextRef类型的数据
            相同的一套绘图序列，指定不同的上下文，可将相同的图像绘制到不同的目标
        作用
            可以保存绘图信息和绘图状态
            决定绘制的输出目标(绘制到什么地方去)
        类型
            Bitmap Graphies Context
            PDF Graphies Context
            Window Graphies Context
            Layer Graphies Context
            Printer Graphies Context
        图片上下文
            图片上下文需要手动开启
            开启的上下文的大小就是生成图片的大小
            手动开启的上下文需要手动关闭
            生成图片的代码不需要写在drawRect中，可写在任何地方
    自定义view步骤
        新建一个类，继承自UIView
        实现 drawRect 方法，这个方法内已自动创建个和当前view相关联的上下文
        获取上下文
        绘制相应的图形内容
        利用图形上下文将绘制的所有内容渲染显示到view上面
    UIGraphics方法
        UIGraphicsGetCurrentContext                获取上下文
        UIGraphicsBeginImageContext                开启图片上下文
        UIGraphicsEndImageContext                  关闭图片上下文
        UIGraphicsGetImageFromCurrentImageContext  从当前上下文生成图片
    CGContext方法
        CGContextAddPath                      把绘制的路径添加到上下文
        CGContextSetLineWidth                 设置线宽
        CGContextSetLineJoin                  设置线的链接方式
        CGContextSetLineCap                   设置线的顶端样式
        CGContextFillPath                     填充
        CGContextStrokePath                   描边
        CGContextSaveGState                   将当前状态保存自上下文状态栈
        CGContextRestoreGState                从上下文状态栈中取出状态
        CGContextTranslateCTM                 对上下文路径平移
        CGContextRotateCTM                    对上下文路径旋转
        CGContextScaleCTM                     对上下文路径缩放
        CGContextClearRect                    擦除上下文中指定区域
    其他方法
        setNeedsDisplay                       重新绘制，当前view的方法
        renderInContext                       layer的方法，把内容渲染至上下文
    UIBezierPath
        对象方法
            fill                              填充(自动获取上下文)
            stroke                            描边(自动获取上下文)
            closePath                         关闭路径(用线连接终点和起点)
            sffClip                           设置裁剪区域，超出路径范围外的被裁减
            removeAllPoints                   删除路径上所有的点
        类方法
            addQuadCurveToPoint               绘制直线和曲线
            bezierPathWithRect                绘制矩形
            bezierPathWithRoundedRect         绘制圆角矩形
            bezierPathWithArcCenter           绘制弧
        属性
            lineWidth                         线宽
    UIKit绘图
        String对象方法
            drawAtPoint                       在指定的起点绘制文字
            drawInRect                        在指定的rect内绘制文字
        UIImage对象方法
            drawAtPoint                       在指定坐标点绘制图片(原始大小)
            drawInRect                        把图片绘制到指定的区域内（缩放）
            drawAsPatternInRect               以平铺的方式在指定的区域绘图
        其他方法
            UIRectClip                        对指定区域裁剪
            UIRectFill                        对指定区域填充
    图片生成文件
        UIImageJPEGRepresentation             把图片生成JPGE文件，可指定压缩
        UIImagePNGRepresentation              把图片生成PNG文件
    范例
        绘制直线
            - (void)drawRect:(CGRect)rect {
                //获取上下文
                CGContextRef ctx = UIGraphicsGetCurrentContext();
                //创建路径
                UIBezierPath *path = [UIBezierPath bezierPath];
                //设置起点
                [path moveToPoint:CGPointMake(100, 50)];
                //添加一根线到终点
                [path addLineToPoint:CGPointMake(250, 250)];
                //以上次终点为起点绘制第二条线
                [path addLineToPoint:CGPointMake(50, 150)];
                //设置颜色
                [[UIColor redColor] set];
                //设置线宽
                CGContextSetLineWidth(ctx, 10.0);
                //设置线的链接方式为圆角
                CGContextSetLineJoin(ctx, kCGLineJoinRound);
                //设置线的顶端样式为圆角
                CGContextSetLineCap(ctx, kCGLineCapRound);
                //把绘制的路径保存到上下文
                CGContextAddPath(ctx, path.CGPath);
                //把上下文内容显示到View上
                CGContextStrokePath(ctx);
            }
        绘制曲线
            - (void)drawRect:(CGRect)rect {
                //获取上下文
                CGContextRef ctx = UIGraphicsGetCurrentContext();
                //创建路径
                UIBezierPath *path = [UIBezierPath bezierPath];
                //设置起点
                [path moveToPoint:CGPointMake(100, 50)];
                //添加一根曲线到终点
                [path addQuadCurveToPoint:CGPointMake(250, 250) controlPoint:CGPointMake(50, 250)];
                //设置线宽
                CGContextSetLineWidth(ctx, 5.0);
                //把绘制的路径保存到上下文
                CGContextAddPath(ctx, path.CGPath);
                //把上下文内容显示到View上
                CGContextStrokePath(ctx);
            }
        绘制矩形
            - (void)drawRect:(CGRect)rect {
                //获取上下文
                CGContextRef ctx = UIGraphicsGetCurrentContext();
                //设置颜色
                [[UIColor blueColor] set];
                //绘制矩形
                UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 200, 200)];
                //把绘制的路径保存到上下文
                CGContextAddPath(ctx, path.CGPath);
                //填充
                CGContextFillPath(ctx);
            }
        绘制圆角矩形
            - (void)drawRect:(CGRect)rect {
                //获取上下文
                CGContextRef ctx = UIGraphicsGetCurrentContext();
                //设置颜色
                [[UIColor blueColor] set];
                //绘制矩形
                UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(50, 50, 200, 200) cornerRadius:50];
                //把绘制的路径保存到上下文
                CGContextAddPath(ctx, path.CGPath);
                //填充
                CGContextFillPath(ctx);
            }
        绘制椭圆
            - (void)drawRect:(CGRect)rect {
                UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 50, 100, 200)];
                [path fill];
            }
        通过图片上下文给图片加水印
            //加载图片
            UIImage *image = [UIImage imageNamed:@&quot;黄人&quot;];
            //开启一个透明的图片上下文
            UIGraphicsBeginImageContextWithOptions(image.size, NO, 0.0);
            //绘制图片
            [image drawAtPoint:CGPointZero];
            //绘制文字
            NSString *str = @&quot;水印&quot;;
            [str drawAtPoint:CGPointMake(10, 20) withAttributes:nil];
            //从上下文中生成图片
            UIImage *newImg = UIGraphicsGetImageFromCurrentImageContext();
            //关闭上下文
            UIGraphicsEndImageContext();
            //给imageView赋值
            self.imageView = newImg;

CALayer
    说明
        UIView之所以能显示在屏幕上，完全是因为它内部的一个图层
        在创建UIView对象时，UIView内部都会自动创建一个图层（CALayer对象）
        通过UIView的layer属性可以访问这个层
        UIView需要显示到屏幕上时，会调用drawRect方法进行绘图，并将内容绘制在图层上
        绘图完成后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示
        UIView本身并不具备显示功能，是其内部的layer具有显示功能
        通过CALayer对象，可调整UIView的阴影，圆角，边框等功能
        UIView的图片会放置在它的layer的contents属性中
    CALayer和UIView的应用区别
        CALayer定义QuartzCore框架中
        CGImageRef和CGColorRef定义在CoreGraphies框架中
        UIColor和UIImage定制在UIKit框架中
        QuartzCore和CGColorRef支持跨平台，iOS 和 Mac OS X 上都可以使用
        UIKit只能使用在iOS中
        为了保证可移植性QuartzCore不能使用UIColor,只能使用CGColorRef等
    CALayer和UIView的选择
        通过CALayer可实现和UIView一样的界面效果
        UIView相比CALayer有事件处理功能。
        展示的内容如果需和用户交互使用UIView，否则两者皆可。
        相比UIView，CALayer的性能更好更加轻量。
        为了程序的扩展性，更推荐使用UIView。
    隐式动画
        系统对非根层属性修改时，默认产生的动画效果称为隐式动画。
        UIView内部默认关联的CALayer成为根层(Root Layer)。
        手动创建的CALayer对象称为非根层。非根层都存在隐式动画。
        会产生动画的属性称为 Animatable properties(可动画属性)。
        常见如: bounds, backgroundColor, position 等。
        可通过动画事务(CATransaction)关闭默认的隐式动画效果
    属性
        shadowColor                    阴影颜色
        shadowOpacity                  阴影不透明度
        shadowOffset                   阴影偏移
        shadowRadius                   设置阴影模糊半径
        borderWidth                    边框宽度，默认边框向内
        borderColor                    边框颜色
        cornerRadius                   设置圆角半径
        masksToBounds                  把超过根层之外的东西裁剪掉
        transform                      形变属性，类型为CATransform3D
        contents                       存档图片，类型为CGImage
        position                       设置CALayer在父层的位置
        anchorPoint                    定位点，决定层中那个点为position的位置
    范例
        自定义layer
            CALayer *layer = [CALayer layer];
            layer.backgroundColor = [UIColor blueColor].CGColor;
            layer.frame = CGRectMake(100, 200, 200, 200);
            [self.view.layer addSublayer:layer];
        取消非根层隐式动画
            [CATransaction setDisableActions:YES];
            self.layer.position = CGPointMake(300, 300);
        设置隐式动画时长
            [CATransaction setAnimationDuration:2.0];
            self.layer.position = CGPointMake(300, 300);

CAGradientLayer
    说明
        渐变层，继承来CALayer
    对象属性
        colors                    渐变颜色的数组
        locations                 渐变位置的数组，和colors对应
        startPoint                渐变起始点，可用来确定渐变方向
        endPoint                  渐变结束点，可用来确定渐变方向
        opacity                   不透明度
    范例
        CAGradientLayer *gradientL = [CAGradientLayer layer];
        gradientL.frame = self.view.bounds;
        gradientL.colors = @[(id)[UIColor grayColor].CGColor,(id)[UIColor redColor].CGColor];
        gradientL.startPoint = CGPointMake(0, 0.5);
        gradientL.endPoint = CGPointMake(1, 0.5);
        gradientL.locations = @[@0.3,@0.8];
        [self.view.layer addSublayer:gradientL];

CAReplicatorLayer
    说明
        复制层，可对其内部子层做复制
    对象属性
        instanceCount                 包括自己复制的分数
        instanceTransform             对复制的子层做形变
        instanceDelay                 复制出来的子层的动画延时执行时长
        instanceRedOffset             复制出来的子层的红色偏移
        instanceGreenOffset           复制出来的子层的绿色偏移
        instanceBlueOffset            复制出来的子层的蓝色偏移
        instanceAlphaOffset           复制出来的子层的Alpha偏移

CAShapeLayer
    说明
        形状图层，可根据指定的路径生成形状图层
    对象属性
        path                        生成形状路径
        fillColor                   形状填充颜色
</code></pre><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><pre><code>Core Animation
    说明
        Core Animation 是一组非常强大的处理动力动画的API。
        支持跨平台，可用在 Mac OS X 和 iOS 平台。
        动画执行过程是在后台操作，不会阻塞主线程。
        直接作用在CALayer上，并非UIView上。
    核心动画和UIView动画区别
        核心动画只作用在CALayer上
        核心动画看到的都是假象，不会修改UIView的真实位置
        当不需要与用户进行交互时使用核心动画
        当根据路径做动画时使用核心动画
        转场动画使用核心动画(转场类型较多)
    相关类说明
        CAAnimation               基类
        CAAnimationGroup          动画组，可以做一组动画
        CABasicAnimation          基础动画，单个值变更的动画
        CAKeyframeAnimation       多个值变更的动画
        CATransition              转场动画
    使用步骤
        1. 需要有CALayer
        2. 初始化上一个CAAnimation对象，并设置一些动画相关属性
        3. 通过调用CALayer的addAnimation方法，增加CAAnimation对象到CALayer
    对象属性
        keyPath                   需要设置动画的属性
        toValue                   属性变化的值
        values                    CAKeyframe的属性变化的值的数组
        path                      CAKeyframe的动画路径
        type                      CATransition的动画效果类型
        startProgress             设置CATransition动画的开始位置
        endProgress               设置CATransition动画的结束位置
        repeatCount               动画重复的次数
        duration                  动画的时长
        autoreverses              动画自动反转
        removedOnCompletion       动画完成后不自动删除动画
        fillMode                  动画完成后的状态
    代理方法
        animationDidStart         动画开始时执行
        animationDidStop          动画完成时执行
    范例
        CABasicAnimation
            //创建动画对象
            CABasicAnimation *anim = [CABasicAnimation animation];
            //设置属性和值
            anim.keyPath = @&quot;position.x&quot;;
            anim.toValue = @300;
            //动画完成后 不自动删除动画
            anim.removedOnCompletion = NO;
            //指定动画完成后的状态
            anim.fillMode = kCAFillModeForwards;
            //添加动画
            [self.subView.layer addAnimation:anim forKey:@&quot;x&quot;];
        CAKeyframeAnimation
            #define angle2Rad(angle) ((angle) / 180.0 * M_PI)
            CAKeyframeAnimation *anim = [CAKeyframeAnimation animation];
            anim.keyPath = @&quot;transform.rotation&quot;;
            anim.values = @[@(angle2Rad(-5)),@(angle2Rad(5)),@(angle2Rad(-5))];
            anim.repeatCount = MAXFLOAT;
            anim.duration = 0.2;
            [self.imageView.layer addAnimation:anim forKey:nil];

Modal
    说明
        除了push之外，还有另外一种控制器的切换方式，就是Modal
        任何控制器都能通过Modal的形式展示出来
        Modal的默认效果：新控制器从屏幕底部上拉，直到覆盖之前的控制器
    方法
        presentViewController          以Modal的形式展示控制器
        dismissViewControllerAnimated  关闭当初Modal出来的控制器

transform
    属性
        transform
    方法
        CGAffineTransformMakeTranslation     相对于原始位置平移
        CGAffineTransformTranslate           相对于上次位置平移
        CGAffineTransformMakeRotation        相对于原始位置旋转
        CGAffineTransformRotate              相对于上次位置旋转
        CGAffineTransformMakeScale           相对于原始位置缩放
        CGAffineTransformScale               相对于上次位置缩放
    范例
        相对于上次位置平移
            [UIView animateWithDuration:0.3 animations:^{
                self.image.transform = CGAffineTransformTranslate(self.image.transform, 0, -50);
            }];
        相对于上次位置旋转45度
            [UIView animateWithDuration:0.3 animations:^{
                self.image.transform = CGAffineTransformRotate(self.image.transform, M_PI_4);
            }];
        相对于上次位置放大1.2倍
            [UIView animateWithDuration:0.3 animations:^{
                self.image.transform = CGAffineTransformScale(self.image.transform, 1.2, 1.2);
            }];
</code></pre><h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><pre><code>Autoresizing
    说明
        可再storyboard或代码中设置控件相对于父控件的上下左右距离和长度宽度。
        可根据不同的屏幕大小固定控件位置。
        可设置控件的宽度和高度根据父控件的尺寸伸缩。
    属性
        autoresizingMask       设置Autoresizing的方式
    范例
        UIView *redView = [[UIView alloc]init];
        redView.backgroundColor = [UIColor redColor];
        CGFloat x = self.view.frame.size.width - 100;
        CGFloat y = self.view.frame.size.height - 100;
        redView.frame = CGRectMake(x, y, 100, 100);
        redView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin|UIViewAutoresizingFlexibleTopMargin;
        [self.view addSubview:redView];

Auto Layout
    说明
        一种自动自动布局技术，专门用来布局UI界面
        Autoresizing 仅能解决父控件和子控件之间的相对关系。
        Auto Layout 可以解决任何控件之间的相对关系。
        苹果建议使用 Auto Layout 不使用frame。
    核心概念
        约束(Constraints): 通过给控件添加约束，来决定控件的位置和尺寸
        参照: 在添加约束时，依照哪个控件来添加
    VFL
        可视化格式语言（Visual Format Language）
        为了简化 Auto Layout 编码推出的轻量语言
    Masonry
        Auto Layout 的第三方框架
        避免苹果 Auto Layout API的繁琐
        [官方地址][https://github.com/SnapKit/Masonry]
    使用代码添加约束原则
        两个同级控件添加约束，需要添加至两个控件的父级
        不同层级控件添加约束，需添加到两个控件最近的共同父级
        两个父子控件添加约束，需添加至父控件
    范例
        UIView *redView = [[UIView alloc]init];
        redView.backgroundColor = [UIColor redColor];
        [self.view addSubview:redView];
        //禁止自动转换Autoresizing为Auto Layout
        redView.translatesAutoresizingMaskIntoConstraints = NO;
        //设置宽度约束
        NSLayoutConstraint *width = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:0 multiplier:0.0 constant:100];
        //添加约束
        [redView addConstraint:width];
        //设置高度约束
        NSLayoutConstraint *height = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:0 multiplier:0.0 constant:100];
        //添加约束
        [redView addConstraint:height];
        //设置右边距约束
        NSLayoutConstraint *right = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:self.view  attribute:NSLayoutAttributeRight multiplier:1 constant:-20];
        //添加约束给父级
        [self.view addConstraint:right];
        //设置右边距约束
        NSLayoutConstraint *bottom = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view  attribute:NSLayoutAttributeBottom multiplier:1 constant:-20];
        //添加约束给父级
        [self.view addConstraint:bottom];
</code></pre><h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><pre><code>NSTimer
    说明
        可指定是否重复和每次调用的事件
        是一种非阻塞的执行方式，
        会受到Runloop运行模式的影响
        可以通过NSTimer类的- (void)invalidate;取消执行。
    对象方法
        scheduledTimerWithTimeInterval   指定延迟时间后执行指定方法
        invalidate                       停止定时器，

CADisplayLink
    说明
        每次屏幕刷新时调用指定的方法
        屏幕每秒刷新60次
        必须加入主运行循环才会执行
    属性
        paused               是否暂停
    对象方法
        addToRunLoop         加入到指定的runLoop
    范例
        CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(display)];
        [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];

performSelector
    说明
        任务在主线程中执行
        是一种非阻塞的执行方式，
        暂时未找到取消执行的方法。
    格式
        [self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f];

GCD
    说明
        通过Grand Central Dispatch 延迟执行某些操作
        可指定队列和延迟时间
    格式
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        });
</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><pre><code>通知
    说明
        NSNotificationCenter（通知中心），负责不同对象间的消息通信
        每一个应用程序都有一个NSNotificationCenter实例。
        任何对象都可以向通知中心发布NSNotification，描述自己做什么。
        其它对象可以申请在特定通知发布时收到通知。
        监听通知必须在发布通知之前
    通知属性
        -(NSString *)name;         通知的名称
        -(id)object;               通知的发布者
        -(NSDictionary)userInfo;   通知发布者传递给通知接受者的信息
    发布
        NSNotification *notf = [NSNotification notificationWithName:@&quot;set&quot; object:self userInfo:@{@&quot;msg&quot;:@&quot;success&quot;}];
        [[NSNotificationCenter defaultCenter]postNotification:notf];
    监听
        [[NSNotificationCenter defaultCenter]addObserver:obj selector:@selector(msg:) name:@&quot;set&quot; object:notf];
    移除
        [[NSNotificationCenter defaultCenter]removeObserver:self name:@&quot;set&quot; object:notf];

UIDevice
    说明
        UIDevice提供了一个单例对象，它代表设备，通过它可获取一些设备信息。
        比如电池电量(batteryLevel),电池状态(batteryState)，设备类型(model)
        UIDevice会发布设备状态改变的通知
    范例
        获取系统版本
            NSString * ver = [[UIDevice currentDevice]systemVersion];

KVC
    说明
        (Key Value Coding)键值编码
        最大的功能是取值和赋值
        可进行自动类型转换
        可以用KVC方式改变内部私有成员变量
    forKey和forKeyPath
        区别
            forKeyPath包含了所有forkey的区别
            forKeyPath可进行内部点语法递归访问内部属性
        共同点
            key必须存在，否则会报错
            使用时，内部会自动查找key和_key属性
    setValuesForKeysWithDictionary问题
        字典中的key必须在模型中属性找到
        如果模型中带有模型，这种方式会把模型内的模型设置为其它数据格式
    格式
        [obj setValue:(nullable id) forKey:(nonnull NSString *)];
        [obj setValue:(nullable id) forKeyPath:(nonnull NSString *)];
    范例
        设置值
            [person.dog setValue:@&quot;DaHuang&quot; forKey:@&quot;name&quot;];
            [person setValue:@&quot;DaHuang&quot; forKeyPath:@&quot;dog.name&quot;];
        取值
            [person valueForKey:@&quot;name&quot;];
            [person valueForKeyPath:@&quot;dog.name&quot;];
        改变私有成员变量
            @interface Person : NSObject
            {
                int _age;
            }
            -(void)printAge;
            @end
            @implementation Person
            -(void)printAge{
                NSLog(@&quot;age:%d&quot;,_age);
            }
            @end
            Person *person = [[Person alloc]init];
            [person setValue:@&quot;20&quot; forKeyPath:@&quot;age&quot;];
            [person printAge];
        字典转模型
            [self setValuesForKeysWithDictionary:dict];
        模型转字典
            NSDictionary *dist = [person dictionaryWithValuesForKeys:@[@&quot;name&quot;,@&quot;age&quot;]];
        取出模型中所有某个属性值
            NSArray *allPerson = @[person_1,person_2,person_3];
            NSArray *allPersonName = [allPerson valueForKeyPath:@&quot;name&quot;]

KVO
    说明
        (Key Value Observing)键值监听
        监听对象的某个属性值的改变
        对象销毁时需移除监听器
        只要类用到KVO，苹果会自动为这个类生成一个子类，可通过isa查看。
    范例
        设置监听器
            [person addObserver:self forKeyPath:@&quot;name&quot; options:nil context:nil];
        移除监听器
            [person removeObserver:self forKeyPath:@&quot;name&quot;];
        设置监听函数
            -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context{
            }

runtime
    说明
        运行时机制
        能动态获取当前类的成员属性，不能获取其子类或父类的属性
</code></pre><h2 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h2><pre><code>程序启动原理
    1.执行main函数
    2.执行UIApplicationMain，创建UIApplication对象，并设置UIApplication的代理。
    3.开启事件循环（主运行循环,用来保证应用程序不退出）
    4.去加载Info.plist文件，依据Info.plist文件执行如下操作
        判断是否有Main参数，如果有则加载Main.storyBoard
        创建一个窗口
        把Main.storyBoard中箭头所指向的控制器设为根控制器
        显示窗口（把窗口的根控制器的view添加到窗口）
    5.应用程序启动完毕，并通知代理。

UIWindow
    说明
        UIWindow是一个特殊的UIView，通常一个App中至少有一个UIWindow。
        iOS程序启动完毕后，创建的第一个视图控件就是UIWindow。
        UIWindow创建后，则创建控制器的view，并把控制器的view添加到UIWindow。
        一个iOS程序之所以能显示到屏幕上，完全是因为有UIWindow。
        没有UIWindow则看不到任何UI界面。
    范例
        - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
            //创建窗口
            self.window = [[UIWindow alloc]init];
            //指定窗口的根控制器啊
            UIViewController *vc = [[UIViewController alloc]init];
            vc.view.backgroundColor = [UIColor redColor];
            self.window.rootViewController =vc;
            //显示窗口
            [self.window makeKeyAndVisible];
            return YES;
        }

LaunchScreen
    说明
        Xcode7种多了一个LaunchScreen.storyboard用来设置启动页面。
        如果没有在项目设置中指定LaunchScreen.storyboard，默认屏幕大小为4S大小。
        LaunchScreen的底层实现是把LaunchScreen.storyboard当中的内容生成一张图片。

Info.plist
    说明
        用来保存设置应用程序的配置信息。是一个字典类型
    属性
        Bundle identifier                应用程序唯一标识，发布和推送时会用到
        Bundle name                      应用程序名称  
        Bundle versions string, short    用于itunes上显示的版本号，即对外的版本
        Bundle version                   应用程序打包版本号，用于项目管理，不对外
    程序中获取获取参数
        [NSBundle mainBundle].infoDictionary[@&quot;property&quot;]

Prefix.pch
    说明
        可存放一些公有的宏
        可导入公用头文件
        可自定义NSLog方法用来在生产环境关闭日志
    原理
        编译过程中，会把PCH文件当中的所有内容导入到工程中所有文件内
        如果PCH中内容较多，会导致编译过程较长
        和C混合编译时会报错，需使用__OBJC__判断当前文件是否是OC文件
    创建
        Command + N -&gt; Other -&gt; PCH File
        文件名通常和项目同名
    配置
        项目配置 -&gt; Build Settings -&gt; Precompile Prefix Header : Yes
        项目配置 -&gt; Build Settings -&gt; Prefix Header : XXX/XXX.pch
    范例
        #ifdef __OBJC__
        #define ScreenWidth [UIScreen mainScreen].bounds.size.width
        #import &quot;XXXXX.h&quot;
        #ifdef DEBUG
        #define XMGLOG(...) NSLog(__VA_ARGS__)
        #else
        #define XMGLOG(...)
        #endif
        #endif

AppIcon
    说明
        设置应用程序的图标
        把图标按照特定文件名和尺寸放置到Assets.xcassets中AppIcon内

状态栏
    说明
        从iOS7开始,系统提供了2种管理状态栏的方式，
        通过UIViewController管理(每一个UIViewController都可以拥有自己不同的状态栏)。
        通过UIApplication管理(一个应用程序的状态栏都由它统一管理)。
        在iOS7中,默认情况下,状态栏都是由UIViewController管理的。
        可通过Info.plist中的View controller-based status bar appearance字段设置是否由UIApplication管理。
    UIViewController实现状态栏样式和可见性
        状态栏的样式
            - (UIStatusBarStyle)preferredStatusBarStyle;
        状态栏的可见性
            - (BOOL)prefersStatusBarHidden;

UIApplication
    说明
        UIApplication对象是应用程序的象征。
        一个应用程序中只有一个UIApplication对象，并且是单例的。
        通过 [UIApplication shareApplication] 可获取这个单例对象
        一个iOS程序启动后创建的第一个对象就是UIApplication对象
        利用UIApplication对象可进行一些应用级别的操作
    属性
        keyWindow       获取通过nakeKeyAndVisiable设置的主窗口
    delegate
        说明
            当系统发生某些事情（如电话，锁屏）导致App收到打扰时，会产生一系列事件。
            这时UIApplication会通知它的代理对象，让代理处理这些系统事件
            代理协议为UIApplicationDelegate
            工程创建时已默认创建了AppDelegate文件并遵守了UIApplicationDelegate协议
        系统事件
            应用程序的生命周期事件（如程序启动或关闭）
            系统事件（如来电）
            内存警告
        协议方法
            didFinishLaunchingWithOptions       应用程序启动完毕时调用
            applicationWillResignActive         应用程序失去焦点时调用
            applicationDidEnterBackground       应用程序进入后台时调用
            applicationWillEnterForeground      应用程序进入前台时调用
            applicationDidBecomeActive          应用程序获取焦点时调用
            applicationWillTerminate            应用程序退出时调用
            applicationDidReceiveMemoryWarning  应用程序收到内存警告时调用
    范例
        设置应用程序图标右上角的红色提醒数字
            //获取UIApplication对象
            UIApplication *app = [UIApplication sharedApplication];
            //注册通知
            UIUserNotificationSettings *notice = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge categories:nil];
            [app registerUserNotificationSettings:notice];
            //设置提醒值
            app.applicationIconBadgeNumber = 20;
        设置联网状态
            UIApplication *app = [UIApplication sharedApplication];
            app.networkActivityIndicatorVisible = YES;
        设置状态栏（需先设置Info.plist）
            UIApplication *app = [UIApplication sharedApplication];
            app.statusBarHidden = YES;
            app.statusBarStyle = UIStatusBarStyleLightContent;
        打开网页
            [app openURL:[NSURL URLWithString:@&quot;tel//10086&quot;]];
            [app openURL:[NSURL URLWithString:@&quot;sms//10086&quot;]];
            [app openURL:[NSURL URLWithString:@&quot;mailto//7760442@g.com&quot;]];
            [app openURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
        创建单例对象
            @interface Person : NSObject
            +(instancetype)sharePerson;
            @end
            @implementation Person
            static Person *_instance;
            //程序加载时，就创建对象
            +(void)load{
                _instance = [[Person alloc]init];
            }
            //每次创建对象都返回同一个实例
            +(instancetype)sharePerson{
                return _instance;
            }
            //如果调用alloc抛出错误
            +(instancetype)alloc{
                if(_instance){
                    NSException *exc = [NSException exceptionWithName:@&quot;异常名称&quot; reason:@&quot;错误原因&quot; userInfo:nil];
                    [exc raise];
                }
                return [super alloc];
            }
            @end
</code></pre><h2 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h2><pre><code>说明
    Runtime简称运行时，OC就是运行时机制，是运行时的一些机制，其中最主要的是消息机制。
    对于C语言，函数的调用在编译时会决定调用哪个函数。
    对于OC语言，属于动态调用过程，在编译时不能决定真正调用哪个函数。
    只有在真正运行时的时候才会根据函数的名称找到对应的函数来调用。
    在编译阶段，OC可以调用任何函数，即使这个函数未实现，只要声明过就不会报错。
    在编译阶段，C语言调用未实现的语言会报错。
    通过RunTime可以调用私有方法

设置RunTime方法提示
    Build Settings -&gt; Enable Strict Checking of objc_Send Calls -&gt; NO

方法调用流程
    1. 根据对象的isa指针,找到方法所在类。
    2. 注册方法编号，因编号查找比字符串查找快速。
    3. 根据方法编号，去方法的类中方法列表中查找函数实现地址。
    4. 根据函数地址去方法区调用对应的函数，方法的实现是保存在内存中的方法区、而不在类里面

发送消息
    说明
        任何方法调用的本质为发送小心，发送消息是通过RunTime实现的。
        Xcode的clang编译器最终会把OC中的代码转换成底层RunTime的实现。
        可在终端通过 clang -rewrite-objc xx.m 查看最终生成代码。
        使用时需导入&lt;objc/message.h&gt;头文件
    范例
        创建对象
            #import &lt;objc/message.h&gt;
            id objc = objc_msgSend([NSObject class], @selector(alloc));
            objc = objc_msgSend(objc, @selector(init));
        从自定义类创建对象
            Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;allco&quot;));
            p = objc_msgSend(p, sel_registerName(&quot;init&quot;));

交换方法
    说明
        可以通过RunTime来交换方法的实现。
        比如以自定义的方法来替换替换默认的方法。
    范例
        @interface UIImage (Custom)
        +(UIImage *)cus_imageNamed:(NSString *)name;
        @end
        #import &quot;UIImage+Custom.h&quot;
        #import &lt;objc/message.h&gt;
        @implementation UIImage (Custom)
        +(void)load{
            //获取并交换两个方法
            Method imageNamedMethod = class_getClassMethod(self, @selector(imageNamed:));
            Method cus_imageNamedMethod = class_getClassMethod(self, @selector(cus_imageNamed:));
            method_exchangeImplementations(imageNamedMethod, cus_imageNamedMethod);
        }
        //自定义的cus_imageNamed方法
        +(UIImage *)cus_imageNamed:(NSString *)name{
            UIImage *image = [UIImage cus_imageNamed:name];
            if(image){
                NSLog(@&quot;加载成功&quot;);
            }else{
                NSLog(@&quot;加载失败&quot;);
            }
            return image;
        }
        @end
        //使用imageNamed方法方法时会自动调用cus_imageNamed方法
        UIImage *image = [UIImage imageNamed:@&quot;1.png&quot;];

动态添加方法
    说明
        OC中只要一个方法实现了，就会立即添加到方法列表中。
        实际开发中，有一些功能是在满足某些条件下才可以使用，比如付费功能。
        这时可通过动态添加方法来实现。
        任何方法内都有self和_cmd两个隐式参数。
        _cmd表示当前方法的方法编号。
    方法
        @interface Person : NSObject
        @end
        #import &quot;Person.h&quot;
        #import &lt;objc/message.h&gt;
        @implementation Person
        void eat(id self, SEL _cmd){
            NSLog(@&quot;eat&quot;);
        }
        //只要一个对象调用了未实现的方法就会调用此方法。
        + (BOOL)resolveInstanceMethod:(SEL)sel{
            if(sel == NSSelectorFromString(@&quot;eat&quot;)){
                class_addMethod(self, sel, (IMP)eat, &quot;v@:&quot;);
            }
            return [super resolveInstanceMethod:sel];
        }
        @end
        //调用一个未实现的方法
        Person *p = [[Person alloc]init];
        [p performSelector:@selector(eat)];

给分类动态添加属性
    说明
        通过RunTime可以给一个对象动态添加属性，比如让一个NSObject类保存一个字符串。
        动态添加属性的本质是让某个属性和对象产生关联。
    范例
        #import &lt;Foundation/Foundation.h&gt;
        @interface NSObject (Property)
        @property NSString *name;
        @end
        #import &quot;NSObject+Property.h&quot;
        #import &lt;objc/message.h&gt;
        @implementation NSObject (Property)
        -(void)setName:(NSString *)name{
            //给当前对象添加属性
            objc_setAssociatedObject(self, &quot;name&quot;, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        }
        -(NSString *)name{
            //获取当前对象动态添加的属性
            return objc_getAssociatedObject(self, &quot;name&quot;);
        }
        @end
        使用方式
        NSObject *objc = [[NSObject alloc]init];
        objc.name = @&quot;ABC&quot;;
        NSLog(@&quot;%@&quot;,objc.name);

字典转模型
    说明
        KVC的问题是字典中的key如果在模型中不存在的话会报错。
        可以利用RunTime来实现字典转模型并避免此问题。
        主要思路为遍历模型的属性，然后依据属性名从字典中获取数据并给模型赋值。
    范例
        @interface NSObject (Model)
        + (instancetype)modelWithDict:(NSDictionary *)dict;
        @end
        #import &quot;NSObject+Model.h&quot;
        #import &lt;objc/message.h&gt;
        @implementation NSObject (Model)
        + (instancetype)modelWithDict:(NSDictionary *)dict{
            id objc = [[self alloc] init];
            //定义成员变量的个数
            unsigned int count = 0;
            //获取成员变量的数组
            Ivar *ivarList = class_copyIvarList(self, &amp;count);
            for (int i = 0; i&lt;count; i++) {
                //获取成员变量
                Ivar ivar = ivarList[i];
                //获取成员变量名字
                NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];
                //去掉成员变量名前的下划线
                NSString *key = [ivarName substringFromIndex:1];
                //从字典中获取值
                id value = dict[key];
                //获取当前成员变量的类型名
                NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];
                //替换字符串中的@和&quot;字符
                ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];
                ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];
                //二级转换，如果dict的值为字典并且是自定义对象，则转换为子模型
                if([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType hasPrefix:@&quot;NS&quot;]){
                    //把类型名转换为类型
                    Class modelClass = NSClassFromString(ivarType);
                    //把value重新赋值为子模型
                    value = [modelClass modelWithDict:value];
                }
                //给模型中属性赋值
                if(value){
                    [objc setValue:value forKey:key];
                }
            }
            return objc;
        }
        @end
</code></pre><h2 id="Xcode-使用"><a href="#Xcode-使用" class="headerlink" title="Xcode 使用"></a>Xcode 使用</h2><pre><code>Xcode5于Xcode7区别
    FrameWorks
        Xcode5有个FrameWorks文件夹，用于存放框架。
        Xcode7会在程序编译时自动导入框架，如需查看框架的头文件，也可在项目配置中导入。
    LaunchScreen
        Xcode7种多了一个LaunchScreen.storyboard用来设置启动页面。
        如果没有在项目设置中指定LaunchScreen.storyboard，默认屏幕大小为4S大小。
    Info.plist
        Xcode5中此文件存放在 Supporting Files 文件夹内
        Xcode5种还包含infoPlist.strings文件，用来做多语言本地化
        Xcode7中存放在项目根目录下
    Prefix.pch
        Xcode7中无此文件

显示行号
    Preferences -&gt; Text Editing -&gt; Show Line numbers

Xcode8关闭启动时的注释
    Product -&gt; Scheme -&gt; Edit Scheme... -&gt; Run
    add the following environment variable: 
    Name:OS_ACTIVITY_MODE, Value: disable

插件
    插件安装后的路径
        ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins
    删除插件
        在安装目录下直接删除文件即可
    插件管理
        [Alcatraz][https://github.com/alcatraz/Alcatraz]
    注释生成器
        [VVDocumenter-Xcode](https://github.com/onevcat/VVDocumenter-Xcode)
    图片文件名提示
        [KSImageNamed-Xcode](https://github.com/ksuther/KSImageNamed-Xcode)
</code></pre><h2 id="iOS9新特性"><a href="#iOS9新特性" class="headerlink" title="iOS9新特性"></a>iOS9新特性</h2><pre><code>新增关键字
    nulllable
        说明
            用来指定属性可为空。
            可以用于属性，方法和参数中。
        范例
            @property (nonatomic, strong, nullable) NSString *str;
            @property (nonatomic, strong) NSString * _Nullable str;
    nonnull
        说明
            用来指定属性不可为空。
            如果传null,nil会警告而不会报错
            在NS_ASSUME_NONNULL_BEGIN,NS_ASSUME_NONNULL_END宏内的属性为nonnull
        范例
            @property (nonatomic, strong, nonnull) NSString *str;
            @property (nonatomic, strong) NSString * _Nonnull str;
    null_resettable
        说明
            get方法不能返回nil。必须在get方法内处理为空的情况。
            set方法传入参数时可为nil。
        范例
            @property (nonatomic, strong, null_resettable) NSString *str;
    null_unspecified
        说明
            不确定是否为空
        范例
            @property (nonatomic, strong, null_unspecified) NSString *str;
            @property (nonatomic, strong) NSString * _Null_unspecified str;

泛型
    说明
        可用于限制集合内元素的类型，和Swift保持了一致。
        在定义时不确定类型，在使用时才确定类型的情况可使用。
        优点是提高了代码规范可可读性，减少了沟通成本。
        在OC中不符合泛型要求会报警告，而不是报错。
    协变和逆变
        用于父子类型的转换。
        协变关键字为 __covariant，允许子类赋值给父类
        逆变关键字为 __contravariant，允许父类赋值给子类
    范例
        定义带有泛型的数组
            NSMutableArray&lt;NSString *&gt; *arr = [NSMutableArray array];
        在定义类中使用
            @interface Person&lt;T&gt; : NSObject
            @property (nonatomic, strong) T attrNmae;
            @end
            Person&lt;UIButton *&gt; *p = [[Person alloc]init];
            p.attrNmae = [[UIButton alloc]init];

__kindof
    说明
        用来表示当前类或者它的子类。
    范例
        @interface Person : NSObject
        + (__kindof Person *)person;
        @end
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/16/Kcptun使用/" itemprop="url">
                  Raspberry Pi 安装 Kcptun
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-16T11:47:52+08:00" content="2016-09-16">
              2016-09-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>Kcptun的作用主要是配合SS用来做加速，试过把Kcptun安装到路由器中，由于性能和稳定性的问题效果不如安装到树莓派上面效果好，配合systemd可以做到开机启动和进程断掉重启服务。配置比较简单，下文的配置方式用来给大家参考。</p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><pre><code>官网
    https://github.com/xtaci/kcptun

下载地址
    https://github.com/xtaci/kcptun/releases/latest

其他资源
    https://blog.kuoruan.com/102.html
</code></pre><h2 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h2><pre><code>下载
    cd /usr/local/opt/
    mkdir kcptun
    cd kcptun
    wget .../kcptun-linux-amd64.tar.gz
    tar -zxf kcptun-linux-amd64.tar.gz

创建 systemd service
    vi /etc/systemd/system/kcptun-server.service

kcptun-server.service 文件内容
    [Unit]
    Description=Start or stop the kcptun-server
    After=network.target
    Wants=network.target
    [Service]
    ExecStart=/usr/local/opt/kcptun/server_linux_amd64 --key &quot;username&quot; -t &quot;127.0.0.1:443&quot; -mtu 1400 -sndwnd 2048 -rcvwnd 2048 -mode fast2
    Restart=1
    [Install]
    WantedBy=multi-user.target

配置说明
    -t &quot;127.0.0.1:443&quot;     指定的是本机地址和shadowsocks的端口
    -mode                  加速模式，fast3 &gt; fast2 &gt; fast &gt; normal &gt; default
    -h                     可查看其他参数说明

启动
    systemctl start kcptun-server

关闭
    systemctl stop kcptun-server

查看状态
    systemctl status kcptun-server

设置开机启动
    systemctl enable kcptun-server
</code></pre><h2 id="Raspberry-Pi-设置"><a href="#Raspberry-Pi-设置" class="headerlink" title="Raspberry Pi 设置"></a>Raspberry Pi 设置</h2><pre><code>下载安装
    cd /usr/local/opt/
    mkdir kcptun
    cd kcptun
    wget .../kcptun-linux-arm.tar.gz
    tar -zxf kcptun-linux-arm.tar.gz

创建 systemd service
    vi /etc/systemd/system/kcptun-client.service

kcptun-client.service 文件内容
    [Unit]
    Description=Start or stop the kcptun-client
    After=network.target
    Wants=network.target
    [Service]
    ExecStart=/usr/local/opt/kcptun/client_linux_arm7 --key &quot;username&quot; -r &quot;45.78.32.99:29900&quot; -l &quot;:443&quot; -mtu 1400 -sndwnd 256 -rcvwnd 2048 -mode fast2 -dscp 46
    Restart=1
    [Install]
    WantedBy=multi-user.target

启动
    systemctl start kcptun-client

关闭
    systemctl stop kcptun-client

查看状态
    systemctl status kcptun-client

设置开机启动
    systemctl enable kcptun-client
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/04/Swift-笔记/" itemprop="url">
                  Swift-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-04T15:47:52+08:00" content="2016-09-04">
              2016-09-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文为学习<a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">SwiftGG 翻译的 Swift Programming Language</a>时的笔记，看的过程中swift 3.0发布，其中的一些代码已经针对swift 3.0做了修改。<br>目前最新的翻译已经包括了3.0的内容，建议大家完整阅读原版。</p>
<h2 id="基础部分-TheBasics"><a href="#基础部分-TheBasics" class="headerlink" title="基础部分(TheBasics)"></a>基础部分(TheBasics)</h2><pre><code>常量和变量
    声明常量
        let maxNumber = 10
    声明变量
        var str = &quot;Hello World&quot;

类型标注(type annotation)
    说明
        如果在声明常量或者变量时赋了一个初始值,Swift可以推断出这个常量或者变量的类型
        在没有初始值的时候，可用来说明常量或变量存储的值的类型
    范例
        var message: String
        var red, green, blue: Double

常量和变量的命名
    说明
        可以用任何你喜欢的字符作为常量和变量名,包括 Unicode 字符
        不能包含数学符号,箭头,保留的(或者非法的)Unicode码位,连线与制表符
        不能以数字开头,但是可以在常量与变量名的其他地方包含数字
        不能改变存储值的类型，也不能重复声明
    范例
        let π = 3.14159
        let 你好 = &quot;你好世界&quot; let ?? = &quot;dogcow&quot;

输出常量和变量
    说明
        print函数会自动添加换行符
        如果不想换行,可以传递一个空字符串给 terminator
        Swift可通过字符串插值的方式把常量或变量插入到字符串，格式为 “\(varName)“
    格式
        print(_:separator:terminator:)
    范例
        输出变量
            var friendlyWelcome = &quot;Hello!&quot;
            print(friendlyWelcome)
        不换行输出
            print(&quot;hello world!&quot;, terminator:&quot;&quot;)
        字符串中加入变量
            var friend = &quot;HanMeiMei&quot;
            print(&quot;hello \(friend)&quot;)

注释
    说明
        编译器将会在编译代码时自动忽 略掉注释部分
        与 C 语言多行注释不同,Swift 的多行注释可以嵌套在其它的多行注释之中。
    范例
        行注释
            //这是一个行注释
        多行注释
            /* 这是一个, 
            多行注释 */
        嵌套多行注释
            /* 这是第一个多行注释的开头
            /* 这是第二个被嵌套的多行注释 */ 
            这是第一个多行注释的结尾 */

分号
    说明
        Swift 并不强制要求你在每条语句的结尾处使用分号
        有一种情况下必须要用分号,即你打算在同一行内写多条独立的语句
    范例
        let cat = &quot;?&quot;; print(cat)

整数
    Swift 提供了8,16,32和64位的有符号和无符号整数类型
    整数可以是 有符号 (正、负、零)或者 无符号 (正、零)
    8位无符号整数类型是 UInt8,32位有符号整数类型是 Int32 

整数范围
    let minValue = UInt8.min // minValue 为 0,是 UInt8 类型 
    let maxValue = UInt8.max // maxValue 为 255,是 UInt8 类型

Int
    Swift提供的Int长度与当前平台的原生字长相同
    在32位平台上, Int 和 Int32 长度相同。 
    在64位平台上, Int 和 Int64 长度相同。

UInt
    Swift也提供了一个特殊的无符号类型UInt,长度与当前平台的原生字长相同:
    在32位平台上, UInt 和 UInt32 长度相同。
    在64位平台上, UInt 和 UInt64 长度相同

浮点数
    Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型
    Float表示32位浮点数。精度要求不高的话可以使用此类型

类型安全和类型推断
    Swift在编译你的代码时进行类型检查(type checks),并把不匹配的类型标记为错误
    如果没有显式指定类型,Swift会使用类型推断(type inference)来选择合适的类型
    当推断整数类型时,Swift 总是会选择 Int 而不是 UInt  
    当推断浮点数的类型时,Swift 总是会选择 Double 而不是 Float 

数值型字面量
    说明
        整数和浮点数都可以添加额外的零并且包含下划线,来增加可读性
        如果一个十进制数的指数为 exp ,那这个数相当于基数和10^exp的乘积
        1.25e2 表示 1.25 × 10^2,等于 125.0
        1.25e-2 表示 1.25 × 10^-2,等于 0.0125
        如果一个十进制数的指数为 exp ,那这个数相当于基数和10^exp的乘积
        1.25e2 表示 1.25 × 10^2,等于 125.0
        1.25e-2 表示 1.25 × 10^-2,等于 0.0125
    格式
        十进制数      没有前缀
        二进制数      前缀是 0b
        八进制数      前缀是 0o
        十六进制      前缀是 0x
    范例
        下面的所有整数字面量的十进制值都是17
            let decimalInteger = 17
            let binaryInteger = 0b10001
            let octalInteger = 0o21
            let hexadecimalInteger = 0x11
        下面的这些浮点字面量都等于十进制的 12.1875
            let decimalDouble = 12.1875
            let exponentDouble = 1.21875e1
            let hexadecimalDouble = 0xC.3p0
        整数和浮点数都可以添加额外的零并且包含下划线
            let paddedDouble = 000123.456
            let oneMillion = 1_000_000
            let justOverOneMillion = 1_000_000.000_000_1

整数转换
    说明
        不同类型的值参与运算时需转换为同一类型
        SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法
        在语言内部, UInt16 有一个构 造器,可以接受一个 UInt8 类型的值
        所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16 
        并不能传入任意类型的值,只能传入 UInt16 内部有对应构造器的值
        不过你可以扩展现有的类型来让它可以接收 其他类型的值(包括自定义类型)
    格式
        SomeType(ofInitialValue)
    范例
        let twoThousand: UInt16 = 2_000
        let one: UInt8 = 1
        let twoThousandAndOne = twoThousand + UInt16(one)

数整数和浮点数转换
    说明
        整数和浮点数的转换必须显式指定类型
        转换为整数时，浮点值会被截断。4.75 会变成 4 , -3.9 会变成 -3
        数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测
    范例
        整数转换为浮点
            let three = 3
            let pointOneFourOneFiveNine = 0.14159
            let pi = Double(three) + pointOneFourOneFiveNine
        浮点转换为整数
            let integerPi = Int(pi)

类型别名
    说明
        类型别名(type aliases)就是给现有类型定义另一个名字
        可以使用 typealias 关键字来定义类型别名
    范例
        typealias AudioSample = UInt16
        var maxAmplitudeFound = AudioSample.min

布尔值
    说明
        Swift 有一个基本的布尔(Boolean)类型,叫做 Bool
        Swift 有两个布尔常量, true 和 false
        如果在需要使用 Bool 类型的地方使用了非布尔值,Swift的类型安全机制会报错
    范例
        let orangesAreOrange = true
        let turnipsAreDelicious = false
        if turnipsAreDelicious {
            print(&quot;Mmm, tasty turnips!&quot;)
        } else {
            print(&quot;Eww, turnips are horrible.&quot;)
        }

元组
    说明
        元组(tuples)把多个值组合成一个复合值。
        元组内的值可以是任意类型,并不要求是相同类型。
        元组在临时组织值的时候很有用,但是并不适合创建复杂的数据结构。 
    范例
        创建
            let http404Error = (404, &quot;Not Found&quot;)
            // http404Error 的类型是 (Int, String),值是 (404, &quot;Not Found&quot;)
        分解
            let (statusCode, statusMessage) = http404Error 
            print(&quot;The status code is \(statusCode)&quot;)
            // 输出 &quot;The status code is 404&quot;
            print(&quot;The status message is \(statusMessage)&quot;)
            // 输出 &quot;The status message is Not Found&quot;
        部分分解
            let (justTheStatusCode, _) = http404Error
            print(&quot;The status code is \(justTheStatusCode)&quot;)
            // 输出 &quot;The status code is 404&quot;
        通过下标访问
            print(&quot;The status code is \(http404Error.0)&quot;)
            // 输出 &quot;The status code is 404&quot;
            print(&quot;The status message is \(http404Error.1)&quot;)
            // 输出 &quot;The status message is Not Found&quot;
        定义元组的时候给单个元素命名
            let http200Status = (statusCode: 200, description: &quot;OK&quot;)
            print(&quot;The status code is \(http200Status.statusCode)&quot;)
            // 输出 &quot;The status code is 200&quot;
            print(&quot;The status message is \(http200Status.description)&quot;)
            // 输出 &quot;The status message is OK&quot;

可选
    说明
        可选表示要可能有值，也可能没有值，用 ? 表示
        例如使用 Int() 转换一个字符串时，返回的是一个可选的 Int?
        可选的 Int 被写 作 Int? 而不是 Int
    范例
        let possibleNumber = &quot;123&quot;
        let convertedNumber = Int(possibleNumber)
        // convertedNumber 被推测为类型 &quot;Int?&quot;, 或者类型 &quot;optional Int&quot;

nil
    说明
        可以给可选变量赋值为 nil 来表示它没有值
        nil 不能用于非可选的常量和变量
        如果代码中有常量或者变量需要处理值缺失的情况,请把它们声明成对应的可选类型
        在 Objective-C 中, nil 是一个指向不存在对象的指针。
        在 Swift 中, nil 不是指针——它是一个确定的值,用来表示值缺失。
        任何类型的可选状态都可以被设置 为 nil ,不只是对象类型。
    范例
        可选类型的声明和初始化
            var serverResponseCode: Int? = 404
            serverResponseCode = nil
        不初始化时自动设置为nil
            var surveyAnswer: String?
            // surveyAnswer 被自动设置为 nil

if语句以及强制解析
    说明
        可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。
        可以使用“相等”( == )或“不等”( != )来执行比较。
        当确定可选类型确实包含值之后,可在可选的名字后面加一个感叹号( ! )来获取值。
        惊叹号表 示“我知道这个可选有值,请使用它。”这被称为可选值的强制解析
        使用 ! 来获取一个不存在的可选值会导致运行时错误。
    范例
        判断可选类型是否有值
            var num = Int(&quot;100&quot;);
            if num != nil {
                print(&quot;num contains some integer value.&quot;)
            }
        强制解析
            if num != nil {
                print(&quot;num is \(num!).&quot;)
            }

可选绑定
    说明
        可选绑定(optional binding)可用来判断可选类型是否包含值
        如果包含就把值赋给一个临时常量或者变量
        可选绑定如果转换成功，变量既可在循环的第一个分支使用，而不需要使用 ! 后缀
    范例
        let str = &quot;100&quot;
        if let num = Int(str) {
            print(&quot;\&apos;\(str)\&apos; has an integer value of \(num)&quot;)
        } else {
            print(&quot;\&apos;\(str)\&apos; could not be converted to an integer&quot;)
        }

隐式解析可选类型
    说明
        可以把隐式解析可选类型当做一个可以自动解析的可选类型
        一个隐式解析可选类型其实就是一个普通的可选类型,但是可以被当做非可选类型来使用
        并不需要每次都使用解析来获取可选值
    范例
        let possibleString: String? = &quot;An optional string.&quot;
        let forcedString: String = possibleString! // 需要惊叹号来获取值
        let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot; 
        let implicitString: String = assumedString // 不需要感叹号

错误处理
    说明
        一个函数可以通过在声明中添加 throws 关键词来抛出错误消息
        当函数能抛出错误消息时, 应该在表达式中前置 try 关键词
    范例
        func canThrowAnError() throws {
            // 这个函数有可能抛出错误
        }
        do {
            try canThrowAnError()
            // 没有错误消息抛出
        } catch {
            // 有一个错误消息抛出
        }

断言
    说明
        断言会在条件为false时候终止程序运行，并在控制台弹出定义的信息
        可以使用全局 assert(_:_file:line:) 函数来写一个断言
        当代码使用优化编译的时候,断言将会被禁用
    范例
        let age = -3
        assert(age &gt;= 0, &quot;A person&apos;s age cannot be less than zero&quot;)
</code></pre><h2 id="基本运算符-BasicOperators"><a href="#基本运算符-BasicOperators" class="headerlink" title="基本运算符(BasicOperators)"></a>基本运算符(BasicOperators)</h2><pre><code>术语
    一元运算符对单一操作对象操作，如 ( -a )。
    一元运算符分前置运算符和后置运算符, 如 ( !b ) 和 ( i++ ) 
    二元运算符操作两个操作对象，如 ( 2 + 3 )
    Swift 只有一个三元运算符,就是三目运算符( a ? b : c)

赋值运算符
    说明
        赋值运算( a = b ),表示用 b 的值来初始化或更新 a 的值
        Swift 的赋值操作并不返回任何值
    范例
        赋值
            let b = 10
            var a = 5
            a= b
        元祖赋值
            let (x, y) = (1, 2)
            // 现在 x 等于 1, y 等于 2
        错误例子
            if x = y {
                //此句错误, 因为 x = y 并不返回任何值
            }

算术运算符
    说明
        Swift支持四则运算符，求余运算符，自增自减运算符，正负运算符
        加法运算符也可用于 String 的拼接
        Swift 默认情况下不允许在数值运算中出现溢出情况
        不同于 C 语言和 Objective-C,Swift中是可以对浮点数进行求余
    范例
        字符串拼接
            &quot;hello, &quot; + &quot;world&quot; // 等于 &quot;hello, world&quot;
        求余运算符
            9 % 4    // 等于 1
            -9 % 4   // 等于 -1
            8 % 2.5  // 等于 0.5
        自增和自减运算
            var i = 0;
            i++       //先自増再返回
            ++i       //先自増再返回, i=i+1 的缩写
            i--       //先自増再返回
            --i       //先自増再返回, i=i-1 的缩写
        一元负号运算符
            let three = 3
            let minusThree = -three     //minusThree 等于 -3
            let plusThree = -minusThree //plusThree 等于 3
        一元正号运算符
            let minusSix = -6
            let alsoMinusSix = +minusSix  //alsoMinusSix 等于 -6

组合赋值运算符
    说明
        复合赋值运算并没有返回值
    范例
        a += 2

比较运算符
    说明
        每个比较运算都返回了一个标识表达式是否成立的布尔值
        Swift 也提供恒等 === 和不恒等 !== 来判断两个对象是否引用同一个对象实例
    范例
        1 == 1    // true, 因为 1 等于 1
        2 != 1    // true, 因为 2 不等于 1
        2 &gt; 1     // true, 因为 2 大于 1
        1 &lt; 2     // true, 因为 1 小于2
        1 &gt;= 1    // true, 因为 1 大于等于 1
        2 &lt;= 1    // false, 因为 2 并不小于等于 1

三目运算符
    范例
        let contentHeight = 40
        let hasHeader = true
        let rowHeight = contentHeight + (hasHeader ? 50 : 20)

空合运算符
    说明
        空合运算符( a ?? b )将对可选类型a进行空判断，有则解析否则返回默认值b
        空合运算符是对以下代码的简短表达方法：a != nil ? a! : b
        如果 a 为非空值( non-nil ),那么值 b 将不会被估值。这也就是所谓的短路求值
    范例
        let a:Int? = Int(&quot;a100&quot;);
        let b = 10;
        print(a ?? b)   //结果为10

区间运算符
    说明
        闭区间运算符( a...b )定义一个包含从 a 到 b (包括 a 和 b )的所有值的区间
        闭区间运算符在迭代一个区间的所有值时是非常有用的
        半开区间( a..&lt;b )定义一个从 a 到 b 但不包括 b 的区间
    范例
        闭区间迭代
            for index in 1...5 {
                print(&quot;\(index) * 5 = \(index * 5)&quot;)
            }
            // 1 * 5 = 5
            // 2 * 5 = 10
            // 3 * 5 = 15
            // 4 * 5 = 20
            // 5 * 5 = 25
        半开区间迭代数组
            let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]
            let count = names.count
            for i in 0..&lt;count {
            print(&quot;第 \(i + 1) 个人叫 \(names[i])&quot;) }
            // 第 1 个人叫 Anna
            // 第 2 个人叫 Alex
            // 第 3 个人叫 Brian
            // 第 4 个人叫 Jack

逻辑运算符
    逻辑非
        说明
            ( !a ) 对一个布尔值取反,使得 true 变 false , false 变 true
        范例
            let allowedEntry = false
            if !allowedEntry {
                print(&quot;ACCESS DENIED&quot;)
            }
            // 输出 &quot;ACCESS DENIED&quot;
    逻辑与
        说明
            ( a &amp;&amp; b ) 只有 a 和 b 的值都为 true 时,整个表达式的值才会是 true
            如果左边的表达式为结果为 false ,那么是不去计算右边的表达式
        范例 
            let enteredDoorCode = true
            let passedRetinaScan = false
            if enteredDoorCode &amp;&amp; passedRetinaScan {
                print(&quot;Welcome!&quot;)
            } else {
                print(&quot;ACCESS DENIED&quot;)
            }
            // 输出 &quot;ACCESS DENIED&quot;
    逻辑或
        说明
            ( a || b ) 表示了两个逻辑表达式的其中一个为 true ,整个表达式就为 true
            当左端的表达式为 true 时,将不计算右边的表达式
        范例
            let hasDoorKey = false
            let knowsOverridePassword = true
            if hasDoorKey || knowsOverridePassword {
                print(&quot;Welcome!&quot;)
            } else {
                print(&quot;ACCESS DENIED&quot;)
            }
            // 输出 &quot;Welcome!&quot;
    逻辑运算符组合计算
        范例
            if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {
                print(&quot;Welcome!&quot;)
            } else {
                print(&quot;ACCESS DENIED&quot;)
            }
            // 输出 &quot;Welcome!&quot;
    使用括号来明确优先级
        范例
            if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {
                print(&quot;Welcome!&quot;)
            } else {
                print(&quot;ACCESS DENIED&quot;)
            }
            // 输出 &quot;Welcome!&quot;
</code></pre><h2 id="字符串和字符-StringsandCharacters"><a href="#字符串和字符-StringsandCharacters" class="headerlink" title="字符串和字符(StringsandCharacters)"></a>字符串和字符(StringsandCharacters)</h2><pre><code>概述
    String 是一个 Character 的有序集合。
    String 可通过 + 符号连接。
    Swift 的 String 类型与 Foundation NSString 类进行了无缝桥接。

字符串字面量
    说明
        字符串字面量是由双引号 ( &quot;&quot; ) 包裹着的具 有固定顺序的文本字符集。 字符串字面量可以用于为常量和变量提供初始值。
    范例
        let someString = &quot;Some string literal value&quot;

初始化空字符串
    说明
        要创建一个空字符串作为初始值,可以将空的字符串字面量赋值给变量。
        也可以初始化一个新的 String 实例。
    范例
        字面量初始化
            var emptyString = &quot;&quot;
        String实例初始化
            var anotherEmptyString = String()
        判断是否为空
            if emptyString.isEmpty {
                print(&quot;Nothing to see here&quot;)
            }

字符串可变性
    说明
        您可以通过将一个特定字符串分配给一个变量来对其进行修改。
        也可以分配给一个常量来保证其不会被修改。
    范例
        可修改
            var variableString = &quot;Horse&quot;
            variableString += &quot; and carriage&quot;
        不可修改
            let constantString = &quot;Highlander&quot;
            constantString += &quot; and another Highlander&quot;
            // 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。

字符串是值类型
    说明
        Swift 的 String 类型是值类型。 
        当其进行常量、变量赋值操作,或在函数方法中传递时,会进行值拷贝。

使用字符
    说明
        可通过 for-in 循环来遍历字符串中每一个字符的值
        可通过 Character 类型创建一个字符的常量或变量
        可通过传递一个值类型为 Character 的数组作为自变量来初始化
    范例
        遍历
            for character in &quot;Dog!?&quot;.characters {
                print(character)
            }
        创建Character类型常量
            let str: Character = &quot;!&quot;
        通过Character数组初始化
            let charArr: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]
            let str = String(charArr)

连接字符串和字符
    说明
        字符串可以通过加法运算符( + )相加在一起(或称“连接”)创建一个新的字符串
        可以用 append() 方法将一个字符附加到一个字符串变量的尾部
    范例
        通过+连接
            let string1 = &quot;hello&quot;
            let string2 = &quot; there&quot;
            var welcome = string1 + string2
        通过+=连接
            var instruction = &quot;look over&quot;
            instruction += &quot; there&quot;
        通过append连接
            var str = &quot;hello world&quot;
            str.append(Character(&quot;!&quot;))

字符串插值
    说明
        字符串插值是一种构建新字符串的方式,可以在其中包含常量、变量、字面量和表达式。 您插入的字符串字面量 的每一项都在以反斜线为前缀的圆括号中。
        写在括号中的表达式不能包含非转义反斜杠 \ ,并且不能包含回车或换行符。
    范例
        let food = &quot;apples&quot;
        let num = 3
        let str = &quot;I eat \(num * 3) \(food)&quot;

Unicode
    说明
        Swift 的 String 类型是基于 Unicode 标量建立的。
        Unicode 码位的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF。
        Unicode 标量不包括 Unicode 代理项码位,其码位范围是 U+D800 到 U+DFFF。
        Unicode 标量,写成 \u{n}, n 为任意一到八位十六进制数且可用的Unicode位码。
        每一个 Swift 的 Character 类型代表一个可扩展的字形群。
    特殊字符
        \0 (空字符)
        \\ (反斜线)
        \t (水平制表符)
        \n (换行符)
        \r (回车符)
        \&quot; (双引号)
        \&apos; (单引号)
    范例
        let dollarSign = &quot;\u{24}&quot;        // $, Unicode 标量 U+0024
        let blackHeart = &quot;\u{2665}&quot;      // ?, Unicode 标量 U+2665
        let sparklingHeart = &quot;\u{1F496}&quot; // ?, Unicode 标量 U+1F496
        let eAcute: Character = &quot;\u{E9}&quot; // é
        let combinedEAcute: Character = &quot;\u{65}\u{301}&quot; // é

计算字符数量
    说明
        可以使用字符串的 characters 属性的 count 属性获取字符串的长度
    范例
        let str = &quot;Hello World!&quot;
        let num = str.characters.count

访问和修改字符串
    说明
        不同的字符可能会占用不同数量的内存空间。
        要知道 Character 的确定位置,必须从String开头遍历每一个Unicode标量直到结尾。
        因此 Swift 的字符串不能用整数(integer)做索引。
        试图获取越界索引对应的 Character ,将引发一个运行时错误
    属性
        startIndex    获取字符串第一个字符的索引
        endIndex      获取字符串最后一个字符的索引
    对象方法
        str.startIndex.predecessor()    得到前面一个索引
        str.endIndex.predecessor()      得到后面一个索引
        str.startIndex.advancedBy()     获取指定位字符的索引
        str.characters.indices          创建一个包含全部索引的范围(Range)
        str.insert()                    插入单个字符
        str.insertContentsOf()          插入字符串
        str.removeAtIndex()             删除指定索引的字符
        str.removeRange()               删除指定索引的字符串
    范例
        通过索引获取字符
            let str = &quot;Hello World!&quot;
            str.startIndex                      //0
            str.endIndex                        //12
            str[str.endIndex.predecessor()]     //!
            str[str.startIndex.successor()]     //H
            str[str.startIndex.advancedBy(4)]   //0
        遍历
            for index in str.characters.indices {
                print(str[index])
            }
        插入字符
            var str = &quot;Hello&quot;
            str.insert(&quot;!&quot;, atIndex: str.endIndex)
        插入字符串
            var str = &quot;Hello&quot;
            str.insertContentsOf(&quot; World!&quot;.characters, at: str.endIndex)
        删除字符
            var str = &quot;Hello World!&quot;
            str.removeAtIndex(str.startIndex)
        删除字符串
            var str = &quot;Hello World!&quot;
            str.removeRange(str.startIndex ..&lt; str.startIndex.advancedBy(4))

比较字符串
    说明
        Swift提供了三种方式来比较文本值:字符串字符相等、前缀相等和后缀相等。
        可用 ( == ) 和 ( != ) 来判断字符串字符相等
        字符串的hasPrefix/hasSuffix方法可判断是否拥有指定前缀或后缀
    范例
        字符串字符相等
            var str1 = &quot;Hello&quot;
            var str2 = &quot;Hello&quot;
            print(str1 == str2)      //true
        可扩展字符集相等
            let str1 = &quot;caf\u{E9}?&quot;
            let str2 = &quot;caf\u{65}\u{301}?&quot;
            print(str1 == str2)      //true
        判断前缀
            var str = &quot;Hello World!&quot;
            print(str.hasPrefix(&quot;Hello&quot;))   //true
        判断后缀
            var str = &quot;Hello World!&quot;
            print(str.hasSuffix(&quot;World!&quot;))  //true

字符串的 Unicode 表示形式
    说明
        可通过遍历 String 的 utf8 和 utf16 属性来访问它的 UTF-8 和 UTF-16 表示
        可通过遍历 String 值的 unicodeScalars 属性来访问它的 Unicode 标量表示
    范例
        访问UTF-8表示
            let str = &quot;ABC&quot;;
            for codeUnit in str.utf16 {
                print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
            }
        访问UTF-16表示
            let str = &quot;ABC&quot;;
            for codeUnit in str.utf16 {
                print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)
            }
        访问Unicode标量表示
            let str = &quot;ABC&quot;;
            for scalar in str.unicodeScalars {
                print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)
            }
</code></pre><h2 id="集合类型-CollectionTypes"><a href="#集合类型-CollectionTypes" class="headerlink" title="集合类型(CollectionTypes)"></a>集合类型(CollectionTypes)</h2><pre><code>集合的类型
    Swift提供Arrays,Sets,Dictionaries三种基本的集合类型用来存储集合数据。
    数组(Arrays)是有序数据的集。
    集合(Sets)是无序无重复数据的集。
    字典(Dictionaries)是无序的键值对的集。
    Swift的Arrays,Sets,Dictionaries类型被实现为泛型集合。
    Swift的Arrays,Sets,Dictionaries中存储的数据值类型必须明确。

集合的可变性
    如果创建一个Arrays,Sets或Dictionaries并分配成一个变量，这个集合将是可变的
    我们 可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小
    如果我们把 Arrays，Sets或Dictionaries分配成常量，那么它就是不可变的。

数组(Arrays)
    语法
        写 Swift 数组应该遵循像 Array&lt;Element&gt; 这样的形式。
        其中 Element 是这个数组中唯一允许存在的数据类型。
        我们也可以使用像 [Element] 这样的简单语法。
    创建空数组
        说明
            我们可以使用构造语法来创建一个由特定数据类型构成的空数组
            如果代码上下文中已经提供了类型信息，我们可以使用空数组语句创建一个空数组
        范例
            构造语法
                var someInts = [Int]()
            空数组语句
                someInts.append(3)
                // someInts 现在包含一个 Int 值
                someInts = []
                // someInts 现在是空数组，但是仍然是 [Int] 类型的。
    创建带有默认值的数组
        说明
            Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。
            可以把数组元素的数量count和初始值repeatedValue传入数组构造函数。
        范例
            var arr = [Double](repeating:0.0, count: 3)
            // arr 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]
    通过两个数组相加创建一个数组
        说明
            我们可以使用加法操作符( + )来组合两种已存在的相同类型数组
            新数组的数据类型会被从两个数组的数据类型中推断出来
        范例
            var arr1 = [Double](repeating:0.0, count: 3)
            var arr2 = Array(repeating: 2.5, count: 3)
            var arr = arr1 + arr2
            print(arr) //[0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
    用字面量构造数组
        说明
            字面量是一系列由逗号分割并由方括号包含的数值
            格式为[value 1, value 2, value 3]
            由于类型推断机制，用字面量构造只拥有相同类型值数组的时候，可省略类型
            使用( += )也可以直接在数组后面添加一个或多个拥有相同类型的数
        范例
            方式一
                var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]
            简写
                var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]
    访问和修改数组
        说明
            可以直接使用下标语法来获取数组中的数据
            可以用下标来改变某个已有索引值对应的数据值
            可以利用下标来一次改变一系列数据值
            不可以用下标访问的形式去在数组尾部添加新项
        属性
            count               访问数组中元素的数量
            isEmpty             判断数组是否为空
        方法
            append              在数组后面添加新的数据项
            insert              在某个具体索引值之前添加数据项
            removeAtIndex       移除数组中的某项,返回移除的元素
            removeLast          把数组中的最后一项移除
        范例
            var arr = [&quot;Eggs&quot;, &quot;Milk&quot;]
            arr.append(&quot;Flour&quot;);
            arr += [&quot;Cheese&quot;, &quot;Butter&quot;]
            arr[4] = &quot;Chocolate&quot;
            arr[3...4] = [&quot;Bananas&quot;, &quot;Apples&quot;]
            arr.insert(&quot;Syrup&quot;, at: 4)
            arr.remove(at: 4)
    数组的遍历
        说明
            我们可以使用 for-in 循环来遍历所有数组中的数据项
            如果同时需要值和索引，可以使用 enumerate() 方法来进行数组遍历
        范例
            var arr = [&quot;Eggs&quot;, &quot;Milk&quot;,&quot;Cheese&quot;, &quot;Butter&quot;,&quot;Bananas&quot;]
            for item in arr {
                print(item)
            }
            for (index,value) in arr.enumerated() {
                print(&quot;\(index):\(value)&quot;)
            }

集合
    说明
        集合(Set)用来存储相同类型并且没有确定顺序的值。
        当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。
    集合类型的哈希值
        一个类型为了存储在集合中，该类型必须是可哈希化的(提供计算hash的方法)
        哈希值是Int类型的，相等的对象哈希值必须相同。
        Swift的所有基本类型 String,Int,Double,Bool 默认都是可哈希化的
        这些基本类型可以作为集合的值的类型或者字典的键的类型。
        没有关联值的枚举成员值默认也是可哈希化的。
        可以使用自定义的类型(遵守Hashable协议)作为集合的值的类型或者是字典的键的类型
    创建和构造一个空的集合
        说明
            Set 类型被写为 Set&lt;Element&gt;, Element 表示 Set 中允许存储的类型
            和数组不同的，集合没有等价的简化形式
            如果上下文提供了类型信息，我们可以通过一个空的数组字面量创建一个空的Set 
        范例
            var letters = Set&lt;Character&gt;()
            letters.insert(&quot;A&quot;)
            letters = []
    用数组字面量创建集合
        说明
            Set类型不能从数组字面量中被单独推断出来，因此Set必须显式声明
            因类型推断功能，Set内部元素的类型可以省略
        范例
            var genres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
            var genres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
    访问和修改一个集合
        属性
            count               访问数组中元素的数量
            isEmpty             判断数组是否为空
        方法
            insert              插入新的元素
            remove              移除指定的元素
            removeAll           删除所有元素 
            contains            检查Set中是否包含特定的值
            sort                对集合排序，返回一个排序后的数组
    遍历一个集合
        说明
            你可以在一个 for-in 循环中遍历一个 Set 中的所有值。
        范例
            var genres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
            for genre in genres {
                print(&quot;\(genre)&quot;)
            }
    集合操作
        说明
            可以高效地完成 Set的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集 合是否全包含，部分包含或者不相交。
        方法
            union          根据两个集合的值创建一个新的集合
            intersection   方法根据两个集合中都包含的值创建的一个新的集合
            subtract       移除指定集合中存在的元素，改变原有集合
            exclusiveOr    排除两个集合共有的元素创建一个新集合
        范例
            var oddDigits: Set = [1, 3, 5, 7, 9]
            let evenDigits: Set = [0, 2, 4, 6, 8]
            let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
            print(oddDigits.union(evenDigits).sorted())
            // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            print(oddDigits.intersection(evenDigits).sorted())
            // []
            oddDigits.subtract(singleDigitPrimeNumbers)
            print(oddDigits.sorted())
            // [9, 1]
            print(evenDigits.symmetricDifference(singleDigitPrimeNumbers).sorted())
            // [0, 3, 4, 5, 6, 7, 8]
    集合成员关系和相等
        方法
            isSubset             一个集合中的值是否也被包含在另外一个集合中
            isSupersetOf         一个集合是否包含另外一个集合中的所有元素
            isStrictSubsetOf     一个集合是否是另外一个集合的子集合
            isStrictSupersetOf   一个集合是否是另外一个集合的父集合
            isDisjointWith       两个集合是否不含有相同的值。
        范例
            var a: Set = [1,2,3,4,5]
            var b: Set = [2,3]
            var c: Set = [5,6,7]
            print(b.isSubset(of: a))
            //true
            print(a.isSuperset(of: b));
            //true
            print(b.isStrictSubset(of: a));
            //true
            print(a.isStrictSuperset(of: b));
            //true
            print(a.isDisjoint(with: c));
            //false

字典
    说明
        字典是一种存储多个相同类型的值的容器。
        每个值(value)都关联唯一的键(key)，键作为字典中的这个值数据的标识符。
        Swift 的字典使用 Dictionary&lt;Key, Value&gt; 定义。
        也可以用 [Key: Value] 这样快捷的形式去创建一个字典类型。
    创建一个空字典
        说明
            如果上下文已经提供了类型信息，我们可以使用字面量来创建一个空字典
        范例
            构造语法创建
                var namesOfIntegers = [Int: String]()
                //它的键是 Int 型，值是 String 型
                namesOfIntegers[16] = &quot;sixteen&quot;
                // namesOfIntegers 现在包含一个键值对
                namesOfIntegers = [:]
                // namesOfIntegers 又成为了一个 [Int: String] 类型的空字典
            字面量创建字典
                var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
            简写
                var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]
    访问和修改字典
        说明
            可使用下标语法来添加或修改数据
            可通过赋值nil来移除键值对
        属性
            count                获取字典数据项的数量
            isEmpty              监测字典数据是否为空
        方法
            updateValue          修改或设置数据，并返回原数据
        范例
            添加
                var dict = [&quot;a&quot;:1,&quot;b&quot;:2]
                dict[&quot;c&quot;] = 3
            修改
                dict[&quot;b&quot;] = 4
            移除
                dict[&quot;b&quot;] = nil
    字典遍历
        说明
            可通过 for-in 循环来遍历某个字典中的键值对
            可通过 keys 和 values 属性单独便利key或value
            可使用 keys 和 values 属性构造数组
        范例
            遍历字典
                var dict = [&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3]
                for (key, value) in dict {
                    print(&quot;\(key): \(value)&quot;)
                }
            遍历key
                for key in dict.keys {
                    print(key)
                }
            遍历value
                for value in dict.values {
                    print(value)
                }
            构造数组
                var valueArr = [Int](dict.values)
                var keyArr = [String](dict.keys)
</code></pre><h2 id="控制流-ControlFlow"><a href="#控制流-ControlFlow" class="headerlink" title="控制流(ControlFlow)"></a>控制流(ControlFlow)</h2><pre><code>For循环
    范例  
        for var index = 0; index &lt; 3; ++index {
            print(&quot;index is \(index)&quot;)
        }

For-In
    说明
        循环对一个集合里面的每个元素执行一系列语句
        不需要知道具体值，可使用下划线( _ )替代变量名来忽略对值的访问
    范例
        乘法表
            for index in 1...5 {
                print(&quot;\(index) times 5 is \(index * 5)&quot;)
            }
        忽略值访问（计算3的次幂）
            let base = 3
            let power = 10
            var answer = 1
            for _ in 1...power {
                answer *= base
            }
        遍历数组
            let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]
            for name in names {
                print(&quot;Hello, \(name)!&quot;)
            }
        遍历字典
            let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]
            for (animalName, legCount) in numberOfLegs {
                print(&quot;\(animalName)s have \(legCount) legs&quot;)
            }

While循环
    说明
        while 循环运行一系列语句直到条件变成 false 。
        这类循环适合使用在第一次迭代前迭代次数未知的情况下。
        Swift 提供两种 while 循环形式: while 和 repeat-while
        repeat-while 和 while 的区别是在判断循环条件之前。
        repeat-while先执行一次循环的代码 块，然后重复循环直到条件为 false 。
    while格式
        while condition {
            statements
        }
    repeat-while格式
        repeat {
            statements
        } while condition

if
    说明
        if语句的 else if 和 else 是可选的
    格式
        if condition {
            statements
        } else if condition {
            statements
        } else {
            statements
        }

switch
    说明
        在switch中，当匹配的 case 分支中的代码执行完毕后，程序会终止 switch 语句。
        不需要在 case 分支中显式地使用 break 语句。
        每一个 case 分支都必须包含至少一条语句。
        一个 case 也可以包含多个模式，用逗号把它们分开。
        可以使用元组在同一个switch语句中测试多个值。下划线_匹配所有可能的值。
        case分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了，这种行为被称为值绑定(value binding)。
        case分支的模式可以使用 where 语句来判断额外的条件。
        如果需要C风格的贯穿的特性，可在每个需要该特性的case分支中使用fallthrough关键字
    范例
        匹配多个模式
            var str = &quot;B&quot;;
            switch str {
            case &quot;A&quot;,&quot;B&quot;:
                print(&quot;A or B&quot;)
            default:
                print(&quot;other&quot;)
            }
        区间匹配
            let num = 60
            switch num {
            case 0:
                print(0)
            case 1..&lt;10:
                print(&quot;大于等于1小于10&quot;)
            case 10..&lt;60:
                print(&quot;大于等于10小于60&quot;)
            case 60..&lt;100:
                print(&quot;大于等于60小于100&quot;)
            default:
                print(&quot;大于等于100&quot;)
            }
        通过元祖匹配多个值
            let somePoint = (1, 1)
            switch somePoint {
            case (0, 0):
                print(&quot;(0, 0) is at the origin&quot;)
            case (_, 0):
                print(&quot;(\(somePoint.0), 0) is on the x-axis&quot;)
            case (0, _):
                print(&quot;(0, \(somePoint.1)) is on the y-axis&quot;)
            case (-2...2, -2...2):
                print(&quot;(\(somePoint.0), \(somePoint.1)) is inside the box&quot;)
            default:
                print(&quot;(\(somePoint.0), \(somePoint.1)) is outside of the box&quot;)
            }
            // 输出 &quot;(1, 1) is inside the box&quot;
        值绑定
            let anotherPoint = (2, 0)
            switch anotherPoint {
            case (let x, 0):
                print(&quot;on the x-axis with an x value of \(x)&quot;)
            case (0, let y):
                print(&quot;on the y-axis with a y value of \(y)&quot;)
            case let (x, y):
                print(&quot;somewhere else at (\(x), \(y))&quot;)
            }
            // 输出 &quot;on the x-axis with an x value of 2&quot;
        where制定条件
            let point = (1, -1)
            switch point {
            case let (x, y) where x == y:
                print(&quot;(\(x), \(y)) is on the line x == y&quot;)
            case let (x, y) where x == -y:
                print(&quot;(\(x), \(y)) is on the line x == -y&quot;)
            case let (x, y):
                print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)
            }
            // 输出 &quot;(1, -1) is on the line x == -y&quot;
        贯穿
            let integerToDescribe = 5
            var description = &quot;The number \(integerToDescribe) is&quot;
            switch integerToDescribe {
            case 2, 3, 5, 7, 11, 13, 17, 19:
                description += &quot; a prime number, and also&quot;
                fallthrough
            default:
                description += &quot; an integer.&quot;
            }
            print(description)
            // 输出 &quot;The number 5 is a prime number, and also an integer.&quot;

控制转移语句(Control Transfer Statements)
    说明
        Swift有五种控制转移语句:continue,break,fallthrough,return,throw
    Continue
        continue告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。
        通过标签显式指明continue语句想要影响嵌套的哪一个循环体。
    Break
        break 语句会立刻结束整个控制流的执行。
        当想要结束一个switch代码块或者一个循环时，可使用break语句。
        当在一个循环体中使用 break 时，会立刻中断跳出循环。
        当在一个switch代码块中使用break 时会立即中断该switch代码块的执行。
        通过标签可指明 break 语句 想要终止的是哪个循环体或者 switch 代码块。
    标签格式
        label name: while condition {
             statements
        }

提前退出
    说明
        与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。
        与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。
        你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。
    范例
        func fooGuard(x: Int?) {
            guard let x = x where x &gt; 0 else {
                // 变量不符合条件判断时，执行下面代码
                return
            }
            // 使用x
        }

检测API可用性
    说明
        Swift 有检查 API 可用性的内置支持。
        这可以确保我们不会不小心地使用对于当前部署目标不可用的API。
    格式
        if #available(platform name version, ..., *) {
            statements to execute if the APIs are available
        } else {
            fallback statements to execute if the APIs are unavailable
        }
    范例
        if #available(iOS 9, OSX 10.10, *) {
        // 在 iOS 使用 iOS 9 的 API, 在 OS X 使用 OS X v10.10 的 API
        } else {
        // 使用先前版本的 iOS 和 OS X 的 API
        }
</code></pre><h2 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数(Functions)"></a>函数(Functions)</h2><pre><code>函数定义与调用
    说明
        函数定义以 func 作为前缀
        用返回箭头 -&gt; 指定函数返回类型
    范例
        参数为String，返回值为String
            func sayHello(personName: String) -&gt; String {
                 let greeting = &quot;Hello, &quot; + personName + &quot;!&quot;
                 return greeting
            }
            print(sayHello(personName: &quot;Jack&quot;))

函数参数与返回值
    范例
        无参函数
            func sayHelloWorld() -&gt; String {
                return &quot;hello, world&quot;
            }
            print(sayHelloWorld())
        多参函数
            func sum(a:Int,b:Int)-&gt;Int{
                return a + b;
            }
            print(sum(a: 1, b: 2));
        无返回值函数
            func sayGoodbye(personName: String) {
                print(&quot;Goodbye, \(personName)!&quot;)
            }
            sayGoodbye(&quot;Dave&quot;)
        返回多个值
            func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
                var currentMin = array[0]
                var currentMax = array[0]
                for value in array[1..&lt;array.count] {
                    if value &lt; currentMin {
                        currentMin = value
                    } else if value &gt; currentMax {
                        currentMax = value
                    } }
                return (currentMin, currentMax)
            }
            let bounds = minMax([8, -6, 2, 109, 3, 71])
            print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
            // prints &quot;min is -6 and max is 109&quot;
        可选元组返回类型
            func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {
                if array.isEmpty { return nil }
                var currentMin = array[0]
                var currentMax = array[0]
                for value in array[1..&lt;array.count] {
                    if value &lt; currentMin {
                        currentMin = value
                    } else if value &gt; currentMax {
                        currentMax = value
                    }
                }
                return (currentMin, currentMax)
            }
            if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
                print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)
            }
            // prints &quot;min is -6 and max is 109&quot;

函数参数名称
    说明
        函数参数都有一个外部参数名和一个局部参数名。
        外部参数名用于在函数调用时标注传递给函数的参数，局部参数名在函数的实现内部使用。
        可用一个下划线( _ )忽略外部参数名
        所有参数必须有独一无二的局部参数名。
        可变参数可以接受零个或多个值。通过在变量类型名后面加入(...)来定义可变参数。
        如果函数有一个或多个带默认值的参数，而且还有一个可变参数，虚把可变参数放在最后。
        函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。
        但可以指定变量参数，通过在参数名前加关键字 var 来定义变量参数(swift3中取消)
        var的修改会在函数结束后消失，inout会将修改后的值回写到原始地址中
    范例
        指定外部参数名
            func sayHello(to person: String, and anotherPerson: String) -&gt; String {
                return &quot;Hello \(person) and \(anotherPerson)!&quot;
            }
            print(sayHello(to: &quot;Bill&quot;, and: &quot;Ted&quot;))
            // prints &quot;Hello Bill and Ted!&quot;
        忽略外部参数名
            func someFunction(_ firstNumber: Int, _ secondNumber: Int) {
            }
            someFunction(1, 2)
        默认参数值
            func someFunction(_ parameterWithDefault: Int = 12) {
            }
            someFunction(6)
            someFunction()
        可变参数
            func arithmeticMean(numbers: Double...) -&gt; Double {
                var total: Double = 0
                for number in numbers {
                    total += number
                }
                return total / Double(numbers.count)
            }
            arithmeticMean(numbers: 1,2,3,4,5)
            // returns 3.0
        变量参数(swift3中取消)
            func appendStr(var str:String){
                str += &quot;C&quot;
                print(str)
            }
            appendStr(str: &quot;AB&quot;)
        输入输出参数
            func swapTwoInts(_ a: inout Int,_ b: inout Int) {
                let temporaryA = a
                a = b
                b = temporaryA
            }
            var a = 1;
            var b = 2;
            swapTwoInts(&amp;a, &amp;b);
            print(a)

函数类型
    说明
        可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它
        函数类型作为另一个函数的返回类型。可在返回箭头( -&gt; )后写一个完整的函数类型
    范例
        使用函数类型
            func addTwoInts(a: Int, _ b: Int) -&gt; Int {
                return a + b
            }
            var mathFunction: (Int, Int) -&gt; Int = addTwoInts
            print(&quot;Result: \(mathFunction(2, 3))&quot;)
            // prints &quot;Result: 5&quot;
        使用函数类型简写
            var mathFunction = addTwoInts
        函数作为参数
            func addTwoInts(_ a: Int, _ b: Int) -&gt; Int {
                return a + b
            }
            func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {
                print(&quot;Result: \(mathFunction(a, b))&quot;)
            }
            printMathResult(addTwoInts, 3, 5)
            // prints &quot;Result: 8&quot;
        函数类型作为返回类型
            func stepForward(_ input: Int) -&gt; Int {
                return input + 1
            }
            func stepBackward(_ input: Int) -&gt; Int {
                return input - 1
            }
            func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
                return backwards ? stepBackward : stepForward
            }
            var currentValue = 3
            print(chooseStepFunction(backwards: currentValue &gt; 0))

嵌套函数
    说明
        定义在其他函数内的函数称为嵌套
        默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数调用。
        一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。
    范例
        func chooseStepFunction(_ backwards: Bool) -&gt; (Int) -&gt; Int {
            func stepForward(input: Int) -&gt; Int { return input + 1 }
            func stepBackward(input: Int) -&gt; Int { return input - 1 }
            return backwards ? stepBackward : stepForward
        }
        var currentValue = -4
        let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
        currentValue = moveNearerToZero(currentValue)
        print(currentValue)
</code></pre><h2 id="闭包-Closures"><a href="#闭包-Closures" class="headerlink" title="闭包(Closures)"></a>闭包(Closures)</h2><pre><code>说明
    闭包是自包含的函数代码块，可以在代码中被传递和使用。
    Swift 中的闭包与 C 和 Objective-C 中的blocks或匿名函数比较相似。
    闭包可以捕获和存储其所在上下文中任意常量和变量的引用。
    这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。
    Swift 会为您管理在捕获过程中涉及到的所有内存操作
    全局函数是一个有名字但不会捕获任何值的闭包
    嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包
    闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包

闭包表达式(Closure Expressions)
    说明
        闭包表达式语法可以使用常量、变量和 inout 类型作为参数，不能提供默认值。
        也可以在参数列表的最后使用可 变参数。元组也可以作为参数和返回值。
        闭包的函数体部分由关键字 in 引入。
        in关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。
        可以推断出闭包的参数和返回值类型的时候可以不需要用完整格式构造内联闭包
        单行表达式闭包可以通过省略 return 关键字来隐式返回单行表达式的结果
        在闭包表达式中使用参数名称缩写时可省略参数定义和in关键字
    表达式格式
        { (parameters) -&gt; returnType in
            statements
        }
    范例
        通过闭包表达式排序
            let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
            func backwards(s1: String, s2: String) -&gt; Bool {
                return s1 &gt; s2
            }
            var reversed = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
                return s1 &gt; s2
            })
            print(reversed)
            // reversed 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]
        表达式合并成一行简写
            reversed = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 } )
        根据上下文推断的简写
            reversed = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
        单表达式闭包隐式返回
            reversed = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
        参数名称缩写
            reversed = names.sorted(by: { $0 &gt; $1 } )
        运算符函数
            reversed = names.sorted(by:&gt;)

尾随闭包(Trailing Closures)
    说明
        如需要将一个很长的闭包表达式作为最后函数最后一个参数，可以使用尾随闭包来增强可读性
        尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用
        如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把 () 省略掉
    格式
        func someFunctionThatTakesAClosure(_ closure: () -&gt; Void) {
            // 函数体部分
        }
        // 以下是不使用尾随闭包进行函数调用 
        someFunctionThatTakesAClosure({
            // 闭包主体部分
        })
        // 以下是使用尾随闭包进行函数调用
        someFunctionThatTakesAClosure() {
            // 闭包主体部分
        }
    范例
        尾随闭包
            let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
            var reversed = names.sorted(){ $0 &gt; $1 }
        只有一个参数时省略()
            reversed = names.sorted { $0 &gt; $1 }

值捕获(Capturing Values)
    说明
        闭包可以在其被定义的上下文中捕获常量或变量。
        即使定义这些常量变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值
        可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。
        嵌套函数可 以捕获其外部函数所有的参数以及定义的常量和变量。
        为了优化，如果一个值是不可变的，Swift 可能会改为捕获并保存一份对值的拷贝。 Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。
    范例
        func makeIncrementor(forIncrement amount: Int) -&gt; () -&gt; Int {
            var runningTotal = 0
            func incrementor() -&gt; Int {
                runningTotal += amount
                return runningTotal
            }
            return incrementor
        }
        let incrementByTen = makeIncrementor(forIncrement: 10)
        print(incrementByTen())     // 结果为10
        print(incrementByTen())     // 结果为20
        let incrementBySeven = makeIncrementor(forIncrement: 7)
        print(incrementBySeven())   // 结果为7
        let alsoIncrementByTen = incrementByTen 

闭包是引用类型(Closures Are Reference Types)
    说明
        无论您将函数或闭包赋值给一个常量还是变量,
        实际上都是将常量或变量的值设置为对应函数或闭包的引用
        如果将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包
    范例
        接上面例子
            print(alsoIncrementByTen())
            // 返回的值为30

非逃逸闭包(Nonescaping Closures)
    说明
        作为函数参数的闭包在函数执行完成后执行，称该闭包从函数中逃逸。
        定义函数时，可在作为参数的闭包后加@escaping 用来指明允许逃逸出此函数。
        Swift 3 中默认事是不允许逃逸的。Swift 2 中则相反，需要加 @noescaping
        @noescape 能使编译器知道这个闭包的生命周期，从而可以进行一些比较激进的优化
        例如接收闭包参数作为回调的函数，函数执行后立即返回，但闭包在异步操作完成后才调用
    范例
        在Swift3中设置escaping
            //定义一个元素类型为无参无返回值函数的空数组
            var completionHandlers: [() -&gt; Void] = []
            func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {
                completionHandlers.append(completionHandler)
            }
        noescape的情况下能在闭包中隐式地引用(省略)self
            var completionHandlers: [() -&gt; Void] = []
            func someFunctionWithEscapingClosure(_ completionHandler: @escaping () -&gt; Void) {
                completionHandlers.append(completionHandler)
            }
            func someFunctionWithNoescapeClosure(_ closure: () -&gt; Void) {
                closure()
            }
            class SomeClass {
                var x = 10
                func doSomething() {
                    someFunctionWithEscapingClosure { self.x = 100 }
                    someFunctionWithNoescapeClosure { x = 200 }
                }
            }
            let instance = SomeClass()
            instance.doSomething()
            print(instance.x)
            // prints &quot;200&quot;
            completionHandlers.first?()
            print(instance.x)
            // prints &quot;100&quot;

自动闭包(Autoclosures)
    说明
        自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。
        这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。
        这种便利语法让你能够用一个普通的表达式来代替显式的闭包，从而省略闭包的花括号。
        通过在参数后加@autoclosure来接收一个自动闭包
        如果闭包可以逃逸，可以和 @escaping 联用
    范例
        闭包延迟执行
            var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
            print(customersInLine.count)
            // prints &quot;5&quot;
            let customerProvider = { customersInLine.remove(at: 0) }
            print(customersInLine.count)
            // prints &quot;5&quot;
            print(&quot;Now serving \(customerProvider())!&quot;)
            // prints &quot;Now serving Chris!&quot;
            print(customersInLine.count)
            // prints &quot;4&quot;
        把闭包作为参数实现延迟执行
            var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
            func serveCustomer(customerProvider: () -&gt; String) {
                print(&quot;Now serving \(customerProvider())!&quot;)
            }
            serveCustomer( customerProvider: { customersInLine.remove(at: 0) } )
            // prints &quot;Now serving Alex!&quot;
        自动闭包
            var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]
            func serveCustomer( customerProvider: @autoclosure () -&gt; String) {
                print(&quot;Now serving \(customerProvider())!&quot;)
            }
            serveCustomer(customerProvider: customersInLine.remove(at: 0))
            // prints &quot;Now serving Chris!&quot;
</code></pre><h2 id="枚举-Enumerations"><a href="#枚举-Enumerations" class="headerlink" title="枚举(Enumerations)"></a>枚举(Enumerations)</h2><pre><code>说明
    C语言中，枚举会为一组整型值分配相关联的名称。
    Swift中的枚举更加灵活，不必给每一个枚举成员提供一个值。
    如果给枚举成员提供一个值(原始值），该值的类型可以是字符串，字符，整型值或浮点数。
    枚举成员可以指定任意类型的关联值存储到枚举成员中。
    每一个枚举成员都可以有适当类型的关联值。
    枚举类型是一等(first-class)类型。
    它们采用了很多在传统上只被类(class)所支持的特性。
    例如计算型属性(computed properties)，用于提供枚举值的附加信息，
    实例方法(instance method s)，用于提供和枚举值相关联的功能。
    枚举也可以定义构造函数(initializers)来提供一个初始值;
    可以在原始实现的基础上扩展它们的功能;
    还可以遵守协议(protocols)来提供标准的功能。

枚举语法
    说明
        用 enum 关键词来创建枚举并且把它们的整个定义放在一对大括号内。
        使用 case 关键字来 定义一个新的枚举成员值。
        多个成员值可以出现在同一行上，用逗号隔开。
        可用点语法给变量赋值。
        变量类型已知时，再次为其赋值可以省略枚举类型名
        与 C 和 OC 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。
        枚举成员本身就是完备的值，这些值的类型是已经明确定义好的(枚举名)类型。
    格式
        enum SomeEnumeration {
            // 枚举定义放在这里
        }
    范例
        枚举表示四个方向
            enum CompassPoint {
                case North
                case South
                case East
                case West
            }
        多个成员
            enum Planet {
                 case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
            }
        给变量赋值
            var directionToHead = CompassPoint.West
        省略枚举类型名
            var directionToHead = CompassPoint.West
            directionToHead = .East

使用Switch语句匹配枚举值
    说明
        在判断一个枚举类型的值时，switch语句必须穷举所有情况。
        不需要匹配每个枚举成员的时候，你可以提供一个default分支来处理其他成员。
    范例
        enum CompassPoint {
            case North, South, East, West
        }
        var directionToHead = CompassPoint.West
        directionToHead = .South
        switch directionToHead {
        case .North:
            print(&quot;Lots of planets have a north&quot;)
        case .South:
            print(&quot;Watch out for penguins&quot;)
        case .East:
            print(&quot;Where the sun rises&quot;)
        case .West:
            print(&quot;Where the skies are blue&quot;)
        }

关联值
    说明
        关联值可以连同成员值一起存储额外的自定义信息。
        每次在代码中使用该枚举成员时，还可以修改这个关联值。
        可以定义枚举来存储任意类型的关联值，每个枚举成员的关联值类型可以各不相同。
        可以在Switch中提取每个关联值作为一个常量或者变量来使用。
        如果一个枚举成员的所有关联值都被提取为常量或变量，可只在成员名称前标注let或var。
    范例
        定义和赋值
            enum Barcode {
                case UPCA(Int, Int, Int, Int)
                case QRCode(String)
            }
            var productBarcode = Barcode.UPCA(8, 85909, 51226, 3)
            productBarcode = .QRCode(&quot;ABCDEFGHIJKLMNOP&quot;)
        在Switch中提取值
            switch productBarcode {
            case .UPCA(let numberSystem, let manufacturer, let product, let check):
                print(&quot;UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
            case .QRCode(let productCode):
                print(&quot;QR code: \(productCode).&quot;)
            }
        在Switch中提取值简写
            switch productBarcode {
            case let .UPCA(numberSystem, manufacturer, product, check):
                print(&quot;UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)
            case let .QRCode(productCode):
                print(&quot;QR code: \(productCode).&quot;)
            }

原始值
    说明
        枚举成员可以被默认值(称为原始值)预填充，这些原始值的类型必须相同。
        原始值可以是字符串，字符，整型或浮点型。每个原始值在枚举声明中必须是唯一的。
        原始值为整数或字符时，Swift会自动为枚举赋值。
        当使用整数作为原始值时，隐式赋值的值依次递增1。
        如果第一个枚举成员没有设置原始值，其原始值将为0。
        使用枚举成员的 rawValue 属性可以访问该枚举成员的原始值。
        原始值构造器时并非所有的值都能匹配枚举成员，最终返回的是一个可选的枚举成员。
    原始值和关联值区别
        原始值是在定义枚举时被预先填充的值，对于一个特定的枚举成员，它的原始值始终不变。
        关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。
    范例
        定义
            enum ASCIIControlCharacter: Character {
                case Tab = &quot;\t&quot;
                case LineFeed = &quot;\n&quot;
                case CarriageReturn = &quot;\r&quot;
            }
        隐式赋值
             enum Planet: Int {
                 case Mercury = 1, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune
            }
        使用字符串类型的原始值
            enum CompassPoint: String {
                case North, South, East, West
            }
        访问枚举原始值
            let earthsOrder = Planet.Earth.rawValue
            // earthsOrder 值为 3
            let sunsetDirection = CompassPoint.West.rawValue
            // sunsetDirection 值为 &quot;West&quot;
        使用原始值初始化枚举实例
            let possiblePlanet = Planet(rawValue: 7)
            // possiblePlanet 类型为 Planet? 值为 Planet.Uranus
        原始值构造器返回的可选值
            let positionToFind = 9
            if let somePlanet = Planet(rawValue: positionToFind) {
                switch somePlanet {
                case .Earth:
                    print(&quot;Mostly harmless&quot;)
                default:
                    print(&quot;Not a safe place for humans&quot;)
                }
            } else {
                print(&quot;There isn&apos;t a planet at position \(positionToFind)&quot;)
            }
            // 输出 &quot;There isn&apos;t a planet at position 9

递归枚举
    说明
        递归枚举(recursive enumeration)是一种枚举类型。
        它有一个或多个枚举成员使用该枚举类型的实例作为关联值。
        使用递归枚举时，编译器会插入一个间接层。
        你可以在枚举成员前加上 indirect 来表示该成员可递归。
    范例
        枚举成员前加indirect
            enum ArithmeticExpression {
                case Number(Int)
                indirect case Addition(ArithmeticExpression, ArithmeticExpression)
                indirect case Multiplication(ArithmeticExpression, ArithmeticExpression)
            }
        枚举类型开头加indirect
             indirect enum ArithmeticExpression {
                 case Number(Int)
                 case Addition(ArithmeticExpression, ArithmeticExpression)
                 case Multiplication(ArithmeticExpression, ArithmeticExpression)
            }
        通过递归枚举来运算
            func evaluate(_ expression: ArithmeticExpression) -&gt; Int {
                switch expression {
                case .Number(let value):
                    return value
                case .Addition(let left, let right):
                    return evaluate(left) + evaluate(right)
                case .Multiplication(let left, let right):
                    return evaluate(left) * evaluate(right)
                }
            }
            // 计算 (5 + 4) * 2
            let five = ArithmeticExpression.Number(5)
            let four = ArithmeticExpression.Number(4)
            let sum = ArithmeticExpression.Addition(five, four)
            let product = ArithmeticExpression.Multiplication(sum, ArithmeticExpression.Number(2))
            print(evaluate(product))
            // 输出 &quot;18&quot;
</code></pre><h2 id="类和结构体-ClassesandStructures"><a href="#类和结构体-ClassesandStructures" class="headerlink" title="类和结构体(ClassesandStructures)"></a>类和结构体(ClassesandStructures)</h2><pre><code>说明
    Swift 并不要求你为自定义类和结构去创建独立的接口和实现文件。
    只需要在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。
    每次定义一个新类或者结构体的时候，实际上你是定义了一个新的类型，建议首字母大写。
    可以用 ( . ) 语法来访问访问实例的属性。
    与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。

类和结构体对比
    共同点
        定义属性用于存储值
        定义方法用于提供功能
        定义附属脚本用于访问值
        定义构造器用于生成初始化值
        通过扩展以增加默认实现的功能
        实现协议以提供某种标准功能
    类相对结构体的其他功能
        继承允许一个类继承另一个类的特征
        类型转换允许在运行时检查和解释一个类实例的类型
        解构器允许一个类实例释放任何其所被分配的资源
        引用计数允许对一个类的多次引用
    类定义语法
        class SomeClass {
            // class definition goes here
        }
    结构体定义语法
        struct SomeStructure {
            // structure definition goes here
        }
    范例
        定义结构体
            struct Resolution {
                var width = 0
                var height = 0
            }
        定义类
            class VideoMode {
                var resolution = Resolution()
                var interlaced = false
                var frameRate = 0.0
                var name: String?
            }
        生成实例
            let someResolution = Resolution()
            let someVideoMode = VideoMode()
        访问属性
            print(someResolution.width)
            print(someVideoMode.resolution.width)
        属性赋值
            someVideoMode.resolution.width = 1280
        结构体成员逐一构造器
            let vga = Resolution(width:640, height: 480)

结构体和枚举是值类型
    说明
        值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。
        所有的基本类型:整数、浮点数、布尔值、字符串、数组和字典都是值类型。
        这些基本类型在底层都是以结构体的形式所实现。
        所有的结构体和枚举类型都是值类型。
        结构体和枚举的实例，及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。
    范例
        struct Resolution {
            var width = 0
            var height = 0
        }
        let hd = Resolution(width: 1920, height: 1080)
        var cinema = hd
        cinema.width = 2048
        print(cinema.width)
        //2048
        print(hd.width)
        //1920

类是引用类型
    说明
        引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。
        因此，引用的是已存在的实例本身而不是其拷贝。
    范例
        struct Resolution {
            var width = 0
            var height = 0
        }
        class VideoMode {
            var resolution = Resolution()
            var interlaced = false
            var frameRate = 0.0
            var name: String?
        }
        let hd = Resolution(width: 1920, height: 1080)
        let tenEighty = VideoMode()
        tenEighty.resolution = hd
        tenEighty.interlaced = true
        tenEighty.name = &quot;1080i&quot;
        tenEighty.frameRate = 25.0
        let alsoTenEighty = tenEighty
        alsoTenEighty.frameRate = 30.0
        print(tenEighty.frameRate)
        //输出30.0
        print(tenEighty === alsoTenEighty)
        //输出true

类和结构体的选择
    当符合下列某个一个或多个条件时，考虑使用结构体
        该数据结构的主要目的是用来封装少量相关简单数据值。
        有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。
        该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。
        该数据结构不需要去继承另一个既有类型的属性或者行为。
    范例
        几何形状的大小，封装一个 width 属性和 height 属性，两者均为 Double 类型。
        一定范围内的路径，封装一个 start 属性和 length 属性，两者均为 Int 类型。
        三维坐标系内一点，封装 x ， y 和 z 属性，三者均为 Double 类型。

字符串、数组、和字典的赋值与复制
    说明
        Swift中许多基本类型，如String,Array,Dictionary类型均以结构体的形式实现。
        这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。
        OC中NSString，NSArray，NSDictionary均以类的形式实现，而并非结构体。
        它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。
</code></pre><h2 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h2><pre><code>说明
    属性将值跟特定的类、结构或枚举关联。
    存储属性存储常量或变量作为实例的一部分，而计算属性计算一个值。
    计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。
    存储属性和计算属性通常与实例关联。但是，属性也可以直接作用于类本身，这种属性称为类型属性。
    可定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。
    属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。

存储属性
    说明
        一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量。
        存储属性可以是变量存储属性，也可以是常量存储属性。
        可以在定义存储属性的时候指定默认值，
        也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。
        把结构体赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性。
        当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。
        把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。
        延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。
        在属性声明前使用 lazy 来标示一个延迟存储属性。
    范例
        修改属性
            struct FixedLengthRange {
                var firstValue: Int
                let length: Int
            }
            var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
            rangeOfThreeItems.firstValue = 6
        常量结构体无法修改属性
            let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
            rangeOfFourItems.firstValue = 6
            // 尽管 firstValue 是个变量属性，这里还是会报错
        延迟存储属性(懒加载)
            class DataImporter {
                var fileName = &quot;data.txt&quot;
                // 这是提供数据导入功能 
            }
            class DataManager {
                lazy var importer = DataImporter()
                var data = [String]()
                // 这是提供数据管理功能
            }
            let manager = DataManager()
            manager.data.append(&quot;Some data&quot;)
            manager.data.append(&quot;Some more data&quot;)
            // DataImporter 实例的 importer 属性还没有被创建
            print(manager.importer.fileName)
            // DataImporter 实例的 importer 属性现在被创建了

计算属性 (getter &amp; setter)
    说明
        除存储属性外，类、结构体和枚举可以定义计算属性。
        计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter。
        用来间接获取和设置其他属性或变量的值。
        setter也可省略参数名称，使用默认名称 newValue。 
        只有 getter 没有 setter 的计算属性就是只读计算属性。
        只读计算属性的声明可以去掉 关键字和花括号。
    范例
        设置getter和setter
            struct Point {
                var x = 0.0, y = 0.0
            }
            struct Size {
                var width = 0.0, height = 0.0
            }
            struct Rect {
                var origin = Point()
                var size = Size()
                var center: Point {
                    get {
                        let centerX = origin.x + (size.width / 2)
                        let centerY = origin.y + (size.height / 2)
                        return Point(x: centerX, y: centerY)
                    }
                    set(newCenter) {
                        origin.x = newCenter.x - (size.width / 2)
                        origin.y = newCenter.y - (size.height / 2)
                    }
                } }
            var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))
            let initialSquareCenter = square.center
            square.center = Point(x: 15.0, y: 15.0)
            print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)
            // 输出 &quot;square.origin is now at (10.0, 10.0)”
        省略setter参数名
            struct AlternativeRect {
                var origin = Point()
                var size = Size()
                var center: Point {
                    get {
                        let centerX = origin.x + (size.width / 2)
                        let centerY = origin.y + (size.height / 2)
                        return Point(x: centerX, y: centerY)
                    }
                    set {
                        origin.x = newValue.x - (size.width / 2)
                        origin.y = newValue.y - (size.height / 2)
                    }
                }
            }
        只读属性
            struct Cuboid {
                var width = 0.0, height = 0.0, depth = 0.0
                var volume: Double {
                    return width * height * depth
                }
            }
            let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
            print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)
            // 输出 &quot;the volume of fourByFiveByTwo is 40.0&quot;

属性观察器
    说明
        属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器。
        新设置的值和旧值相同，同样会调用属性观察器。
        willset 观察器在新的值被设置之前调用, didset 观察器在新的值被设置之后立即调用。
        willSet 观察器会将新的属性值作为常量参数传入。
        在 willSet 的实现代码中可以为这个参数指定一个名称。也可使用默认名称 newValue。
    范例
        class StepCounter {
            var totalSteps: Int = 0 {
                willSet(newTotalSteps) {
                    print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)
                }
                didSet {
                    if totalSteps &gt; oldValue  {
                        print(&quot;Added \(totalSteps - oldValue) steps&quot;)
                    }
                }
            }
        }
        let stepCounter = StepCounter()
        stepCounter.totalSteps = 200
        // About to set totalSteps to 200
        // Added 200 steps

全局变量和局部变量
    说明
        计算属性和属性观察器所描述的模式也可以用于全局变量和局部变量。
        全局变量是在函数、方法、闭包或任何类型之外定义的变量。
        局部变量是在函数、方法或闭包内部定义的变量。
        在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。
        计算型变量跟计算属性一样，返回一个计算的值而不是存储值，声明格式也完全一样。

类型属性
    说明
        实例的属性属于实例，每次类实例化后都拥有自己的一套属性值，实例之间的属性相互独立。
        可以为类本身定义属性，不管类型有多少个实例，这些属性都只有唯一一份。
        类型属性用于定义特定类所有实例共享的数据，就像C中的静态常量和静态变量。
        值类型的存储型类型属性可以是变量或常量。
        计算型类型属性跟实例的计算属性一样只能定义成变量属性。
        跟实例的存储属性不同，必须给存储型类型属性指定默认值。
        存储型类型属性是默认是延迟初始化的(lazily initialized)的，不需要lazy修饰符。
    类型属性语法
        使用关键字 static 来定义类型属性。
        类型属性是作为类型定义的一部分需写在类型最外层的花括号内。
        其作用范围也在类型支持的范围内。
        在为类定义计算型类型属性时，可以使用关键字class来支持子类对父类的实现进行重写。
    范例
        结构体定义类型属性
            struct SomeStructure {
                static var storedTypeProperty = &quot;Some value.&quot;
                static var computedTypeProperty: Int {
                    return 1
                }
            }
        枚举定义类型属性
            enum SomeEnumeration {
                static var storedTypeProperty = &quot;Some value.&quot;
                static var computedTypeProperty: Int {
                    return 6
                }
            }
        类定义类型属性
            class SomeClass {
                static var storedTypeProperty = &quot;Some value.&quot;
                static var computedTypeProperty: Int {
                    return 27
                }
                class var overrideableComputedTypeProperty: Int {
                    return 107
                }
            }
        获取和设置类型属性的值
            print(SomeStructure.storedTypeProperty)
            // 输出 &quot;Some value.&quot; 
            SomeStructure.storedTypeProperty = &quot;Another value.&quot;
            print(SomeStructure.storedTypeProperty)
            // 输出 &quot;Another value.” 
            print(SomeEnumeration.computedTypeProperty)
            // 输出 &quot;6&quot;
            print(SomeClass.computedTypeProperty)
            // 输出 &quot;27&quot;
</code></pre><h2 id="方法-Methods"><a href="#方法-Methods" class="headerlink" title="方法(Methods)"></a>方法(Methods)</h2><pre><code>说明
    方法是与某些特定类型相关联的函数。
    类、结构体、枚举都可以定义实例方法。
    实例方法为给定类型的实例封装了具体的任务与功能。
    类、结构体、枚举也可以定义类型方法。
    类型方法与类型本身相关联。
    类型方法与OC中的类方法(class methods)相似。

实例方法
    说明
        实例方法是属于某个特定类、结构体或者枚举类型实例的方法。
        实例方法的语法与函数完全一致。
        实例方法要写在它所属的类型的前后大括号之间。
        实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。
        实例方法只能被它所属的类的某个特定实例调用。
        方法可局部参数名称和外部参数名称
    self
        类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。
        访问实例中的属性或者方法可也可省略self。参数名和属性名相同时，参数名优先。
    实例方法中修改值类型
        结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改。
        方法前加mutating关键字，可让实例方法内部可修改实力的属性。
        方法内可以给self属性赋值一个全新的实例，新实例在方法结束后将替换原来的实例。
        不能在结构体类型常量上调用可变方法，因为常量的属性不能被改变。
    范例
        定义示例方法
            class Counter {
                var count = 0
                func increment() {
                    self.count += 1
                }
                func incrementBy(_ amount: Int, numberOfTimes: Int) {
                    count += amount * numberOfTimes
                }
                func reset() {
                    count = 0
                }
            }
            let counter = Counter()
            counter.increment()
            // 初始计数值是1
            counter.incrementBy(5, numberOfTimes: 3)
            // 计数值现在是16
            counter.reset()
            // 计数值现在是0
        mutating关键字
            struct Point {
                var x = 0.0, y = 0.0
                mutating func moveByX(x deltaX: Double, y deltaY: Double) {
                    x += deltaX
                    y += deltaY
                }
            }
            var somePoint = Point(x: 1.0, y: 1.0)
            somePoint.moveByX(x: 2.0, y: 3.0)
            print(&quot;The point is now at (\(somePoint.x), \(somePoint.y))&quot;)
            // 打印输出: &quot;The point is now at (3.0, 4.0)&quot;
            let fixedPoint = Point(x: 3.0, y: 3.0)
            fixedPoint.moveByX(2.0, y: 3.0)
            // 这里将会抛出一个错误
        给self赋值
            struct Point {
                var x = 0.0, y = 0.0
                mutating func moveByX(deltaX: Double, y deltaY: Double) {
                    self = Point(x: x + deltaX, y: y + deltaY)
                }
            }
        枚举通过可变方法设置self为不同成员
            enum TriStateSwitch {
                case Off, Low, High
                mutating func next() {
                    switch self {
                    case .Off:
                        self = .Low
                    case .Low:
                        self = .High
                    case .High:
                        self = .Off
                    }
                }
            }
            var ovenLight = TriStateSwitch.Low
            ovenLight.next()

类型方法
    说明
        类型本身调用的方法，这种方法就叫做类型方法。
        可以为所有的类、结构体和枚举定义类型方法。
        声明结构体和枚举的类型方法，在方法的func关键字之前加上static关键 。
        类可以用class关键字来允许子类重写父类的实现方法。
        类型方法和实例方法一样用点语法调用。
    self
        在类型方法的方法体(body)中，self 指向这个类型本身，而不是类型的某个实例。
        对于结构体和枚举来说，静态属性和静态方法参数名相同时，可以用self来区分。
    范例
        调用类型方法
            class SomeClass {
                static func someTypeMethod() {
                    // type method implementation goes here
                }
            }
            SomeClass.someTypeMethod()
        综合示例
            struct LevelTracker {
                static var highestUnlockedLevel = 1
                static func unlockLevel(level: Int) {
                    if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
                }
                static func levelIsUnlocked(level: Int) -&gt; Bool {
                    return level &lt;= highestUnlockedLevel
                }
                var currentLevel = 1
                mutating func advanceToLevel(level: Int) -&gt; Bool {
                    if LevelTracker.levelIsUnlocked(level: level) {
                        currentLevel = level
                        return true
                    } else {
                        return false
                    }
                }
            }
            class Player {
                var tracker = LevelTracker()
                let playerName: String
                func completedLevel(level: Int) {
                    LevelTracker.unlockLevel(level: level + 1)
                    tracker.advanceToLevel(level: level + 1)
                }
                init(name: String) {
                    playerName = name
                }
            }
            var player = Player(name: &quot;Argyrios&quot;)
            player.completedLevel(level: 1)
            print(&quot;highest unlocked level is now \(LevelTracker.highestUnlockedLevel)&quot;)
            // 打印输出:highest unlocked level is now 2
            player = Player(name: &quot;Beto&quot;)
            if player.tracker.advanceToLevel(level: 6) {
                print(&quot;player is now on level 6&quot;)
            } else {
                print(&quot;level 6 has not yet been unlocked&quot;)
            }
            // 打印输出:level 6 has not yet been unlocked
</code></pre><h2 id="下标脚本-Subscripts"><a href="#下标脚本-Subscripts" class="headerlink" title="下标脚本(Subscripts)"></a>下标脚本(Subscripts)</h2><pre><code>说明
    下标脚本可以定义在类,结构体,和枚举中。
    使用下标脚本的索引设置和获取值，不需要再调用实例的特定的赋值和访问方法。
    对于同一个目标可以定义多个下标脚本，通过索引值类型的不同来进行重载。
    下标脚本不限于单个纬度，你可以定义多个入参的下标脚本满足自定义类型的需求。

下标脚本语法
    说明
        下标脚本允许在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值。
        语法类似于实例方法和计算型属性的混合。
        与定义实例方法类似，定义下标脚本使用subscript关键字，显式声明入参和返回类型。
        与实例方法不同的是下标脚本可以设定为读写或只读。
        这种方式又有点像计算型属性的get ter和setter。
    范例
        可读写
            class ClassName {
                subscript(index: Int) -&gt; Int {
                    get {
                        // 返回与入参匹配的Int类型的值
                    }
                    set(newValue) {
                        // 执行赋值操作
                    }
                }
            }
        只读可省略get
            subscript(index: Int) -&gt; Int {
                // 返回与入参匹配的Int类型的值
            }
        构体中使用只读下标脚本
            struct TimesTable {
                let multiplier: Int
                subscript(index: Int) -&gt; Int {
                    return multiplier * index
                }
            }
            let threeTimesTable = TimesTable(multiplier: 3)
            print(&quot;3的6倍是\(threeTimesTable[6])&quot;)
            // 输出 &quot;3的6倍是18&quot;

下标脚本用法
    说明
        通常下标脚本是用来访问集合，列表或，序列中元素的快捷方式。
        你可以在你自己特定的类或结构体中自由的实现下标脚本来提供合适的功能。

下标脚本选项
    说明
        下标脚本允许任意数量的入参索引，并且每个入参类型也没有限制。
        下标脚本的返回值也可以是任何类型。
        下标脚本可以使用变量参数和可变参数。
        使用写入读出(in-out)参数或给参数设置默认值都是不允许的。
        一个类或结构体可以根据自身需要提供多个下标脚本实现。
        在定义下标脚本时通过入参的类型进行区分。
        使用下标脚本时会自动匹配合适的下标脚本实现运行，这就是下标脚本的重载。
        一个下标脚本入参是最常见的情况，但只要有合适的场景也可以定义多个下标脚本入参。
    范例
        struct Matrix {
            let rows: Int, columns: Int
            var grid: [Double]
            init(rows: Int, columns: Int) {
                self.rows = rows
                self.columns = columns
                grid = Array(repeating: 0.0, count: rows * columns)
            }
            func indexIsValidForRow(row: Int, column: Int) -&gt; Bool {
                return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
            }
            subscript(row: Int, column: Int) -&gt; Double {
                get {
                    assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)
                    return grid[(row * columns) + column]
                }
                set {
                    assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;)
                    grid[(row * columns) + column] = newValue
                }
            }
        }
        var matrix = Matrix(rows: 2, columns: 2)
        matrix[0, 1] = 1.5
        matrix[1, 0] = 3.2
</code></pre><h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><pre><code>说明
    一个类可以继承(inherit)另一个类的方法(methods)，属性(properties)和其它特性。
    当一个类继承其它类时，继承类叫子类(subclass)，被继承类叫超类(或父类，superclass)。
    在 Swift 中，继承是区分「类」与其它类型的一个基本特征。
    类可以调用或重写父类的方法,属性和下标脚本。
    可以为类中继承来的属性添加属性观察器，当属性值改变时，类就会被通知。

基类
    说明
        不继承于其它类的类，称之为基类(base calss)。
    范例
        class Vehicle {
            var currentSpeed = 0.0
            var description: String {
                return &quot;traveling at \(currentSpeed) miles per hour&quot;
            }
            func makeNoise() {
            }
        }
        let someVehicle = Vehicle()
        print(&quot;Vehicle: \(someVehicle.description)&quot;)
        // Vehicle: traveling at 0.0 miles per hour

子类
    说明
        子类指的是在一个已有类的基础上创建一个新的类。
        子类继承父类的特性，并且可以优化或改变它。你还可以为子类添加新的特性。
        了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔。
        子类还可以继续被其它类继承。
    范例
        class Bicycle: Vehicle {
            var hasBasket = false
        }
        let bicycle = Bicycle()
        bicycle.hasBasket = true
        bicycle.currentSpeed = 15.0
        print(&quot;Bicycle: \(bicycle.description)&quot;)
        // Bicycle: traveling at 15.0 miles per hour

重写
    说明
        子类可以重写父类的实例方法，类方法，实例属性，或下标脚本。
        如果要重写某个特性，你需要在重写定义的前面加上override关键字。
        缺少override关键字的相同定义将在编译时报错。
        override会提醒编译器去检查该类的超类(或其中一个父类)是否有匹配重写版本的声明。
        可以通过使用 super 前缀来访问超类版本的方法，属性或下标脚本。
        可以将一个继承来的只读属性重写为一个读写属性，但不能将读写属性重写为一个只读属性。
        可以在属性重写中为一个继承来的属性添加属性观察器。
    范例
        重写方法
            class Train: Vehicle {
                override func makeNoise() {
                    print(&quot;Choo Choo&quot;)
                }
            }
        重写属性
            class Car: Vehicle {
                var gear = 1
                override var description: String {
                    return super.description + &quot; in gear \(gear)&quot;
                }
            }
        重写属性观察器
            class AutomaticCar: Car {
                override var currentSpeed: Double {
                    didSet {
                        gear = Int(currentSpeed / 10.0) + 1
                    }
                }
            }

防止重写
    说明
        可以通过把方法，属性或下标脚本的声明关键字前加上final关键字来防止重写。
        如: final var, final func, final class func, final subscript
        重写了带有final关键字的方法属性或下标脚本会在编译时报错。
        在类扩展中的方法，属性或下标脚本也可以在扩展的定义里标记为final。
        你可以通过在关键字 class 前添加 final 来使整个类不可继承。
</code></pre><h2 id="构造过程-Initialization"><a href="#构造过程-Initialization" class="headerlink" title="构造过程(Initialization)"></a>构造过程(Initialization)</h2><pre><code>说明
    构造过程是使用类、结构体或枚举类型一个实例的准备过程。
    在新实例可用前必须执行这个过程。
    具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。
    可通过定义构造器( Initializers )来实现构造过程。
    这些构造器可以看做是用来创建特定类型新实例的特殊方法。
    与 OC 中的构造器不同，Swift 的构造器无需返回值。
    类的实例也可以通过定义析构器( deinitializer )在实例释放之前执行特定的清除工作。

存储属性的初始赋值
    说明
        类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。
        存储型属性的值不能处于一个未知的状态。
        可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。
        构造器在创建某特定类型的新实例时调用。
        它的最简形式类似于一个不带任何参数的实例方法，以关键字 init 命名。
        设置默认值和通过构造器赋值都不会触发任何属性观察者。
    范例
        构造器设置初始值
            struct Fahrenheit {
                var temperature: Double
                init() {
                    temperature = 32.0
                }
            }
            var f = Fahrenheit()
        设置默认值
            struct Fahrenheit {
                var temperature = 32.0
            }

自定义构造过程
    说明
        可以通过输入参数和可选属性类型来自定义构造过程，也可以在构造过程中修改常量属性。
    范例
        多个构造器并设置参数
            struct Celsius {
                var temperatureInCelsius: Double
                init(fromFahrenheit fahrenheit: Double) {
                    temperatureInCelsius = (fahrenheit - 32.0) / 1.8
                }
                init(fromKelvin kelvin: Double) {
                    temperatureInCelsius = kelvin - 273.15
                } }
            let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
            // boilingPointOfWater.temperatureInCelsius 是 100.0
            let freezingPointOfWater = Celsius(fromKelvin: 273.15)
            // freezingPointOfWater.temperatureInCelsius 是 0.0”
        多参数构造器
            struct Color {
                let red, green, blue: Double
                init(red: Double, green: Double, blue: Double) {
                    self.red   = red
                    self.green = green
                    self.blue  = blue
                }
                init(_ red: Double,_ green: Double,_ blue: Double) {
                    self.red   = red
                    self.green = green
                    self.blue  = blue
                }
                init(white: Double) {
                    red   = white
                    green = white
                    blue  = white
                }
            }
            let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
            let blue = Color(0, 0, 1.0)
            let halfGray = Color(white: 0.5)
        可选属性类型
            class SurveyQuestion {
                var text: String
                var response: String?
                init(text: String) {
                    self.text = text
                }
                func ask() {
                    print(text)
                } }
            let cheeseQuestion = SurveyQuestion(text: &quot;Do you like cheese?&quot;)
            cheeseQuestion.ask()
            // 输出 &quot;Do you like cheese?&quot;
            cheeseQuestion.response = &quot;Yes, I do like cheese.&quot;
        构造过程设置常量值
            class SurveyQuestion {
                let text: String
                var response: String?
                    init(text: String) {
                    self.text = text
                }
                func ask() {
                    print(text)
                }
            }
            let beetsQuestion = SurveyQuestion(text: &quot;How about beets?&quot;)
            beetsQuestion.ask()
            // 输出 &quot;How about beets?&quot;

默认构造器
    说明
        如果结构体和类的所有属性都有默认值，同时没有自定义的构造器，
        那么 Swift 会给这些结构体和类创建一个默认构造器。
        这个默认构造器将简单的创建一个所有属性值都设置为默认值的实例。
        结构体所有存储型属性提供了默认值且自身没有提供定制的构造器，会自动生成构造器。
    范例
        类默认构造器
            class ShoppingListItem {
                var name: String?
                var quantity = 1
                var purchased = false
            }
            var item = ShoppingListItem()
        结构体的逐一成员构造器
            struct Size {
                var width = 0.0, height = 0.0
            }
            let twoByTwo = Size(width: 2.0, height: 2.0)

值类型的构造器代理
    说明
        构造器可以通过调用其它构造器来完成实例的部分构造过程。
        这一过程称为构造器代理，它能减少多个构造器间的代码重复。
        构造器代理的实现规则和形式在值类型和类类型中有所不同。
        如果你为某个值类型定义了一个定制的构造器，你将无法访问到默认构造器。
        值类型(结构体和枚举类型)不支持继承，它们只能代理给本身提供的其它构造器。
        类可以继承自其它类，类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。
        值类型可以使用 self.init 在自定义的构造器中引用其它的属于相同值类型的构造器。
    范例
        struct Size {
            var width = 0.0, height = 0.0
        }
        struct Point {
            var x = 0.0, y = 0.0
        }
        struct Rect {
            var origin = Point()
            var size = Size()
            init() {}
            init(origin: Point, size: Size) {
                self.origin = origin
                self.size = size
            }
            init(center: Point, size: Size) {
                let originX = center.x - (size.width / 2)
                let originY = center.y - (size.height / 2)
                self.init(origin: Point(x: originX, y: originY), size: size)
            }
        }
        let basicRect = Rect()
        // basicRect 的原点是 (0.0, 0.0)，尺寸是 (0.0, 0.0)
        let originRect = Rect(origin: Point(x: 2.0, y: 2.0),size: Size(width: 5.0, height: 5.0))
        // originRect 的原点是 (2.0, 2.0)，尺寸是 (5.0, 5.0)
        let centerRect = Rect(center: Point(x: 4.0, y: 4.0),size: Size(width: 3.0, height: 3.0))
        // centerRect 的原点是 (2.5, 2.5)，尺寸是 (3.0, 3.0)

类的继承和构造过程
    说明
        类里面的所有存储型属性--包括所有继承自父类的属性--都必须在构造过程中设置初始值。
        Swift 提供了两种类型的类构造器来确保所有类实例中存储型属性都能获得初始值。
        它们分别是指定构造器和便利构造器。
        指定构造器必须总是向上代理，便利构造器必须总是横向代理。
        当重写一个父类指定构造器时，你需要写override修饰符。
    指定构造器
        指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性。
        并根据父类链往上调用父类的构造器来实现父类的初始化。
        每一个类都必须拥有至少一个指定构造器。
        许多类通过继承了父类中的指定构造器而满足了这个条件。
    便利构造器
        便利构造器是类中比较次要的、辅助型的构造器。
        便利构造器需在 init 关键字之前放置 convenience 关键字
        可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。
        也可以定义便利构造器来创建一个特殊用途或特定输入的实例。
    类的构造器代理规则
        指定构造器必须调用其直接父类的的指定构造器。
        便利构造器必须调用同一类中定义的其它构造器。
        便利构造器必须最终以调用一个指定构造器结束。
    自动构造器的继承
        子类不会默认继承父类的构造器。如特定条件可以满足，父类构造器是可以被自动继承的。
        如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。
        如果子类提供了所有父类指定构造器的实现它将自动继承所有父类的便利构造器。
    范例
        构造器重写
            class Vehicle {
                var numberOfWheels = 0
                var description: String {
                    return &quot;\(numberOfWheels) wheel(s)&quot;
                }
            }
            class Bicycle: Vehicle {
                override init() {
                    super.init()
                    numberOfWheels = 2
                }
            }
            let bicycle = Bicycle()
            print(&quot;Bicycle: \(bicycle.description)&quot;)
            // Bicycle: 2 wheel(s)
        自动构造器的继承
            class Food {
                var name: String
                init(name: String) {
                    self.name = name
                }
                convenience init() {
                    self.init(name: &quot;[Unnamed]&quot;)
                }
            }
            let namedMeat = Food(name: &quot;Bacon&quot;)
            // namedMeat 的名字是 &quot;Bacon”
            let mysteryMeat = Food()
            // mysteryMeat 的名字是 [Unnamed]
            class RecipeIngredient: Food {
                var quantity: Int
                init(name: String, quantity: Int) {
                    self.quantity = quantity
                    super.init(name: name)
                }
                override convenience init(name: String) {
                    self.init(name: name, quantity: 1)
                }
            }
            let oneMysteryItem = RecipeIngredient()
            let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)
            let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)
            //三种构造器创建RecipeIngredient实例
            class ShoppingListItem: RecipeIngredient {
                var purchased = false
                var description: String {
                    var output = &quot;\(quantity) x \(name)&quot;
                    output += purchased ? &quot; YES&quot; : &quot; NO&quot;
                    return output
                }
            }
            var breakfastList = [
                ShoppingListItem(),
                ShoppingListItem(name: &quot;Bacon&quot;),
                ShoppingListItem(name: &quot;Eggs&quot;, quantity: 6),
            ]
            breakfastList[0].name = &quot;Orange juice&quot;
            breakfastList[0].purchased = true
            for item in breakfastList {
                print(item.description)
            }
            // 1 x orange juice YES
            // 1 x bacon NO
            // 6 x eggs NO

可失败构造器
    说明
        如果在构造自身的过程中有可能失败，则为其定义一个可失败构造器是非常有用的。
        失败是指，如给构造器传入无效的参数,缺少所需的外部资源，不满足某种必要的条件等。
        语法为在 init 关键字后面加添问号 (init?) 
        通过 return nil 语句，来表 明可失败构造器在何种情况下“失败”。
        带原始值的枚举类型会自带一个可失败构造器 init?(rawValue:);
        也可使用(init!) 定义可失败构造器，他将构建一个特定类型的隐式解析可选类型的对象。
    范例
        类的可失败构造器
            struct Animal {
                let species: String
                init?(species: String) {
                    if species.isEmpty { return nil }
                    self.species = species
                }
            }
            let someCreature = Animal(species: &quot;Giraffe&quot;)
            // someCreature 的类型是 Animal? 而不是 Animal
            if let giraffe = someCreature {
                print(&quot;An animal was initialized with a species of \(giraffe.species)&quot;)
            }
            // 打印 &quot;An animal was initialized with a species of Giraffe&quot;
            let anonymousCreature = Animal(species: &quot;&quot;)
            if anonymousCreature == nil {
                print(&quot;The anonymous creature could not be initialized&quot;)
            }
            // 打印 &quot;The anonymous creature could not be initialized&quot;
        枚举的可失败构造器
            enum TemperatureUnit {
                case Kelvin, Celsius, Fahrenheit
                init?(symbol: Character) {
                    switch symbol {
                    case &quot;K&quot;:
                        self = .Kelvin
                    case &quot;C&quot;:
                        self = .Celsius
                    case &quot;F&quot;:
                        self = .Fahrenheit
                    default:
                        return nil }
                }
            }
            let fahrenheitUnit = TemperatureUnit(symbol: &quot;F&quot;)
            if fahrenheitUnit != nil {
                print(&quot;initialization succeeded.&quot;)
            }
            // 打印 &quot;initialization succeeded.&quot;
            let unknownUnit = TemperatureUnit(symbol: &quot;X&quot;)
            if unknownUnit == nil {
                print(&quot;so initialization failed.&quot;)
            }
            // 打印 &quot;initialization failed.&quot;
        带原始值的枚举类型的可失败构造器
            enum TemperatureUnit: Character {
                case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;
            }
            let fahrenheitUnit = TemperatureUnit(rawValue: &quot;F&quot;)
            if fahrenheitUnit != nil {
                print(&quot;initialization succeeded.&quot;)
            }
            // prints &quot;initialization succeeded.&quot;
            let unknownUnit = TemperatureUnit(rawValue: &quot;X&quot;)
            if unknownUnit == nil {
                print(&quot;initialization failed.&quot;)
            }
            // prints &quot;initialization failed.&quot;
        类的可失败构造器
            class Product {
                let name: String!
                init?(name: String) {
                    self.name = name
                    if name.isEmpty { return nil }
                }
            }
            if let bowTie = Product(name: &quot;bow tie&quot;) {
                print(&quot;The product&apos;s name is \(bowTie.name)&quot;)
            }
            // 打印 &quot;The product&apos;s name is bow tie&quot;
        构造失败的传递
            class Product {
                let name: String!
                init?(name: String) {
                    self.name = name
                    if name.isEmpty { return nil }
                }
            }
            class CartItem: Product {
                let quantity: Int!
                init?(name: String, quantity: Int) {
                    self.quantity = quantity
                    super.init(name: name)
                    if quantity &lt; 1 { return nil }
                }
            }
            if let oneUnnamed = CartItem(name: &quot;&quot;, quantity: 1) {
                print(&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;)
            } else {
                print(&quot;Unable to initialize one unnamed product&quot;)
            }
            // 打印 &quot;Unable to initialize one unnamed product&quot;

        重写一个可失败构造器
            class Document {
                var name: String?
                // 该构造器构建了一个name属性值为nil的document对象
                init() {}
                // 该构造器构建了一个name属性值为非空字符串的document对象
                init?(name: String) {
                    if name.isEmpty { return nil }
                    self.name = name
                }
            }
            class AutomaticallyNamedDocument: Document {
                override init() {
                    super.init()
                    self.name = &quot;[Untitled]&quot;
                }
                override init(name: String) {
                    super.init()
                    if name.isEmpty {
                        self.name = &quot;[Untitled]&quot;
                    } else {
                        self.name = name
                    }
                }
            }

必要构造器
    说明
        可在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器。
        在子类重写父类的必要构造器时，必须在子类的构造器前也添加 required 修饰符。
        在重写父类的必要构造器时，不需要添加 override 修饰符。
    范例
        class SomeClass {
            required init() {
                // 在这里添加该必要构造器的实现代码 }
            }
        }
        class SomeSubclass: SomeClass {
            required init() {
                // 在这里添加子类必要构造器的实现代码 }
            }
        }

通过闭包和函数来设置属性的默认值
    说明
        如某个存储型属性的默认值需要特别的定制，可使用闭包或全局函数来为其定制的默认值。
        每当某个属性所属的新类型实例创建时，对应的闭包或函数会被调用。
        闭包的返回值会当做默认值赋值给这个属性。
        闭包结尾的大括号后面接了一对空的小括号，表示需要立刻执行此闭包。
    格式
        class SomeClass {
            let someProperty: SomeType = {
            // 在这个闭包中给 someProperty 创建一个默认值
            // someValue 必须和 SomeType 类型相同
            return someValue
            }()
        }
    范例
        struct Checkerboard {
            let boardColors: [Bool] = {
                var temporaryBoard = [Bool]()
                var isBlack = false
                for i in 1...10 {
                    for j in 1...10 {
                        temporaryBoard.append(isBlack)
                        isBlack = !isBlack
                    }
                    isBlack = !isBlack
                }
                return temporaryBoard
            }()
            func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool {
                return boardColors[(row * 10) + column]
            }
        }
        let board = Checkerboard()
        print(board.squareIsBlackAtRow(row: 0, column: 1))
        // 输出 &quot;true&quot; 
        print(board.squareIsBlackAtRow(row: 9, column: 9))
        // 输出 &quot;false&quot;
</code></pre><h2 id="析构过程-Deinitialization"><a href="#析构过程-Deinitialization" class="headerlink" title="析构过程(Deinitialization)"></a>析构过程(Deinitialization)</h2><pre><code>说明
    析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。
    析构器用关键字 deinit 来标示，类似于构造器要用 init 来标示。

析构过程原理
    说明
        Swift通过自动引用计数(ARC) 处理实例的内存管理，自动释放不再需要的实例以释放资源。
        在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数。
        析构器是在实例释放发生前被自动调用，不允许被主动调用的。
        子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。
        即使子类没有提供自己的析构器，父类的析构器也同样会被调用。
        直到实例的析构器被调用时，实例才会被释放，所以析构器可以访问所有请求实例的属性。
    格式
        deinit {
            // 执行析构过程
        }
</code></pre><h2 id="自动引用计数-AutomaticReferenceCounting"><a href="#自动引用计数-AutomaticReferenceCounting" class="headerlink" title="自动引用计数(AutomaticReferenceCounting)"></a>自动引用计数(AutomaticReferenceCounting)</h2><pre><code>自动引用计数的工作机制
    当你每次创建一个类的新的实例的时候，ARC会分配一大块内存用来储存实例的信息。
    内存中会包含实例的类型信息，以及这个实例所有相关属性的值。
    当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。
    为确保使用中的实例不被销毁，ARC会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。
    无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。

自动引用计数实践
    范例
        class Person {
            let name: String
            init(name: String) {
                self.name = name
                print(&quot;\(name) is being initialized&quot;)
            }
            deinit {
                print(&quot;\(name) is being deinitialized&quot;)
            }
        }
        var reference1: Person?
        var reference2: Person?
        var reference3: Person?
        reference1 = Person(name: &quot;John Appleseed&quot;)
        // prints &quot;John Appleseed is being initialized”
        reference2 = reference1
        reference3 = reference1
        reference1 = nil
        reference2 = nil
        reference3 = nil
        // prints &quot;John Appleseed is being deinitialized&quot;

类实例之间的循环强引用
    范例
        class Person {
            let name: String
            init(name: String) { self.name = name }
            var apartment: Apartment?
            deinit { print(&quot;\(name) is being deinitialized&quot;) }
        }
        class Apartment {
            let unit: String
            init(unit: String) { self.unit = unit }
            var tenant: Person?
            deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
        }
        var john: Person?
        var unit4A: Apartment?
        john = Person(name: &quot;John Appleseed&quot;)
        unit4A = Apartment(unit: &quot;4A&quot;)
        john!.apartment = unit4A
        unit4A!.tenant = john

解决实例之间的循环强引用
    说明
        Swift提供了两种解决循环强引用的问题: 弱引用和无主引用。
        弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。
        对于生命周期中会变为 nil 的实例使用弱引用。
        对于初始化赋值后再也不会被赋值为 nil 的实例，使用无主引用。
    弱引用
        弱引用不会对其引用的实例保持强引用，因而不会阻止ARC销毁被引用的实例。
        声明属性或者变量时，在前面加上 weak 关键字表明这是一个弱引用。
        在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。
        因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。
        因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。
        ARC 会在引用的实例被销毁后 自动将其赋值为 nil 。
    无主引用
        和弱引用类似，无主引用不会牢牢保持住引用的实例。
        和弱引用不同的是，无主引用是永远有值的。
        无主引用总是被定义为非可选类型(non-optional type)。
        你可以在声明属性或者变量时，在前面加上关键字 unowned 表示这是一个无主引用。
        如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。
        使用无主引用，必须确保引用始终指向一个未销毁的实例。
    范例
        弱引用
            class Person {
                let name: String
                init(name: String) { self.name = name }
                var apartment: Apartment?
                deinit { print(&quot;\(name) is being deinitialized&quot;) }
            }
            class Apartment {
                let unit: String
                init(unit: String) { self.unit = unit }
                weak var tenant: Person?
                deinit { print(&quot;Apartment \(unit) is being deinitialized&quot;) }
            }
            var john: Person?
            var unit4A: Apartment?
            john = Person(name: &quot;John Appleseed&quot;)
            unit4A = Apartment(unit: &quot;4A&quot;)
            john!.apartment = unit4A
            unit4A!.tenant = john
            john = nil
            // prints &quot;John Appleseed is being deinitialized&quot;
            unit4A = nil
            // prints &quot;Apartment 4A is being deinitialized&quot;
        无主引用
            class Customer {
                let name: String
                var card: CreditCard?
                init(name: String) {
                    self.name = name
                }
                deinit { print(&quot;\(name) is being deinitialized&quot;) }
            }
            class CreditCard {
                let number: UInt64
                unowned let customer: Customer
                init(number: UInt64, customer: Customer) {
                    self.number = number
                    self.customer = customer
                }
                deinit { print(&quot;Card #\(number) is being deinitialized&quot;) }
            }
            var john: Customer?
            john = Customer(name: &quot;John Appleseed&quot;)
            john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
            john = nil
            // prints &quot;John Appleseed is being deinitialized&quot;
            // prints &quot;Card #1234567890123456 is being deinitialized&quot;
        隐式解析可选属性
            class Country {
                let name: String
                var capitalCity: City!
                init(name: String, capitalName: String) {
                    self.name = name
                    self.capitalCity = City(name: capitalName, country: self)
                }
            }
            class City {
                let name: String
                unowned let country: Country
                init(name: String, country: Country) {
                    self.name = name
                    self.country = country
                }
            }
            var country = Country(name: &quot;Canada&quot;, capitalName: &quot;Ottawa&quot;)
            print(&quot;\(country.name)&apos;s capital city is called \(country.capitalCity.name)&quot;)
            // prints &quot;Canada&apos;s capital city is called Ottawa&quot;

闭包引起的循环强引用
    说明
        当将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例。
        这个闭包体中可能访问了实例的某个属性或方法，则会导致循环强引用。
        循环强引用的产生，是因为闭包和类相似，都是引用类型。
        当你把一个闭包赋值给某个属性时，你也把一个引用赋值给了这个闭包。
        和两个类实例不同，这次一个是类实例，另一个是闭包。
        Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表。
    范例
        class HTMLElement {
            let name: String
            let text: String?
            lazy var asHTML: (Void) -&gt; String = {
                if let text = self.text {
                    return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
                } else {
                    return &quot;&lt;\(self.name) /&gt;&quot;
                }
            }
            init(name: String, text: String? = nil) {
                self.name = name
                self.text = text
            }
            deinit {
                print(&quot;\(name) is being deinitialized&quot;)
            }
        }
        var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)
        print(paragraph!.asHTML())
        // prints &lt;p&gt;hello, world&lt;/p&gt;
        paragraph = nil
        // HTMLElement的实例并不会销毁

解决闭包引起的循环强引用
    说明
        在定义闭包时同时定义捕获列表作为闭包的一部分，可解决闭包和类实例之间的循环强引用。
        捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。
        声明每个捕获的引用为弱引用或无主引用，而不是强引用。
        应当根据代码关系来决定使用弱引用还是无主引用。
    定义捕获列表
        捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，
        另一个元素是类实例的引用(self)或初始化过的变量，这些项在方括号中用逗号分开。
        如果闭包有参数列表和返回类型，把捕获列表放在它们前面:
        如果闭包没有指明参数列表或者返回类型，那么可以把捕获列表和关键字in放在闭包最开始。
    弱引用和无主引用
        在闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。
        在被捕获的引用可能会变为 nil 时，将闭包内的捕获定义为弱引用。
    格式
        闭包有参数和返回
            lazy var someClosure: (Int, String) -&gt; String = {
                [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
                // closure body goes here
            }
        闭包无参数和返回
            lazy var someClosure: Void -&gt; String = {
                 [unowned self, weak delegate = self.delegate!] in
                 // closure body goes here
            }
        范例
            class HTMLElement {
                let name: String
                let text: String?
                lazy var asHTML: (Void) -&gt; String = {
                    [unowned self] in
                    if let text = self.text {
                        return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;
                    } else {
                        return &quot;&lt;\(self.name) /&gt;&quot;
                    }
                }
                init(name: String, text: String? = nil) {
                    self.name = name
                    self.text = text
                }
                deinit {
                    print(&quot;\(name) is being deinitialized&quot;)
                }
            }
            var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello, world&quot;)
            print(paragraph!.asHTML())
            // prints &quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;
</code></pre><h2 id="可空链式调用-OptionalChaining"><a href="#可空链式调用-OptionalChaining" class="headerlink" title="可空链式调用(OptionalChaining)"></a>可空链式调用(OptionalChaining)</h2><pre><code>说明
    可空链式调用(Optional Chaining)是一种可以请求和调用属性、方法及下标的过程。
    它的可空性体现于请求或调用的目标当前可能为空(nil)。
    如果可空的目标有值，那么调用就会成功; 如果选择的目标为nil，那么这种调用将返回nil。
    多个连续的调用可以被链接在一起形成一个调用链，其中任何一个节点为nil将导致整个链调用失败。

使用可空链式调用来强制展开
    说明
        通过在想调用非空的属性、方法、或下标的可空值后面放一个问号，可以定义一个可空链。
        这一点很像在可空值后面放一个叹号(!)来强制展开其中值。
        当可空值为空时可空链式只是调用失败，然而强制展开将会触发运行时错误。
    范例
        class Person {
            var residence: Residence?
        }
        class Residence {
            var numberOfRooms = 1
        }
        let john = Person()
        let roomCount = john.residence!.numberOfRooms
        // 强制展开，会报错
        if let roomCount = john.residence?.numberOfRooms {
            print(&quot;John&apos;s residence has \(roomCount) room(s).&quot;)
        } else {
            print(&quot;Unable to retrieve the number of rooms.&quot;)
        }
        // 可空链式调用，打印&quot;Unable to retrieve the number of rooms.&quot;

为可空链式调用定义模型类
    说明
        通过使用可空链式调用可以调用多层属性，方法，和下标。
        这样可以通过各种模型向下访问各种子属性。
        并且判断能否访问子属性的属性，方法或下标。
    范例
        class Person {
            var residence: Residence?
        }
        class Residence {
            var rooms = [Room]()
            var numberOfRooms: Int {
                return rooms.count
            }
            subscript(i: Int) -&gt; Room {
                get {
                    return rooms[i]
                }
                set {
                    rooms[i] = newValue
                }
            }
            func printNumberOfRooms() {
                print(&quot;The number of rooms is \(numberOfRooms)&quot;)
            }
            var address: Address?
        }
        class Room {
            let name: String
            init(name: String) { self.name = name }
        }
        class Address {
            var buildingName: String?
            var buildingNumber: String?
            var street: String?
            func buildingIdentifier() -&gt; String? {
                if buildingName != nil {
                    return buildingName
                } else if buildingNumber != nil {
                    return buildingNumber
                } else {
                    return nil
                }
            }
        }

通过可空链式调用访问属性
    说明
        可以通过可空链式调用访问属性的可空值，并且判断访问是否成功。
    范例
        访问属性
            let john = Person()
            if let roomCount = john.residence?.numberOfRooms {
                print(&quot;John&apos;s residence has \(roomCount) room(s).&quot;)
            } else {
                print(&quot;Unable to retrieve the number of rooms.&quot;)
            }
            // prints &quot;Unable to retrieve the number of rooms.&quot;
        设置属性
            let someAddress = Address()
            someAddress.buildingNumber = &quot;29&quot;
            someAddress.street = &quot;Acacia Road&quot;
            john.residence?.address = someAddress

通过可空链式调用来调用方法
    说明
        可以通过可空链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。
    范例
        判断方法是否调用成功
            if john.residence?.printNumberOfRooms() != nil {
                print(&quot;It was possible to print the number of rooms.&quot;)
            } else {
                print(&quot;It was not possible to print the number of rooms.&quot;)
            }
            // prints &quot;It was not possible to print the number of rooms.&quot;
        判断属性是否设置成功
            if (john.residence?.address = someAddress) != nil {
                print(&quot;It was possible to set the address.&quot;)
            } else {
                print(&quot;It was not possible to set the address.&quot;)
            }
            // prints &quot;It was not possible to set the address.&quot;

通过可空链式调用来访问下标
    说明
        通过可空链式调用，我们可以用下标来对可空值进行读取或写入，并且判断下标调用是否成功。
        当通过可空链式调用访问可空值的下标的时候，应该将问号放在下标方括号的前面而不是后面。
        可空链式调用的问号 一般直接跟在可空表达式的后面。
    范例
        取值
            if let firstRoomName = john.residence?[0].name {
                print(&quot;The first room name is \(firstRoomName).&quot;)
            } else {
                print(&quot;Unable to retrieve the first room name.&quot;)
            }
            // prints &quot;Unable to retrieve the first room name.&quot;
        赋值
            john.residence?[0] = Room(name: &quot;Bathroom&quot;)
            //赋值同样会失败，因为 residence 目前是 nil 
        设置值后再访问
            let johnsHouse = Residence()
            johnsHouse.rooms.append(Room(name: &quot;Living Room&quot;))
            johnsHouse.rooms.append(Room(name: &quot;Kitchen&quot;))
            john.residence = johnsHouse
            if let firstRoomName = john.residence?[0].name {
                print(&quot;The first room name is \(firstRoomName).&quot;)
            } else {
                print(&quot;Unable to retrieve the first room name.&quot;)
            }
            // prints &quot;The first room name is Living Room.&quot;
        访问可空类型的下标
            var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]
            testScores[&quot;Dave&quot;]?[0] = 91
            testScores[&quot;Bev&quot;]?[0] += 1
            testScores[&quot;Brian&quot;]?[0] = 72
            // [&quot;Dave&quot;: [91, 82, 84], &quot;Bev&quot;: [80, 94, 81]]

多层链接
    说明
        可以通过多个链接多个可空链式调用来向下访问属性，方法以及下标。
        但是多层可空链式调用不会添加返回值的可空性。
        如果你访问的值不是可空的，通过可空链式调用将会放回可空值。
    范例
        失败情况
            if let johnsStreet = john.residence?.address?.street {
                print(&quot;John&apos;s street name is \(johnsStreet).&quot;)
            } else {
                print(&quot;Unable to retrieve the address.&quot;)
            }
            // prints &quot;Unable to retrieve the address.&quot;
        成功情况
            let johnsAddress = Address()
            johnsAddress.buildingName = &quot;The Larches&quot;
            johnsAddress.street = &quot;Laurel Street&quot;
            john.residence?.address = johnsAddress
            if let johnsStreet = john.residence?.address?.street {
                print(&quot;John&apos;s street name is \(johnsStreet).&quot;)
            } else {
                print(&quot;Unable to retrieve the address.&quot;)
            }
            // prints &quot;John&apos;s street name is Laurel Street.&quot;

对返回可空值的函数进行链接
    说明
        还可以通过可空链式调用来调用返回可空值的方法，并且可以继续对可空值进行链接。
    范例
        if let beginsWithThe =
            john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) {
            if beginsWithThe {
                print(&quot;John&apos;s building identifier begins with \&quot;The\&quot;.&quot;)
            } else {
                print(&quot;John&apos;s building identifier does not begin with \&quot;The\&quot;.&quot;)
            } }
        // prints &quot;John&apos;s building identifier begins with &quot;The&quot;.&quot;
</code></pre><h2 id="错误处理-ErrorHandling"><a href="#错误处理-ErrorHandling" class="headerlink" title="错误处理(ErrorHandling)"></a>错误处理(ErrorHandling)</h2><pre><code>表示并抛出错误
    说明
        在Swift中，错误用遵循 ErrorType 协议类型的值来表示。
        这个空协议表示一种可以用做错误处理的类型。 
        Swift 的枚举类型尤为适合塑造一组相关的错误情形(error conditions)，
        枚举的关联值还可以提 供额外信息，表示某些错误情形的性质。
    范例
        enum VendingMachineError: Error {
            case InvalidSelection //选择无效
            case InsufficientFunds(coinsNeeded: Int) //金额不足 
            case OutOfStock //缺货
        }

处理错误
    说明
        Swift中有 4 种处理错误的方式:throwing,do-catch,可选处理,断言
        在调用一个能抛出错误的函数，方法，或者构造器之前，加上 try 关键字
    用throwing函数传递错误
        用 throws 关键字标来识一个可抛出错误的函数，方法或是构造器。
        在函数声明中的参数列表之后加上 throws 。
        一个标识了 throws 的函数被称作throwing函数。
        如果这个函数还有返回值类型，throws 关键词需要写在箭 头(-&gt;)的前面。
        一个throwing函数从其内部抛出错误，并传递到该函数被调用时所在的区域中。
    用Do-Catch处理错误
        说明
            可以使用一个 do-catch 语句运行一段闭包代码来做错误处理。
            如果在 do 语句中的代码抛出了一个错误。
            则这个 错误会与 catch 语句做匹配来决定哪条语句能处理它。
            在 catch 后面写一个模式(pattern)来表示这个语句能处理什么样的错误。
            如果没有模式，则这条语句可以和任何错误相匹配，且错误和名为name的局部常量绑定。
        格式
            do {
                try expression
                statements
            } catch pattern 1 {
                statements
            } catch pattern 2 where condition {
                statements
            } 
    将错误转换成可选值
        可以使用 try? 通过将其转换成一个可选值来处理错误。
        如果在评估 try? 表达式时一个错误被抛出，那么这个表达式的值就是nil。
    使错误传递失效
        有时你知道某个 throwing 函数实际上在运行时是不会抛出错误的。
        此时可以在表达式前面写 try! 使错误传递失效。
        并把调用包装在一个运行时断言(runtime assertion)中来断定不会有错误抛出。
    范例
        用throwing函数传递错误
            struct Item {
                var price: Int
                var count: Int
            }
            class VendingMachine {
                var inventory = [
                    &quot;Candy Bar&quot;: Item(price: 12, count: 7),
                    &quot;Chips&quot;: Item(price: 10, count: 4),
                    &quot;Pretzels&quot;: Item(price: 7, count: 11)
                ]
                var coinsDeposited = 0
                func dispenseSnack(snack: String) {
                    print(&quot;Dispensing \(snack)&quot;)
                }
                func vend(itemNamed name: String) throws {
                    guard var item = inventory[name] else {
                        throw VendingMachineError.InvalidSelection
                    }
                    guard item.count &gt; 0 else {
                        throw VendingMachineError.OutOfStock
                    }
                    guard item.price &lt;= coinsDeposited else {
                        throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited)
                    }
                    coinsDeposited -= item.price
                    item.count -= 1
                    inventory[name] = item
                    dispenseSnack(snack: name)
                }
            }
            let favoriteSnacks = [
                &quot;Alice&quot;: &quot;Chips&quot;,
                &quot;Bob&quot;: &quot;Licorice&quot;,
                &quot;Eve&quot;: &quot;Pretzels&quot;,
            ]
            func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
                let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot;
                try vendingMachine.vend(itemNamed: snackName)
            }
        用Do-Catch处理错误
            var vendingMachine = VendingMachine()
            vendingMachine.coinsDeposited = 8
            do {
                try buyFavoriteSnack(person: &quot;Alice&quot;, vendingMachine: vendingMachine)
            } catch VendingMachineError.InvalidSelection {
                print(&quot;Invalid Selection.&quot;)
            } catch VendingMachineError.OutOfStock {
                print(&quot;Out of Stock.&quot;)
            } catch VendingMachineError.InsufficientFunds(let coinsNeeded) {
                print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)
            }
            // prints &quot;Insufficient funds. Please insert an additional 2 coins.&quot;
        将错误转换成可选值
            func fetchData() -&gt; Data? {
                if let data = try? fetchDataFromDisk() { return data }
                if let data = try? fetchDataFromServer() { return data }
                return nil
            }
        使错误传递失效
            let photo = try! loadImage(&quot;./Resources/John Appleseed.jpg&quot;)

指定清理操作
    说明
        可以使用 defer 语句在代码执行到要离开当前的代码段之前去执行一套语句。
        该语句让你能够做一些应该被执行的必要清理工作。
        defer 语句将代码的执行延迟到当前的作用域退出之前。
        该语句由 defer 关键字和要被延时执行的语句组成。
        defer 语句中不能包含 break return throw 等会将控制权移交到语句外面的代码。
        多条defer语句时，先定义的后执行。
    范例
        func processFile(filename: String) throws {
            if exists(filename) {
                let file = open(filename)
                defer {
                    close(file)
                }
                while let line = try file.readline() {
                    // 处理文件
                }
                // 在这里，作用域的最后调用 close(file)
            }
        }
</code></pre><h2 id="类型转换-TypeCasting"><a href="#类型转换-TypeCasting" class="headerlink" title="类型转换(TypeCasting)"></a>类型转换(TypeCasting)</h2><pre><code>定义一个类层次作为例子
    说明
        可以将类型转换用在类和子类的层次结构上。
        检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。
    范例
        class MediaItem {
            var name: String
            init(name: String) {
                self.name = name
            }
        }
        class Movie: MediaItem {
            var director: String
            init(name: String, director: String) {
                self.director = director
                super.init(name: name)
            }
        }
        class Song: MediaItem {
            var artist: String
            init(name: String, artist: String) {
                self.artist = artist
                super.init(name: name)
            }
        }
        let library = [
            Movie(name: &quot;Casablanca&quot;, director: &quot;Michael Curtiz&quot;),
            Song(name: &quot;Blue Suede Shoes&quot;, artist: &quot;Elvis Presley&quot;),
            Movie(name: &quot;Citizen Kane&quot;, director: &quot;Orson Welles&quot;),
            Song(name: &quot;The One And Only&quot;, artist: &quot;Chesney Hawkes&quot;),
            Song(name: &quot;Never Gonna Give You Up&quot;, artist: &quot;Rick Astley&quot;)
        ]
        // the type of &quot;library&quot; is inferred to be [MediaItem]

检查类型
    说明
        用类型检查操作符( is )来检查一个实例是否属于特定子类型。
        若实例属于那个子类型，类型检查操作符返回true ，否则返回false 。
    范例
        var movieCount = 0
        var songCount = 0
        for item in library {
            if item is Movie {
                movieCount += 1
            } else if item is Song {
                songCount += 1
            }
        }
        print(&quot;Media library contains \(movieCount) movies and \(songCount) songs&quot;)
        // prints &quot;Media library contains 2 movies and 3 songs&quot;

向下转型(Downcasting)
    说明
        某类型的一个常量或变量可能在幕后实际上属于一个子类。
        当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符(as? 或 as!)
        因为向下转型可能会失败，类型转型操作符带有两种不同形式。
        as? 条件形式返回一个你试图向下转成的类型的可选值。
        as! 强制形式把试图向下转型和强制解包结果作为一个混合动作。
    范例
        for item in library {
            if let movie = item as? Movie {
                print(&quot;Movie: &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;)
            } else if let song = item as? Song {
                print(&quot;Song: &apos;\(song.name)&apos;, by \(song.artist)&quot;)
            }
        }
        // Movie: &apos;Casablanca&apos;, dir. Michael Curtiz
        // Song: &apos;Blue Suede Shoes&apos;, by Elvis Presley

Any和AnyObject的类型转换
    说明
        Swift为不确定类型提供了两种特殊类型别名:
        AnyObject 可以代表任何class类型的实例。
        Any 可以表示任何类型，包括方法类型(function types)。
    范例
        AnyObject类型
            let someObjects: [AnyObject] = [
                Movie(name: &quot;2001: A Space Odyssey&quot;, director: &quot;Stanley Kubrick&quot;),
                Movie(name: &quot;Moon&quot;, director: &quot;Duncan Jones&quot;),
                Movie(name: &quot;Alien&quot;, director: &quot;Ridley Scott&quot;)
            ]
            for movie in someObjects as! [Movie] {
                print(&quot;Movie: &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;)
            }
            // Movie: &apos;2001: A Space Odyssey&apos;, dir. Stanley Kubrick
            // Movie: &apos;Moon&apos;, dir. Duncan Jones
            // Movie: &apos;Alien&apos;, dir. Ridley Scott
        Any
            var things = [Any]()
            things.append(0)
            things.append(0.0)
            things.append(42)
            things.append(3.14159)
            things.append(&quot;hello&quot;)
            things.append((3.0, 5.0))
            things.append(Movie(name: &quot;Ghostbusters&quot;, director: &quot;Ivan Reitman&quot;))
            things.append({ (name: String) -&gt; String in &quot;Hello, \(name)&quot; })
</code></pre><h2 id="嵌套类型-NestedTypes"><a href="#嵌套类型-NestedTypes" class="headerlink" title="嵌套类型(NestedTypes)"></a>嵌套类型(NestedTypes)</h2><pre><code>嵌套类型实例
    说明
        可以在枚举类型、类和结构体中定义支持嵌套的类型。
        要在一个类型中嵌套另一个类型，将需要嵌套的类型的定义写在被嵌套类型的区域{}内。
        并且可以根据需要定义多级嵌套。
    范例
        struct BlackjackCard {
            // 嵌套的 Suit 枚举
            enum Suit: Character {
                case Spades = &quot;♠&quot;, Hearts = &quot;♡&quot;, Diamonds = &quot;♢&quot;, Clubs = &quot;♣&quot;
            }
            // 嵌套的 Rank 枚举
            enum Rank: Int {
                case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
                case Jack, Queen, King, Ace
                struct Values {
                    let first: Int, second: Int?
                }
                var values: Values {
                    switch self {
                    case .Ace:
                        return Values(first: 1, second: 11)
                    case .Jack, .Queen, .King:
                        return Values(first: 10, second: nil)
                    default:
                        return Values(first: self.rawValue, second: nil)
                    }
                }
            }
            // BlackjackCard 的属性和方法
            let rank: Rank, suit: Suit
            var description: String {
                var output = &quot;suit is \(suit.rawValue),&quot;
                output += &quot; value is \(rank.values.first)&quot;
                if let second = rank.values.second {
                    output += &quot; or \(second)&quot;
                }
                return output
            }
        }
        let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
        print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)
        // 打印 “theAceOfSpades: suit is ♠, value is 1 or 11”

嵌套类型的引用
    说明
        在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀
    范例
        let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
        // 红心符号为 “♡”
</code></pre><h2 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展(Extensions)"></a>扩展(Extensions)</h2><pre><code>说明
    扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。
    这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。
    扩展和 Objective-C 中的分类类似，不同的是，Swift 的扩展没有名字。

扩展功能
    添加计算型属性和计算型类型属性
    定义实例方法和类型方法
    提供新的构造器
    定义下标
    定义和使用新的嵌套类型
    使一个已有类型符合某个协议

扩展语法
    说明
        使用关键字 extension 来声明扩展
    格式
        extension SomeType {
            // 为 SomeType 添加的新功能写到这里
        }
        extension SomeType: SomeProtocol, AnotherProctocol {
            // 协议实现写到这里
        }

计算型属性
    说明
        扩展可以为已有类型添加计算型实例属性和计算型类型属性。
    范例
        extension Double {
            var km: Double { return self * 1_000.0 }
            var m : Double { return self }
            var cm: Double { return self / 100.0 }
            var mm: Double { return self / 1_000.0 }
            var ft: Double { return self / 3.28084 }
        }
        let oneInch = 25.4.mm
        print(&quot;One inch is \(oneInch) meters&quot;)
        // 打印 “One inch is 0.0254 meters”
        let threeFeet = 3.ft
        print(&quot;Three feet is \(threeFeet) meters&quot;)
        // 打印 “Three feet is 0.914399970739201 meters”
        let aMarathon = 42.km + 195.m
        print(&quot;A marathon is \(aMarathon) meters long&quot;)
        // 打印 “A marathon is 42195.0 meters long”

构造器
    说明
        扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。
        指定构造器和析构器必须总是由原始的类实现来提供。
    范例
        struct Size {
            var width = 0.0, height = 0.0
        }
        struct Point {
            var x = 0.0, y = 0.0
        }
        struct Rect {
            var origin = Point()
            var size = Size()
        }
        let defaultRect = Rect()
        let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),size: Size(width: 5.0, height: 5.0))
        extension Rect {
            init(center: Point, size: Size) {
                let originX = center.x - (size.width / 2)
                let originY = center.y - (size.height / 2)
                self.init(origin: Point(x: originX, y: originY), size: size)
            }
        }
        let centerRect = Rect(center: Point(x: 4.0, y: 4.0),size: Size(width: 3.0, height: 3.0))
        // centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)

方法
    说明
        扩展可以为已有类型添加新的实例方法和类型方法。
    范例
        extension Int {
            func repetitions(_ task: () -&gt; Void) {
                for _ in 0..&lt;self {
                    task()
                }
            }
        }
        3.repetitions({
            print(&quot;Hello!&quot;)
        })
        // Hello!
        // Hello!
        // Hello!
        3.repetitions {
            print(&quot;Goodbye!&quot;)
        }
        // Goodbye!
        // Goodbye!
        // Goodbye!

可变实例方法
    说明
        通过扩展添加的实例方法也可以修改该实例本身。
        结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 mutating。
    范例
        extension Int {
            mutating func square() {
                self = self * self
            }
        }
        var someInt = 3
        someInt.square()
        // someInt 的值现在是 9

下标
    说明
        扩展可以为已有类型添加新下标。
    范例
        extension Int {
            subscript(digitIndex: Int) -&gt; Int {
                var decimalBase = 1
                for _ in 0..&lt;digitIndex {
                    decimalBase *= 10
                }
                return (self / decimalBase) % 10
            }
        }
        746381295[0]
        // 返回 5
        746381295[1]
        // 返回 9
        746381295[2]
        // 返回 2
        746381295[8]
        // 返回 7

嵌套类型
    说明
        扩展可以为已有的类、结构体和枚举添加新的嵌套类型。
    范例
        extension Int {
            enum Kind {
                case Negative, Zero, Positive
            }
            var kind: Kind {
                switch self {
                case 0:
                    return .Zero
                case let x where x &gt; 0:
                    return .Positive
                default:
                    return .Negative
                }
            }
        }
        func printIntegerKinds(_ numbers: [Int]) {
            for number in numbers {
                switch number.kind {
                case .Negative:
                    print(&quot;- &quot;, terminator: &quot;&quot;)
                case .Zero:
                    print(&quot;0 &quot;, terminator: &quot;&quot;)
                case .Positive:
                    print(&quot;+ &quot;, terminator: &quot;&quot;)
                }
            }
            print(&quot;&quot;)
        }
        printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
        // 打印 “+ + - 0 - 0 + ”
</code></pre><h2 id="协议-Protocols"><a href="#协议-Protocols" class="headerlink" title="协议(Protocols)"></a>协议(Protocols)</h2><pre><code>说明
    协议规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。
    类、结构体或枚举都可以采纳协议，并为协议定义的这些要求提供具体实现。
    某个类型能够满足某个协议的要求，就可以说该类型“符合”这个协议。
    除了采纳协议的类型必须实现的要求外，还可以对协议进行扩展。

协议语法
    定义协议
        protocol SomeProtocol {
            // 这里是协议的定义部分
        }
    遵守协议
        struct SomeStructure: FirstProtocol, AnotherProtocol {
            // 这里是结构体的定义部分
        }
    拥有父类并遵守协议
        class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol {
            // 这里是类的定义部分
        }

属性要求
    说明
        协议可以要求采纳协议的类型提供特定名称和类型的实例属性或类型属性。
        协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。
        此外，协议还指定属性是可读的还是可读可写的。
        如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。
        如果协议只要求属性是可读的，那么该属性不仅可以是可读的，还可以是可写的。
        协议总是用 var 关键字来声明变量属性。
        在类型声明后加上 { set get } 来表示属性是可读可写的。
        可读属性则用 { get } 来表示。
        在协议中定义类型属性时，总是使用 static 关键字作为前缀。
    范例
        定义实例属性
            protocol SomeProtocol {
                var mustBeSettable: Int { get set }
                var doesNotNeedToBeSettable: Int { get }
            }
        定义类型属性
            protocol AnotherProtocol {
                static var someTypeProperty: Int { get set }
            }

方法要求
    说明
        协议可以要求采纳协议的类型实现某些指定的实例方法或类方法。
        这些方法像普通方法一样放在协议的定义中，但是不需要大括号和方法体。
        可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。
        不支持为协议中的方法的参数提供默认值。
        当类类型采纳协议时，除了 static 关键字，还可以使用 class 关键字作为前缀：
    范例
        定义包含类方法的协议
            protocol SomeProtocol {
                static func someTypeMethod()
            }
        定义包含实例方法的协议
            protocol RandomNumberGenerator {
                func random() -&gt; Double
            }
        遵守协议
            class LinearCongruentialGenerator: RandomNumberGenerator {
                var lastRandom = 42.0
                let m = 139968.0
                let a = 3877.0
                let c = 29573.0
                func random() -&gt; Double {
                    lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy: m))
                    return lastRandom / m
                }
            }
            let generator = LinearCongruentialGenerator()
            print(&quot;Here&apos;s a random number: \(generator.random())&quot;)
            // 打印 “Here&apos;s a random number: 0.37464991998171”
            print(&quot;And another one: \(generator.random())&quot;)
            // 打印 “And another one: 0.729023776863283”

Mutating方法要求
    说明
        将 mutating 关键字作为方法的前缀，写在 func 关键字之前。
        表示可以在该方法中修改它所属的实例以及实例的任意属性的值。
    范例
        protocol Togglable {
            mutating func toggle()
        }
        enum OnOffSwitch: Togglable {
            case Off, On
            mutating func toggle() {
                switch self {
                case .Off:
                    self = .On
                case .On:
                    self = .Off
                }
            }
        }
        var lightSwitch = OnOffSwitch.Off
        lightSwitch.toggle()
        // lightSwitch 现在的值为 .On

构造器要求
    说明
        协议可以要求采纳协议的类型实现指定的构造器。
        可在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体。
    范例
        protocol SomeProtocol {
            init(someParameter: Int)
        }

构造器要求在类中的实现
    说明
        可以在采纳协议的类中实现构造器。
        无论是作为指定构造器还是便利构造器。须为构造器实现标上 required 修饰符。
        使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。
        如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符：
    范例
        遵守指定构造器的协议
            class SomeClass: SomeProtocol {
                required init(someParameter: Int) {
                    // 这里是构造器的实现部分
                }
            }
        子类继承父类并遵守协议
            protocol SomeProtocol {
                init()
            }
            class SomeSuperClass {
                init() {
                    // 这里是构造器的实现部分
                }
            }
            class SomeSubClass: SomeSuperClass, SomeProtocol {
                // 因为采纳协议，需要加上 required
                // 因为继承自父类，需要加上 override
                required override init() {
                    // 这里是构造器的实现部分
                }
            }

可失败构造器要求
    说明
        协议还可以为采纳协议的类型定义可失败构造器要求。
        采纳协议的类型可以通过可 init? 或 init 来满足协议中定义的可失败构造器要求。
        协议中定义的非可失败构造器要求可以通过 init 或 init! 来满足。

协议作为类型
    说明
        协议可以像其他普通类型一样使用，使用场景如下：
        作为函数,方法或构造器中的参数类型或返回值类型
        作为常量,变量或属性的类型
        作为数组,字典或其他容器中的元素类型
    范例
        class Dice {
            let sides: Int
            let generator: RandomNumberGenerator
            init(sides: Int, generator: RandomNumberGenerator) {
                self.sides = sides
                self.generator = generator
            }
            func roll() -&gt; Int {
                return Int(generator.random() * Double(sides)) + 1
            }
        }
        var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
        for _ in 1...5 {
            print(&quot;Random dice roll is \(d6.roll())&quot;)
        }
        // Random dice roll is 3
        // Random dice roll is 5
        // Random dice roll is 4
        // Random dice roll is 5
        // Random dice roll is 4

委托（代理）模式
    说明
        委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。
    范例
        protocol DiceGame {
            var dice: Dice { get }
            func play()
        }
        protocol DiceGameDelegate {
            func gameDidStart(game: DiceGame)
            func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)
            func gameDidEnd(game: DiceGame)
        }
        class SnakesAndLadders: DiceGame {
            let finalSquare = 25
            let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
            var square = 0
            var board: [Int]
            init() {
                board = [Int](count: finalSquare + 1, repeatedValue: 0)
                board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
                board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
            }
            var delegate: DiceGameDelegate?
            func play() {
                square = 0
                delegate?.gameDidStart(self)
                gameLoop: while square != finalSquare {
                    let diceRoll = dice.roll()
                    delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
                    switch square + diceRoll {
                    case finalSquare:
                        break gameLoop
                    case let newSquare where newSquare &gt; finalSquare:
                        continue gameLoop
                    default:
                        square += diceRoll
                        square += board[square]
                    }
                }
                delegate?.gameDidEnd(self)
            }
        }
        class DiceGameTracker: DiceGameDelegate {
            var numberOfTurns = 0
            func gameDidStart(game: DiceGame) {
                numberOfTurns = 0
                if game is SnakesAndLadders {
                    print(&quot;Started a new game of Snakes and Ladders&quot;)
                }
                print(&quot;The game is using a \(game.dice.sides)-sided dice&quot;)
            }
            func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
                numberOfTurns += 1
                print(&quot;Rolled a \(diceRoll)&quot;)
            }
            func gameDidEnd(game: DiceGame) {
                print(&quot;The game lasted for \(numberOfTurns) turns&quot;)
            }
        }
        let tracker = DiceGameTracker()
        let game = SnakesAndLadders()
        game.delegate = tracker
        game.play()
        // Started a new game of Snakes and Ladders
        // The game is using a 6-sided dice
        // Rolled a 3
        // Rolled a 5
        // Rolled a 4
        // Rolled a 5
        // The game lasted for 4 turns

通过扩展添加协议一致性
    说明
        即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。
        扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。
    范例
        protocol TextRepresentable {
            var textualDescription: String { get }
        }
        extension Dice: TextRepresentable {
            var textualDescription: String {
                return &quot;A \(sides)-sided dice&quot;
            }
        }
        let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
        print(d12.textualDescription)
        // 打印 “A 12-sided dice”

通过扩展采纳协议
    说明
        当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议。
    范例
        struct Hamster {
            var name: String
            var textualDescription: String {
                return &quot;A hamster named \(name)&quot;
            }
        }
        extension Hamster: TextRepresentable {}
        let simonTheHamster = Hamster(name: &quot;Simon&quot;)
        let somethingTextRepresentable: TextRepresentable = simonTheHamster
        print(somethingTextRepresentable.textualDescription)
        // 打印 “A hamster named Simon”

协议类型的集合
    说明
        协议类型可以在数组或者字典这样的集合中使用。
    范例
        let things: [TextRepresentable] = [game, d12, simonTheHamster]
        for thing in things {
            print(thing.textualDescription)
        }
        // A game of Snakes and Ladders with 25 squares
        // A 12-sided dice
        // A hamster named Simon

协议的继承
    说明
        协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。
        协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔。
        遵守协议的类必须符合该协议，和该协议继承的协议的要求。
    范例
        protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
            // 这里是协议的定义部分
        }

类类型专属协议
    说明
        你可以在协议的继承列表中，通过添加class关键字来限制协议只能被类类型采纳。
        而结构体或枚举不能采纳该协议。
        class关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前。
    范例
        protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
            // 这里是类类型专属协议的定义部分
        }

协议合成
    说明
        有时候需要同时采纳多个协议。
        可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合。
        你可以罗列任意多个你想要采纳的协议，以与符号(&amp;)分隔。
    范例
        protocol Named {
            var name: String { get }
        }
        protocol Aged {
            var age: Int { get }
        }
        struct Person: Named, Aged {
            var name: String
            var age: Int
        }
        func wishHappyBirthday(to celebrator: Named &amp; Aged) {
            print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)
        }
        let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)
        wishHappyBirthday(to: birthdayPerson)
        // 打印 “Happy birthday Malcolm - you&apos;re 21!”

检查协议一致性
    说明
        你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。
        检查和转换到某个协议类型在语法上和类型的检查和转换完全相同。
    语法
        is  用来检查实例是否符合某个协议，符合则返回 true，否则返回 false。
        as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值。
        as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。
    范例
        protocol HasArea {
            var area: Double { get }
        }
        class Circle: HasArea {
            let pi = 3.1415927
            var radius: Double
            var area: Double { return pi * radius * radius }
            init(radius: Double) { self.radius = radius }
        }
        class Country: HasArea {
            var area: Double
            init(area: Double) { self.area = area }
        }
        class Animal {
            var legs: Int
            init(legs: Int) { self.legs = legs }
        }
        let objects: [AnyObject] = [
            Circle(radius: 2.0),
            Country(area: 243_610),
            Animal(legs: 4)
        ]
        for object in objects {
            if let objectWithArea = object as? HasArea {
                print(&quot;Area is \(objectWithArea.area)&quot;)
            } else {
                print(&quot;Something that doesn&apos;t have an area&quot;)
            }
        }
        // Area is 12.5663708
        // Area is 243610.0
        // Something that doesn&apos;t have an area

可选的协议要求
    说明
        协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。
        在协议中使用 optional 关键字作为前缀来定义可选要求。
        使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。
        可选的协议要求只能用在标记 @objc 特性的协议中。
        @objc特性表示协议将暴露给 Objective-C 代码。
    范例
        @objc protocol CounterDataSource {
            @objc optional func incrementForCount(count: Int) -&gt; Int
            @objc optional var fixedIncrement: Int { get }
        }
        class Counter {
            var count = 0
            var dataSource: CounterDataSource?
            func increment() {
                if let amount = dataSource?.incrementForCount?(count: count) {
                    count += amount
                } else if let amount = dataSource?.fixedIncrement {
                    count += amount
                }
            }
        }
        class ThreeSource: NSObject, CounterDataSource {
            let fixedIncrement = 3
        }
        var counter = Counter()
        counter.dataSource = ThreeSource()
        for _ in 1...4 {
            counter.increment()
            print(counter.count)
        }
        // 3
        // 6
        // 9
        // 12

协议扩展
    说明
        协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标的实现。
        可以基于协议本身来实现这些功能，无需在每个采纳协议的类型中都重复同样的实现。
        可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。
        如果采纳协议的类型对协议的要求提供了实现，自定义实现会替代协议扩展的默认实现。
        扩展协议时，可以对遵守协议的类指定限制条件，满足时获得协议扩展提供的默认实现。
    范例
        协议扩展增加方法
            extension RandomNumberGenerator {
                func randomBool() -&gt; Bool {
                    return random() &gt; 0.5
                }
            }
        提供默认实现
            extension PrettyTextRepresentable  {
                var prettyTextualDescription: String {
                    return textualDescription
                }
            }
        为协议扩展添加限制条件
            extension CollectionType where Generator.Element: TextRepresentable {
                var textualDescription: String {
                    let itemsAsText = self.map { $0.textualDescription }
                    return &quot;[&quot; + itemsAsText.joinWithSeparator(&quot;, &quot;) + &quot;]&quot;
                }
            }
            let murrayTheHamster = Hamster(name: &quot;Murray&quot;)
            let morganTheHamster = Hamster(name: &quot;Morgan&quot;)
            let mauriceTheHamster = Hamster(name: &quot;Maurice&quot;)
            let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]
            print(hamsters.textualDescription)
            // 打印 “[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]”
</code></pre><h2 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h2><pre><code>说明
    泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。
    它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。

泛型所解决的问题
    说明
        下载非泛型的例子中，如果要交换多个类型的值，需要实现多个函数。
        Swift 是类型安全的语言，所以它不允许类型不同的变量互换值。
    范例
        func swapTwoInts( a: inout Int, _ b: inout Int) {
            let temporaryA = a
            a = b
            b = temporaryA
        }
        func swapTwoStrings( a: inout String, _ b: inout String) {
            let temporaryA = a
            a = b
            b = temporaryA
        }
        func swapTwoDoubles( a: inout Double, _ b: inout Double) {
            let temporaryA = a
            a = b
            b = temporaryA
        }

泛型函数
    说明
        泛型函数可以适用于任何类型，下面的 swapTwoValues 是上面三个函数的泛型版本。
        它能接受两个任意类型的值，条件是这两个值有着相同的类型。
        swapTwoValues 函数被调用时，T 所代表的类型都会由传入的值的类型推断出来。
    范例
        func swapTwoValues&lt;T&gt;( a: inout T, _ b: inout T) {
            let temporaryA = a
            a = b
            b = temporaryA
        }

类型参数
    说明
        类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用尖括号括起来，如 &lt;T&gt;。
        一个类型参数被指定，你可以用它来定义一个函数的参数类型，返回类型或函数主题注释类型。
        可提供多个类型参数，将它们都写在尖括号中，用逗号分开。

命名类型参数
    说明
        通常类型参数具有一个描述性名字，例如 Dictionary&lt;Key, Value&gt; 中的 Key,Value。
        当它们之间没有有意义的关系时，也可以使用单个字母来命名，例如 T、U、V。
        终使用大写字母开头的驼峰命名法来为类型参数命名，以表明它们是占位类型，而不是一个值

泛型类型
    说明
        除了泛型函数，Swift 还允许你定义泛型类型。
        这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。
    范例
        非泛型栈
            struct IntStack {
                var items = [Int]()
                mutating func push(item: Int) {
                    items.append(item)
                }
                mutating func pop() -&gt; Int {
                    return items.removeLast()
                }
            }
        泛型栈
            struct Stack&lt;Element&gt; {
                var items = [Element]()
                mutating func push(_ item: Element) {
                    items.append(item)
                }
                mutating func pop() -&gt; Element {
                    return items.removeLast()
                }
            }
            var stackOfStrings = Stack&lt;String&gt;()
            stackOfStrings.push(&quot;uno&quot;)
            stackOfStrings.push(&quot;dos&quot;)
            stackOfStrings.push(&quot;tres&quot;)
            stackOfStrings.push(&quot;cuatro&quot;)
            // 栈中现在有 4 个字符串
            let fromTheTop = stackOfStrings.pop()
            // fromTheTop 的值为 &quot;cuatro&quot;，现在栈中还有 3 个字符串

扩展一个泛型类型
    说明
        扩展一个泛型类型的时候，并不需要在扩展的定义中提供类型参数列表。
        原始类型定义中声明的类型参数列表在扩展中可以直接使用。
        原始类型中的参数名称会被用作原始定义中类型参数的引用。
    范例
        extension Stack {
            var topItem: Element? {
                return items.isEmpty ? nil : items[items.count - 1]
            }
        }
        if let topItem = stackOfStrings.topItem {
            print(&quot;The top item on the stack is \(topItem).&quot;)
        }
        // 打印 “The top item on the stack is tres.”

类型约束
    说明
        可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束。
        它们将成为类型参数列表的一部分。
    格式
        func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
            // 这里是泛型函数的函数体部分
        }
    范例
        func findIndex&lt;T: Equatable&gt;(_ array: [T], _ valueToFind: T) -&gt; Int? {
            for (index, value) in array.enumerated() {
                if value == valueToFind {
                    return index
                }
            }
            return nil
        }
        let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
        // doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中
        let stringIndex = findIndex([&quot;Mike&quot;, &quot;Malcolm&quot;, &quot;Andrea&quot;], &quot;Andrea&quot;)
        // stringIndex 类型为 Int?，其值为 2

关联类型
    说明
        定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。
        关联类型为协议中的某个类型提供了一个占位名（别名），其代表的实际类型在协议被采纳时才会被指定。
        可以通过 associatedtype 关键字来指定关联类型。
    范例
        protocol Container {
            associatedtype ItemType
            mutating func append(item: ItemType)
            var count: Int { get }
            subscript(i: Int) -&gt; ItemType { get }
        }
        struct IntStack: Container {
            // IntStack 的原始实现部分
            var items = [Int]()
            mutating func push(item: Int) {
                items.append(item)
            }
            mutating func pop() -&gt; Int {
                return items.removeLast()
            }
            // Container 协议的实现部分
            typealias ItemType = Int
            mutating func append(item: Int) {
                self.push(item: item)
            }
            var count: Int {
                return items.count
            }
            subscript(i: Int) -&gt; Int {
                return items[i]
            }
        }

Where子句
    说明
        类型约束让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。
        可以在参数列表中通过 where 子句为关联类型定义约束。
        可通过 where 子句要求一个关联类型遵守某个协议，或类型参数和关联类型必须类型相同。
        可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句。
        可以在函数体或者类型的大括号之前添加 where 子句。
    范例
        func allItemsMatch&lt;C1: Container, C2: Container&gt;
            (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool
            where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {
                // 检查两个容器含有相同数量的元素
                if someContainer.count != anotherContainer.count {
                    return false
                }
                // 检查每一对元素是否相等
                for i in 0..&lt;someContainer.count {
                    if someContainer[i] != anotherContainer[i] {
                        return false
                    }
                }
                // 所有元素都匹配，返回 true
                return true
        }
        var stackOfStrings = Stack&lt;String&gt;()
        stackOfStrings.push(&quot;uno&quot;)
        stackOfStrings.push(&quot;dos&quot;)
        stackOfStrings.push(&quot;tres&quot;)
        var arrayOfStrings = [&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;]
        if allItemsMatch(stackOfStrings, arrayOfStrings) {
            print(&quot;All items match.&quot;)
        } else {
            print(&quot;Not all items match.&quot;)
        }
        // 打印 “All items match.”
</code></pre><h2 id="访问控制-AccessControl"><a href="#访问控制-AccessControl" class="headerlink" title="访问控制(AccessControl)"></a>访问控制(AccessControl)</h2><pre><code>说明
    访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。
    这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。
    可以明确地给单个类型（类、结构体、枚举）设置访问级别。
    也可以给（类、结构体、枚举）的属性、方法、构造器、下标等设置访问级别。
    协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。

模块和源文件
    说明
        Swift 中的访问控制模型基于模块和源文件这两个概念。
        模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。
        一个模块可以使用 import 关键字导入另外一个模块。
        Xcode 的每个 target（例如框架或应用程序）都被当作独立的模块处理。
        源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。
        同一个源文件也可以包含多个类型、函数之类的定义。

访问级别
    三种级别
        public
            可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为 public 级别。
        internal
            可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为 internal 级别。
        private
            限制实体只能在所在的源文件内部使用。使用 private 级别可以隐藏某些功能的实现细节。
    访问级别基本原则  
        不可以在某个实体中定义访问级别更高的实体。
        一个 public 访问级别的变量，其类型的访问级别不能是 internal 或 private。
        函数的访问级别不能高于它的参数类型和返回类型的访问级别。
    默认访问级别
        如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别
    单target应用程序的访问级别
        当编写一个单 target 应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别。使用默认的访问级别 internal 即可。但是，你也可以使用 private 级别，用于隐藏一些功能的实现细节。
    框架的访问级别
        当你开发框架时，就需要把一些对外的接口定义为 public 级别。
        这会便于使用者导入该框架后可以正常使用其功能。
        这些被你定义为 public 的接口，就是这个框架的 API。
        框架依然会使用默认的 internal 级别，也可以指定为 private 级别。
        当你想把某个实体作为框架的 API 的时候，需显式为其指定 public 级别。
    单元测试 target 的访问级别
        当你的应用程序包含单元测试 target 时，测试模块需要访问应用程序模块中的代码。默认情况下只有 public 级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -&gt; Enable Testability）下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 internal 级别的实体。

访问控制语法
    说明
        通过修饰符 public、internal、private 来声明实体的访问级别。
    格式
        public class SomePublicClass {}
        internal class SomeInternalClass {}
        private class SomePrivateClass {}
        public var somePublicVariable = 0
        internal let someInternalConstant = 0
        private func somePrivateFunction() {}
        class SomeInternalClass {}   // 隐式访问级别 internal
        var someInternalConstant = 0 // 隐式访问级别 internal

自定义类型
    说明
        如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。
        新类型只能在它的访问级别限制范围内使用。
    类类型
        说明
            一个类的访问级别也会影响到类的成员（属性,方法,构造器,下标）的默认访问级别。
            如类为private级别，则该类型的所有成员的默认访问级别为private。
            如类为public或internal，则该类型的所有成员的默认访问级别为internal。
        范例
            public class SomePublicClass {          // 显式的 public 类
                public var somePublicProperty = 0   // 显式的 public 类成员
                var someInternalProperty = 0        // 隐式的 internal 类成员
                private func somePrivateMethod() {} // 显式的 private 类成员
            }
            class SomeInternalClass {               // 隐式的 internal 类
                var someInternalProperty = 0        // 隐式的 internal 类成员
                private func somePrivateMethod() {} // 显式的 private 类成员
            }
            private class SomePrivateClass {        // 显式的 private 类
                var somePrivateProperty = 0         // 隐式的 private 类成员
                func somePrivateMethod() {}         // 隐式的 private 类成员
            }
    元组类型
        说明
            元组的访问级别将由元组中访问级别最严格的类型来决定。
            元组的访问级别是在它被使用时自动推断出的，而无法明确指定。
    函数类型
        说明
            函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。
            如访问级别不符合函数定义所在环境的默认访问级别，需明确指定该函数的访问级别。
        范例
            报错:函数默认级别高于推断返回级别
                func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
                    // 此处是函数实现部分
                }
            指定函数访问级别
                private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
                    // 此处是函数实现部分
                }
    枚举类型
        说明
            枚举成员的访问级别和该枚举类型相同，不能为枚举成员单独指定不同的访问级别。
            枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。
        范例
            public enum CompassPoint {
                case North    //public访问级别
                case South    //public访问级别
                case East     //public访问级别
                case West     //public访问级别
            }
    嵌套类型
        说明
            在private级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有private访问级别。
            在public或者internal级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal访问级别。
            如果想让嵌套类型拥有public访问级别，那么需要明确指定该嵌套类型的访问级别。

子类
    说明
        子类的访问级别不得高于父类的访问级别。
        可以通过重写为继承来的类成员提供更高的访问级别。
    范例
        public class A {
            private func someMethod() {}
        }
        internal class B: A {
            override internal func someMethod() {}
        }

常量、变量、属性、下标
    说明
        常量、变量、属性不能拥有比它们的类型更高的访问级别。
        常量、变量、属性、下标的Getters和Setters的访问级别和它们所属类型的访问级别相同。
        Setter的访问级别可以低于对应的Getter，这样就可以控制变量、属性或下标的读写权限。
        使用private(set)和internal(set)可以改变Setter的访问级别。
    范例
        numberOfEdits的set为使用private
            struct TrackedString {
                private(set) var numberOfEdits = 0
                var value: String = &quot;&quot; {
                    didSet {
                        numberOfEdits += 1
                    }
                }
            }
        numberOfEdits的get为使用public，set为private
            public struct TrackedString {
                public private(set) var numberOfEdits = 0
                public var value: String = &quot;&quot; {
                    didSet {
                        numberOfEdits += 1
                    }
                }
                public init() {}
            }

构造器
    说明
        自定义构造器的访问级别可以低于或等于其所属类型的访问级别。
        唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。
        如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。
    默认构造器
        默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。
        如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。
    结构体默认的成员逐一构造器
        如结构体中任意存储型属性的级别为private，其默认成员逐一构造器的级别为private。
        否则，这种构造器的访问级别依然是 internal。

协议
    说明
        如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。
        这将限制该协议只能在适当的访问级别范围内被采纳。
    协议继承
        定义一个继承自其他协议的协议，新协议拥有的访问级别最高也只能和被继承协议的级别相同。
        例如，你不能将继承自 internal 协议的新协议定义为 public 协议。
    协议一致性
        一个类型可以遵守比自身访问级别低的协议。
        采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。

扩展
    说明
        你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。
        扩展成员具有和原始类型成员一致的访问级别。
    通过扩展添加协议一致性
        如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。
        协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。

泛型
    泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别。
    还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。

类型别名
    你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。
    类型别名的访问级别不可高于其表示的类型的访问级别。
</code></pre><h2 id="高级运算符-AdvancedOperators"><a href="#高级运算符-AdvancedOperators" class="headerlink" title="高级运算符(AdvancedOperators)"></a>高级运算符(AdvancedOperators)</h2><pre><code>说明
    与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。
    所有溢出行为都会被捕获并报告为错误。
    如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符。
    在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，以及相应的优先级与结合性。
    自定义运算符在代码中可像预定义的运算符一样使用，可扩展已有的类型以支持自定义的运算符。

位运算符
    说明
        位运算符可以操作数据结构中每个独立的比特位。
        它们通常被用在底层开发中，比如图形编程和创建设备驱动。
        位运算符在处理外部资源的原始数据时也十分有用，如对自定义通信协议的数据进行编码解码。
    运算法
        ~           按位取反
        &amp;           按位与，两数为1结果为1
        |           按位或，两数有一个为1，结果为1
        ^           按位异或，两数不同，结果为1
        &lt;&lt;          按位左移，对一个数的所有位进行指定位数的左移
        &gt;&gt;          和按位右，对一个数的所有位进行指定位数的右移
    范例
        按位取反
            let initialBits: UInt8 = 0b00001111
            let invertedBits = ~initialBits // 等于 0b11110000
        按位与
            let firstSixBits: UInt8 = 0b11111100
            let lastSixBits: UInt8  = 0b00111111
            let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100
        按位或
            let someBits: UInt8 = 0b10110010
            let moreBits: UInt8 = 0b01011110
            let combinedbits = someBits | moreBits // 等于 11111110
        按位异或
            let firstBits: UInt8 = 0b00010100
            let otherBits: UInt8 = 0b00000101
            let outputBits = firstBits ^ otherBits // 等于 00010001
        移位运算 
            let shiftBits: UInt8 = 4 // 即二进制的 00000100
            shiftBits &lt;&lt; 1           // 00001000
            shiftBits &lt;&lt; 2           // 00010000
            shiftBits &lt;&lt; 5           // 10000000
            shiftBits &lt;&lt; 6           // 00000000
            shiftBits &gt;&gt; 2           // 00000001
        通过移位运算对颜色拆分
            let pink: UInt32 = 0xCC6699
            let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16  // redComponent 是 0xCC，即 204
            let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102
            let blueComponent = pink &amp; 0x0000FF         // blueComponent 是 0x99，即 153

溢出运算符
    说明
        默认情况下，当向一个整数赋予超过它容量的值时，Swift会报错，而不是生成一个无效的数。
        这个行为为我们在运算过大或着过小的数的时候提供了额外的安全性。
        对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。当发生下溢时，它们会从所能容纳的最小数变成最大的数。
    运算符
        &amp;+       溢出加法
        &amp;-       溢出减法
        &amp;*       溢出乘法
    范例
        溢出报错
            var potentialOverflow = Int16.max
            // potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数
            potentialOverflow += 1
            // 这里会报错
        溢出加法
            var unsignedOverflow = UInt8.max
            // unsignedOverflow 等于 UInt8 所能容纳的最大整数 255
            unsignedOverflow = unsignedOverflow &amp;+ 1
            // 此时 unsignedOverflow 等于 0
        溢出减法
            var unsignedOverflow = UInt8.min
            // unsignedOverflow 等于 UInt8 所能容纳的最小整数 0
            unsignedOverflow = unsignedOverflow &amp;- 1
            // 此时 unsignedOverflow 等于 255
        有符号的数溢出减法
            var signedOverflow = Int8.min
            // signedOverflow 等于 Int8 所能容纳的最小整数 -128
            signedOverflow = signedOverflow &amp;- 1
            // 此时 signedOverflow 等于 127

优先级和结合性
    说明
        运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。
        结合性定义了相同优先级的运算符是如何结合的。
    文档
        [Swift官方运算符列表][https://developer.apple.com/reference/swift/1851035-swift_standard_library_operators#//apple_ref/doc/uid/TP40016054]

运算符函数
    说明
        类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。
        不能对默认的赋值运算符（=）进行重载。只有组合赋值运算符可以被重载。
        同样地，无法对三目条件运算符 （a ? b : c） 进行重载。
        复合赋值运算符将赋值运算符（=）与其它运算符进行结合。
        类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。
        为了使用等价运算符能对自定义的类型进行判等运算，可为其提供自定义实现
    范例
        加法运算符
            struct Vector2D {
                var x = 0.0, y = 0.0
            }
            extension Vector2D {
                static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D {
                    return Vector2D(x: left.x + right.x, y: left.y + right.y)
                }
            }
            let vector = Vector2D(x: 3.0, y: 1.0)
            let anotherVector = Vector2D(x: 2.0, y: 4.0)
            let combinedVector = vector + anotherVector
            // combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)
        前缀和后缀运算符
            extension Vector2D {
                static prefix func - (vector: Vector2D) -&gt; Vector2D {
                    return Vector2D(x: -vector.x, y: -vector.y)
                }
            }
            let positive = Vector2D(x: 3.0, y: 4.0)
            let negative = -positive
            // negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例
            let alsoPositive = -negative
            // alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例
        复合赋值运算符
            extension Vector2D {
                static func += (left: inout Vector2D, right: Vector2D) {
                    left = left + right
                }
            }
            var original = Vector2D(x: 1.0, y: 2.0)
            let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
            original += vectorToAdd
            // original 的值现在为 (4.0, 6.0)
        等价运算符
            extension Vector2D {
                static func == (left: Vector2D, right: Vector2D) -&gt; Bool {
                    return (left.x == right.x) &amp;&amp; (left.y == right.y)
                }
                static func != (left: Vector2D, right: Vector2D) -&gt; Bool {
                    return !(left == right)
                }
            }
            let twoThree = Vector2D(x: 2.0, y: 3.0)
            let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
            if twoThree == anotherTwoThree {
                print(&quot;These two vectors are equivalent.&quot;)
            }
            // 打印 “These two vectors are equivalent.”

自定义运算符
    说明
        除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。
        新的运算符要使用 operator 关键字在全局作用域内进行定义。
        同时还要指定 prefix、infix 或者 postfix 修饰符。
    自定义中缀运算符的优先级
        每个自定义中缀运算符都属于某个优先级组。
        这个优先级组指定了这个运算符和其他中缀运算符的优先级和结合性。
        没有明确放入优先级组的自定义中缀运算符会放到一个默认的优先级组内，其优先级高于三元运算符
    范例
        自定义 +++ 运算符
            prefix operator +++ {}
            extension Vector2D {
                static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D {
                    vector += vector
                    return vector
                }
            }
            var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
            let afterDoubling = +++toBeDoubled
            // toBeDoubled 现在的值为 (2.0, 8.0)
            // afterDoubling 现在的值也为 (2.0, 8.0)
        优先级组
            infix operator +-: AdditionPrecedence
            extension Vector2D {
                static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D {
                    return Vector2D(x: left.x + right.x, y: left.y - right.y)
                }
            }
            let firstVector = Vector2D(x: 1.0, y: 2.0)
            let secondVector = Vector2D(x: 3.0, y: 4.0)
            let plusMinusVector = firstVector +- secondVector
            // plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/11/Objective-C-笔记/" itemprop="url">
                  Objective-C-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-11T15:47:52+08:00" content="2016-08-11">
              2016-08-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>Cocoa框架
    说明
        是苹果公司为Mac OS X所创建的原生面向对象的编程环境
        是Mac OS X上五大API之一（其它四个是Carbon、POSIX、X11和Java）
        Cocoa中包含Foundation 和 UIKit

Foundation/Foundation.h
    说明
        包含了其他大量头文件，等于引入OC库
    位置
        /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks

NS
    说明
        是 NeXT Software 的建成
        OC不支持命名空间，NS是为了避免命名冲突而给的前缀
        看到NS前缀就知道是Cocoa中的系统类的名称

@
    说明
        OC中@由特殊用法
        @&quot;&quot;  表示将C字符串转换为NSString
        @标识符  OC中大部分关键字是以@开头的，比如@interface,@class,@end等

注释
    单行注释
        // ......
    多行注释
        /* ...... */
    文档注释
        /**
         * ......
         */

@class
    说明
        声明类，可用来替换 #import; 可避免引入的文件修改后，需重新编译的问题。
        当大量文件#import同一个文件时，此文件修改，所有引入它的文件都需要重新编译
        @class也可避免两个文件互相#import时的循环引入问题
        缺点是没有代码提示，可通过在.m中#import头文件来解决此问题
    范例
        .h   @class Person
        .m   #import &quot;Person.h&quot;

源文件
    .h       头文件
    .c       C语言源文件
    .cpp     C++语言的源文件，VC里用cpp作后缀名
    .cc      C++语言的源文件，GCC里采用cc作为后缀名
    .m       Objective-C的源文件
    .mm      Objective-C++的源文件

OC新增关键字
    @interface,@implementation,@end,@public,@protected,@private,@selector,,@try,@catch,@throw,@finally,@protocol,@optional,@required,,@class,@property,@synthesize,@dynamic,BOOL,Class,YES,NO,id,self,super,nil,atomic,noatomic,,retain,assign,copy,block

OC和C数据类型差异
    C语言数据类型
        基本类型
            整型
                短整型 short
                整型 int
            字符型 char
            实型
                单精度型 float
                双精度型 double
        构造类型
            数组
            结构体 struct
            共用型 union
            枚举类型 enum
        指针类型
        空类型 void
        定义类型 typeof
    OC数据类型
        基本数据类型
            数值型
                整形
                浮点型
            字符形 char
            布尔型 BOOL
            空类型 void
        Block类型
        指针数据类型
            类 class
            id类型
        特殊类型（SEL, Nil）

nil,Nil,NULL区别
    nil            为对象赋值空指针
    Nil            为类对象赋值空指针
    NULL           通用指针（泛型指针）
    [NSNull null]  空对象，用在不能使用nil的场合
</code></pre><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><pre><code>#import
    说明
        引入文件，相当于 #include
        import可以防止重复包涵，不需要手动编写防止重复包含的代码
        &lt;&gt; 内包含的是系统头文件， &quot;&quot; 包含的是用户自己编写的文件

#pragma mark
    说明
        对代码进行分组，方便对代码进行查找和导航
    范例
        #pragma mark Person类的声明
        #pragma mark -
</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><pre><code>Boolean
    说明
        用来存储 true false 两个逻辑值
        实质是 unsigned char 类型
    范例
        Boolean flag = true;

BOOL
    说明
        用来存储 YES NO 两个逻辑值
    范例
        BOOL flag = YES;

NSString
    说明
        NSString 是 Objective-C 中核心处理字符串的类之一
    范例
        创建常量字符串
            NSString *str = @&quot;Hello World&quot;;
        类的方式创建字符串
            NSString *str = [NSString new];
            str = @&quot;Hello World&quot;;
        格式化创建字符串
            NSString *str = [NSString stringWithFormat:@&quot;%d.jpg&quot;,i];
        用一个已存在的字符串创建字符串
            NSString *str1 = @&quot;Hello World&quot;;
            NSString *str2 = [[NSString alloc] initWithString:str1];
        计算字符串长度(不计算 \0 中文算一个字符)
            NSString *str = @&quot;Hello World&quot;;
            int length = [str length];

NS_ENUM
    说明
        可定义类型的枚举
    格式
        typedef NS_ENUM(枚举类型, 枚举名称) {枚举值};
    范例
        typedef NS_ENUM(NSInteger, Alignment) {
            Center = 0,
            Left   = 1,
            Right  = 2,
            Fill   = 3,
        };

NS_OPTIONS
    说明
        位枚举
        一个参数可传多个值
        1 &lt;&lt; 0 相当于 00000001, 等于1
        1 &lt;&lt; 1 相当于 00000010, 等于2
        1 &lt;&lt; 2 相当于 00000100, 等于4
        1 &lt;&lt; 3 相当于 00001000, 等于8
        1 &lt;&lt; 0 | 1 &lt;&lt; 1 | 1 &lt;&lt; 2  或位运算结果为 00000111, 等于7
        00000111 &amp; 00000001 与位运算结果为1，结果为真
        00000111 &amp; 00000010 与位运算结果为2，结果为真
        00000111 &amp; 00001000 与位运算结果为0，结果为假
    范例
        typedef NS_OPTIONS(NSUInteger, State) {
            Normal       = 0,
            Highlighted  = 1 &lt;&lt; 0,
            Disabled     = 1 &lt;&lt; 1,
            Selected     = 1 &lt;&lt; 2,
        };

id
    说明
        id是一种通用的对象类型，可以用来存储属于任何类的对象，也可以理解为万能指针
        id编译时不检查类型，运行时检查。编译器变异id类型时认为是动态类型
        NSObject编译时检查类型，需强制转换
    范例
        Person *person = [Person new];
        Student *student = [Student new];
        id obj = student;
        [obj eat];

instancetype
    说明
        和id一样同为万能指针。iOS_5 之后推出，
        和id都可以做为方法的返回类型
        instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象
        instancetype只能做为返回值，不能像id那样做为参数

block
    说明
        block类型是一个C级别的语法和运营机制
        和标准的C函数区别是除了可执行代码，还包含了于堆栈内存绑定的变量
        block可同时兼容C，C++，OC三种语言
        block也是一个代码段，和函数相比没有名称
        可定义一个变量来存储block代码段，这个变量为block类型
    格式
        返回值类型 (^block变量名)(形参列表) = ^(形参列表) {
        };
    范例
        无参无返回值
            void (^myBlock)() = ^{
                NSLog(@&quot;hello world!&quot;);
            };
            myBlock();
        有参无返回值
            void (^sum)(int,int) = ^(int a,int b){
                NSLog(@&quot;a+b=%d&quot;,a + b);
            };
            sum(1,2);
        无参有返回值
            NSString * (^myBlock)() = ^{
                return @&quot;hello world!&quot;;
            };
            NSLog(@&quot;%@&quot;,myBlock());
        有参有返回值
            int (^sum)(int,int);
            sum = ^(int a,int b){
                return a + b;
            };
            NSLog(@&quot;a+b=%d&quot;,sum(1,2));
    block 的 typedef
        说明
            block的别名
        格式
            typedef 返回值类型 (^新别名)(参数类型列表);
        范例
            没有返回值没有参数的block别名
                typedef void (^Block)();
                Block b1 = ^{
                    NSLog(@&quot;Hello World!&quot;);
                };
                b1();
            有返回值有参数的block别名
                typedef int (^Block)(int,int);
                Block sum = ^(int a, int b){
                    return a + b;
                };
                NSLog(@&quot;a + b = %d&quot;,sum(1,2));
    block外部变量
        说明
            block内部不允许修改外部非全局变量值
            定义block时，block会把外部局部变量以const方式复制一份存放到block所在内存中
            外部变量可通过增加 __block 修饰符而允许block内部修改，但修改的仍是复制值
        block分类
            全局block  定义在函数外面的block，或定义在函数内部却没有捕获任何白能量
            栈block    区别为是否引用了外部变量
            堆block    对栈block拷贝而来
    block做为函数的返回值
        说明
            需先用 typedef 定义一个 block 类型别名
            用新定义的类型做为函数的返回值类型
        范例
            typedef int (^Block)(int,int);
            Block fun(){
                return ^(int a, int b){
                    return a + b;
                };
            }
            fun()(1,2);
    block做为对象的属性
        范例
            @property(nonatomic,copy) void (^block)();
    block做为对象方法的参数
        范例
            -(void)test:(void (^)()) block;
    block做为对象方法的返回值
        范例
            -(void (^)())test;
    技巧
        助记符: 输入inlineblock，tab切换输入内容
</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><pre><code>类文件
    .h 类声明文件，用于声明成员变量，方法。声明使用@interface和@end。
    .m 类的实现文件，用于实现.h中声明的方法。实现使用@implementation和@end。

方法
    方法的声明和实现必须要 + 和 - 开头
    + 表示类方法(静态方法)
    - 表示对象方法(动态方法)

成员变量（实例变量，属性）
    作用域（访问修饰符）
        @public      公开的，任意地方通过实例对象都可访问
        @protected   (默认)只能在类的内部和子类中方法
        @private     只能在类的内部访问
        @package     同一框架内才可以访问（介于私有和公开之间）

声明
    格式
        @interface 类名:父类名
        {
            定义类的属性
        }
        方法类型标识符(返回值类型)方法名1:(参数类型)参数名 方法名2:(参数类型)参数名;
        @end
    范例
        typedef enum color{white,black,gold} iColor;
        @interface iPhone : NSString
        {
            @public
            iColor   _color;
            float    _size;
            NSString *_cpu;
        }
        - (void)aboutMyPhone;
        - (void)callPhone:(NSString *) telNum;
        - (void)sendMessage:(NSString *)telNum content:(NSString *)content;
        @end

实现
    格式
        @implementation 类名
            方法的具体实现
        @end
    范例
        @implementation iPhone
        - (void)aboutMyPhone{
            NSLog(@&quot;颜色：%d，尺寸：%f，CPU：%@&quot;,_color,_size,_cpu);
        }
        - (void)callPhone:(NSString *) telNum{
            NSLog(@&quot;给%@打电话！&quot;,telNum);
        }
        - (void)sendMessage:(NSString *)telNum content:(NSString *)content{
            NSLog(@&quot;给%@发送短信，短信内容是：%@！&quot;,telNum,content);
        }
        @end

创建对象
    说明
        ClassName new 会实例化一个对象
        new做了如下三件事请
        分配内存空间 (相当于 alloc)
        给实例变量初始化 (相当于 init)
        返回空间的首地址
    范例
        常用方式
            iPhone *iphone6 = [[iPhone alloc] init];
        简洁方式
            iPhone *iphone6 = [iPhone new];

属性访问
    格式
        对象名-&gt;属性名;
    范例
        iphone6-&gt;_color = black;
        iphone6-&gt;_size = 4.7f;
        iphone6-&gt;_cpu = @&quot;A8&quot;;

方法调用
    格式
        [类名或对象名 方法名];
    范例
        [iphone6 aboutMyPhone];
        [iphone6 callPhone:@&quot;10086&quot;];
        [iphone6 sendMessage:@&quot;18688730820&quot; content:@&quot;你好&quot;];

匿名对象调用方法
    范例
        [[iPhone new] aboutMyPhone];

self
    用在类方法中
        说明
            self此时指向当前的类
        范例
            @interface Person : NSObject
            +(void)eat;
            +(void)run;
            @end
            @implementation Person
            +(void)eat{
                NSLog(@&quot;人在吃东西！&quot;);
                [self run];
            }
            +(void)run{
                NSLog(@&quot;人在走路！&quot;);
            }
            @end
            [Person eat];
    用在对象方法中
        说明
            self此时指向当前调用方法的对象
        范例
            @interface Person : NSObject
            -(void)eat;
            -(void)run;
            @end
            @implementation Person
            -(void)eat{
                NSLog(@&quot;人在吃东西！&quot;);
            }
            -(void)run{
                NSLog(@&quot;人在走路！&quot;);
                [self eat];
            }
            @end
    访问成员变量
        说明
            在对象方法中可通过self访问对象成员变量
        范例
            @interface Dog : NSObject{
                int speed;
            }
            -(void)run;
            @end
            @implementation Dog
            -(void)run:(int)speed{
                self-&gt;speed = speed;
            }
            @end
    self在OC的内存管理特殊作用

私有方法
    说明
        .h中没有声明，在.m文件中直接实现的方法
        此时该方法只能通过self调用，且无法被子类继承

@property
    说明
        省略方法声明和实现，免去手写set和get方法繁琐的代码
        告诉编译器声明属性的访问器(getter/setter)方法
        只能写在 @interface @end 之间
        Xcode4.4后不需@synthesize，可直接生成实现
        调用 对象.属性 时，会操作名为 _属性 的实例变量，不存在会自动生成
        @property增强模式下，get和set方法可手动实现其中之一，不能同时手动实现
    格式
        @property (参数1,参数2) 类型名 变量名(去掉_)
    参数
        控制set方法的内存管理
            retain     MRC模式下，release旧值，retain新值（用于OC对象）
            strong     ARC模式下强指针，用于OC气体对象
            weak       ARC模式下弱指针，通常用于UI控件
            assign     直接赋值，不做任何内存管理(默认，用于非OC对象类型)
            copy       release旧值，copy新值（一般用于NSString\block）
        控制需不需要生成set方法
            readwrite  同时生成set方法和get方法（默认）
            readonly   只会生成get方法
        多线程管理
            atomic     对属性加锁，多线程下属性安全，性能低（默认）
            nonatomic  对属性不加锁，多线程下不安全，性能高
        控制set方法和get方法的名称
            setter     设置set方法的名称，一定有个冒号:
            getter     设置get方法的名称
    范例
        只省略声明
            @interface iPhone : NSString
            {
                float    _size;
            }
            @property float size;
            @end
            @implementation iPhone
            + (void)setSize:(float)size{
                _size = size;
            }
            + (float)size{
                return _size;
            }
            @end
            iPhone *p = [iPhone new];
            p.size = 5.3f;
            NSLog(@&quot;size=%f&quot;,p-&gt;_size);
        @property增强模式同时省略声明和实现
            @interface iPhone : NSString
            @property float size;
            @end
            @implementation iPhone
            @end
            iPhone *p = [iPhone new];
            p.size = 5.3f;

@synthesize
    说明
        省略set和get方法的实现，需配合@property使用
        生成.h中声明的get和set方法
        @synthesize不指定实例变量时会自动生成
        Xcode4.4后不需要此方法，@property可直接生成实现
    格式
        @synthesize 变量名1,变量名2,变量名3;
        @synthesize 变量名 = 实例变量名;
    范例
        @interface iPhone : NSString
        {
            float    _size;
        }
        @property float size;
        @end
        @implementation iPhone
        @synthesize size = _size;
        @end
        iPhone.size = 4.7f;

封装
    说明
        隐藏内部实现，只暴露接口
        避免外部修改对象内部的属性
    setter命名规范
        方法必须是set开头
        set后跟上成员变量的名，变量名首字母大写
        返回值一定是void
        一定要接收一个参数，而且参数类型需要和变量类型一致
        形参名不能和成员变量名一样（苹果官方推荐属性名前加 _ ）
    getter命名规范
        一定要有返回值，返回值类型和成员变量的类型一致
        方法名和成员变量名一样(去掉 _ )
        不需要接受任何参数
    点语法
        通过 对象.属性 可调用对象的set和get方法，用来存储读取属性
        对象.属性 并不是直接访问属性，而是Xcode识别点语法后替换为对象set或get方法
        如果没有set和get方法，无法使用点语法
    范例
        @interface iPhone : NSString
        {
            float    _size;
        }
        - (void)setSize:(float)size;
        - (float)size;
        @end
        @implementation iPhone
        - (void)setSize:(float)size{
            _size = size;
        }
        - (float)size{
            return _size;
        }
        @end
        iPhone *iphone6 = [iPhone new];
        [iPhone setSize:4.7f];
        iPhone.size = 5.3f;
        float s = iPhone.siz;

继承
    注意事项
        子类不同定义和父类同名的属性
        OC类只支持单一继承，不支持多继承
        OC类支持多层继承
    范例
        @interface Animal : NSObject{
            int _age;
        }
        -(void)eat:(NSString*)foodName;
        -(void)run;
        @end
        @implementation Animal
        -(void)eat:(NSString*)foodName{
            NSLog(@&quot;正在吃%@&quot;,foodName);
        }
        -(void)run{
            NSLog(@&quot;正在跑&quot;);
        }
        @end
        @interface Dog : Animal
        -(void)lookHome;
        @end
        @implementation Dog
        -(void)lookHome{
            NSLog(@&quot;正在看家&quot;);
        }
        @end
        [[Dog new] eat:@&quot;粑粑&quot;];

多态
    说明
        不同的对象以自己的方式相应相同名称方法的能力称为多态
    多态的条件
        有继承关系，有方法重写
        父类的声明变量指向子类对象
        例: 父类 *p=[子类 new];
    多态的优点
        简化编程接口，允许在类和类之间重用一些习惯性的命名
    多态原理
        动态绑定：程序直到执行时才知道对象所属类型和调用的实际方法
        OC可在运行时加入新的数据类型和新的程序模块：动态类型识别，动态绑定，动态加载
    范例
        @interface Animal : NSObject
        -(void)run;
        @end
        @implementation Animal
        -(void)run{
            NSLog(@&quot;动物在跑&quot;);
        }
        @end
        @interface Dog : Animal
        @end
        @implementation Dog
        -(void)run{
            NSLog(@&quot;狗在跑&quot;);
        }
        @end
        Animal *p = [Dog new];
        [p run];

super
    说明
        指代父类，可在子类方法中调用父类的方法
        super是一个编译指示器，用来给编译器使用，而不是一个指针。
        编译器识别到super后会让当前对象调用父类方法。
        调用者还是当前对象，调用的是父类的方法。
    范例
        //类结构如下: NSObject -&gt; Person -&gt; SubPerson
        //下面代码在SubPerson中调用
        [self class]               //SubPerson
        [self superclass]          //Person
        [super class]              //SubPerson
        [super superclass]         //Person

class
    说明
        获取当前方法调用者的类   

superclass
    说明
        获取当前方法调用者的父类

构造方法
    重写构造方法
        说明
            用来初始化对象的方法，OC中初始化对象的方法为init
            init为一个对象方法，返回调用init方法的对象
            重写构造方法可让对象初始化后成员变量就有默认值
        范例
            @interface Person : NSObject
            {
                int _age;
            }
            @end
            @implementation Person
            -(instancetype)init{
                //先让父类吧父类原来的事情做完
                self = [super init];
                //判断父类是否初始化成功
                if(self){
                    _age = 10;
                }
                return self;
            }
            @end
    自定义构造方法
        说明
            创建对象时，可用指定的值初始化对象
            一定是对象方法，以减号开头
            返回值一般是id或instancetype类型
            方法名一般以initWith开头
        范例
            @interface Person : NSObject
            @property NSString* name;
            -(instancetype)initWithName:(NSString *) name;
            @end
            @implementation Person
            -(instancetype)initWithName:(NSString *)name{
                if(self=[super init]){
                    _name = name;
                }
                return self;
            }
            @end
            Person *p = [[Person alloc]initWithName:@&quot;Jack&quot;];
</code></pre><h2 id="动态类型检测"><a href="#动态类型检测" class="headerlink" title="动态类型检测"></a>动态类型检测</h2><pre><code>判断类和之类的实例
    说明
        判断实例对象是否是这个类或者是这个类子类的实例
    格式
        [对象 isKindOfClass:类对象];
    范例
        Person *person = [Person new];
        Student *student = [Student new];
        BOOL isInstance = [student isKindOfClass:[Person class]];

判断类的实例
    说明
        判断实例对象是否是这个类的实例，不包括子类
    格式
        [对象 isMemberOfClass:类对象];
    范例
        Person *person = [Person new];
        Student *student = [Student new];
        BOOL isInstance = [student isMemberOfClass:[Person class]];

判断是否是类的子类
    说明
        判断类是否是指定类的子类
    格式
        [类 isSubclassOfClass:类对象];
    范例
        Person *person = [Person new];
        Student *student = [Student new];
        BOOL isSub = [Student isSubclassOfClass:[Person class]];

判断对象实例能否响应指定方法
    说明
        判断实例是否有指定方法，返回BOOL类型
    格式
        [对象 respondsToSelector:SEL];
    范例
        Person *person = [Person new];
        SEL sel = @selector(run);
        BOOL isRespond = [person respondsToSelector:sel];

判断类是否能调用指定方法
    说明
        判断类是否能调用指定方法，返回BOOL类型
    格式
        [对象 instancesRespondToSelector:SEL];
    范例
        Person *person = [Person new];
        BOOL isRespond = [Person instancesRespondToSelector:sel];

SEL方式响应方法
    说明
        可以调用无参数的方法或者一个参数和两个参数的方法
        可以延时调用
    范例
        @interface Person : NSObject
        -(void)play;
        -(void)run:(NSString *)speed;
        -(void)eat:(NSString *) food andNumber:(NSString *) number;
        @end
        @implementation Person
        -(void)play{}
        -(void)run:(NSString *)speed{}
        -(void)eat:(NSString *) food andNumber:(NSString *) number{}
        @end
        Person *p = [Person new];
        [p performSelector:@selector(play)];
        [p performSelector:@selector(run:) withObject:@&quot;10&quot;];
        [p performSelector:@selector(eat:andNumber:) withObject:@&quot;food&quot; withObject:@&quot;10&quot;];
</code></pre><h2 id="MRC-手动内存管理"><a href="#MRC-手动内存管理" class="headerlink" title="MRC-手动内存管理"></a>MRC-手动内存管理</h2><pre><code>引用计数器操作
    方法
        retain        使引用计数器 +1
        release       使得引用计数器 -1
        retainCount   得到引用计数器的值
    范例
        Person *p = [Person new];
        Person *p2 = [p retain];
        printf(&quot;%lu\n&quot;,[p retainCount]);

dealloc
    说明
        当系统引用计数器为0时，系统会自动调用对象的dealloc方法
        通常可重写dealloc方法
    范例
        @interface Person : NSObject
        @end
        @implementation Person
        -(void)dealloc{
            [super dealloc];
        }
        @end

@autorelease
    说明
        自动释放池
        当对象通过autorelease方法加入自动释放池后引用计数不会变化
        自动释放池结束后，会给池中每个对象发送release消息
    注意
        并不是把代码放入到自动化释放池就会自动释放,需执行autorelease方法
        无论对象是否是@autoreleasepoll内部创建，但需要在内部执行对象的autorelease方法
    范例
        @autoreleasepoll
        {
            Person *p = [[Person new] autorelease];
        }
</code></pre><h2 id="ARC-自动内存管理"><a href="#ARC-自动内存管理" class="headerlink" title="ARC - 自动内存管理"></a>ARC - 自动内存管理</h2><pre><code>说明
    ARC下不需要写retain,release,autorelease
    ARC是编译器特性，是在代码编译时候插入release,autorelease
    ARC的判断准则是只要没有强指针指向对象，对象就会被立即释放
    ARC下允许重写dealloc，但不允许调用[super dealloc]
    GC垃圾回收机制是运行特性

指针分类
    强指针     默认情况下所有的指针都是强指针，可用 __strong 修饰
    弱指针     __weak 关键字修饰的指针,例 __weak Person = [Person new];

ARC模式下兼容非ARC的类
    说明
        targets-&gt;build phases中修改compiler Flags
    参数
        -fno-objc-arc    让原来的非ARC项目不使用ARC编译
        -fobjc-arc       指定.m文件按照ARC方式编译
</code></pre><h2 id="Category-分类"><a href="#Category-分类" class="headerlink" title="Category - 分类"></a>Category - 分类</h2><pre><code>说明
    是OC的特有语法，其他语言中没有此语法，类似C#中的扩展方法
    可在不修改原有类的基础上增加新的方法
    可把一个庞大的类分模块开发
    可对现有类进行扩展，如可扩展 Cocoa touch 中的类
    可以做为子类的替代手段
    可对类中的方法归类

注意
    分类只能增加方法，不能增加成员变量
    可以在分类方法中访问原来类的成员变量
    如果分类和原来类中出现同名方法，优先分类方法
    如果多个分类中出现同名方法，最后编译的优先
    分类中的@property只会增加get和set方法，不会增加下划线的成员属性

非正式协议
    凡是NSObject或是其子类的类别，都是非正式协议

使用步骤
    声明分类
        格式
            @interface 待扩展的类名 (分类的名称)
            @end
        范例
            @interface Person : NSObject
            @end
            @implementation Person
            @end
            @interface Person (base)
                -(void)eat;
                -(void)run;
            @end
    实现分类
        格式
            @implementation 待扩展的类名 (分类的名称)
            @end
        范例
            @implementation Person (base)
                -(void)eat{
                    NSLog(@&quot;eatting&quot;);
                }
                -(void)run{
                    NSLog(@&quot;running&quot;);
                }
            @end
    使用分类
        说明
            和使用类中原有的对象方法一样
        范例
            Person *p = [Person new];
            [p run];

Extendsion - 扩展
    说明
        扩展又称为延展，是Category的一个特例
        一定用来声明只在内部使用的私有方法或属性
        Extendsion 的名字为空，并且新添加的方法一定要予以实现
        可为类添加额外的原来没有的变量，方法，或合成属性
        只能在原.m文件中的@implementation内实现方法
        定义在.m中的类扩展方法为私有的，定义在.h文件中的类扩展方法为公有的
    范例
        @interface Person ()
        @end
</code></pre><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><pre><code>说明
    OC中的copy指的是对象的拷贝
    目的是使用某个对象的数据，但是在修改对象的时候不影响原对象内容
    一个对象可以调用copy或mutableCopy方法来创建一个副本对象
    使用copy或mutableCopy时，必须遵守copy或mutableCopy的协议
    copy:创建不可变的副本，如NSString,NSArray,NSDictionary
    mutableCopy:创建的是可变的副本,如NSMutableString,NSMutableArray
    无论是否是可变对象，copy后是不可变的，mutableCopy后是可变的
    copy是浅拷贝，不会重新分配内存空间，原对象引用计数+1
    mutableCopy是深拷贝，会在内存中重新分配空间

范例
    字符串的mutableCopy
        NSString *str = @&quot;ABCDE&quot;;
        NSMutableString *strCopy = [str mutableCopy];
        [strCopy appendString:@&quot;FG&quot;];
    为自定义类实现copy
        @interface Person : NSObject &lt;NSCopying&gt;
        @property (nonatomic,assign) int age;
        @end
        @implementation Person
        -(id)copyWithZone:(NSZone *)zone{
            Person *p = [[Person alloc]init];
            p.age = self.age;
            return p;
        }
        @end
</code></pre><h2 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h2><pre><code>说明
    协议是一些方法的声明，一般写在.h文件中
    如果一个类采用一个协议，需实现这个协议中定义的必须实现的方法

使用流程
    定义协议
    在类中采用指定的协议
    实现协议中的方法（方法有必须实现和选择实现）

使用注意
    Protocol用来声明一大堆的方法(不能声明成员变量),不能写实现
    只要采用协议，便拥有了这个协议的声明（不需要在.h文件中重复声明）
    只要父类遵守了某个协议，子类也遵守
    Protocol声明的方法可以让任何类去实现
    OC不能继承多个类，但是可采用多个协议
    基协议&lt;NSObject&gt;是最基本的协议，其中声明了许多基本方法
    一个协议可以遵守另外的协议

基协议
    NSObject是一个基类，最根本最基本的类，任何其他类最终都要继承它
    还有名字也叫NSObject的协议，它是一个基协议，最根本最基本的协议
    NSObject协议中声明很多最基本的方法
    建议每个新的协议都要遵守NSObject协议

协议声明关键字
    @required   这个方法必须要实现（若不实现，编译器会发出警告）
    @optional   这个方法不一定要实现

定义协议
    格式
        @protocol 协议名称 &lt;NSObject&gt;
            //方法列表
        @end
    范例
        @protocol baseProtocol &lt;NSObject&gt;
        @required
        -(void)eat;
        @optional
        -(void)run;
        @end

采用协议
    一般格式
        #import &quot;协议名称1&quot;
        #import &quot;协议名称2&quot;
        @interface 类名:父类 &lt;协议名称1,协议名称2&gt;
        @end
    避免协议相互引用和大量编译的方式
        .h
            @protocol &quot;协议名称&quot;
            @interface 类名:父类 &lt;协议名称&gt;
            @end 
        .m
            #import &quot;协议名称&quot;
        main.m
            #import &quot;协议名称&quot;

类型限制
    说明
        可对赋给变量的值做限制，必须满足指定协议的条件下才可赋值
    格式
        数据类型&lt;协议名称&gt; 变量名
    范例
        限制协议
            id &lt;baseProtocol&gt; p = [[Person alloc] init];
        同时限制协议和类型
            Person &lt;baseProtocol&gt; p = [[Person alloc] init];
        对类中的属性限制
            @interface Student : Person
            @property(nonatomic,strong) Dog&lt;baseProtocol&gt; *dog;
            @end
</code></pre><h2 id="Foundation-框架"><a href="#Foundation-框架" class="headerlink" title="Foundation 框架"></a>Foundation 框架</h2><pre><code>NSString
    写入文件
        - (BOOL)writeToURL
    读取文件
        + (nullable instancetype)stringWithContentsOfFile
    字符串比较
        - (BOOL)isEqualToString:(NSString *)aString;
    判断字符串是否相等
        - [str1 (NSComparisonResult)compare:(NSString *)string;:str2];
    全部字符转为大写字母
        - (NSString *)uppercaseString;
    全部字符转为小写字母
        - (NSString *)lowercaseString
    首字母变大写，其他字母都变小写
        - (NSString *)capitalizedString
    判断字符串的前缀
        - (BOOL)hasPrefix:(nonnull NSString * )
    判断字符串的后缀
        - (BOOL)hasSuffix:(NSString *)str;
    字符串查找
        - (NSRange)rangeOfString:(NSString *)searchString;
    字符串截取
        - (NSString *)substringFromIndex:(NSUInteger)from;
        - (NSString *)substringToIndex:(NSUInteger)to;
        - (NSString *)substringWithRange:(NSRange)range;
    字符串替换
        - (NSString *)stringByReplacingOccurrencesOfString
    字符串和其他类型转换
        @property doubleValue;
        @property floatValue;
        @property intValue;
    转换为C语言字符串
        @property UTF8String
    C语言字符串转换为NSString
        + (nullable instancetype)stringWithUTF8String

NSMutableString
    说明
        继承自NSString，可任意动态的在字符串中添加删除和修改
        NSMutableString可使用NSString中的所有方法
    范例
        NSMutableArray *str = [NSMutableString string];

NSURL
    说明
        OC中URL处理的类
    范例
        NSURL *url = [NSURL URLWithString:@&quot;file:///root/tmp.txt&quot;];

NSRange
    说明
        表示事物的范围，通常是字符串里的字符范围或数组里的元素范围
        是Foundation框架中比较常用的结构体，包括location和length
        location 表示该范围的起始位置
        length 表示该范围的长度
    范例
        创建方法1
            NSRange range;
            range.location = 10;
            range.length = 3;
        创建方法2
            NSRange range = {10,3};
        创建方法3
            NSRange range;
            range = (NSRange){10,3};
        OC结构赋值
            NSRange range = NSMakeRange(7, 3);
        转换为NSString
            NSStringFromRange(NSRange range);

NSArray
    说明
        OC中的数组类，可存放任意OC对象
        不能存储 int,float,double,char,enum,struct 类型的数据
        一旦初始化完毕，里面的内容是永远固定的，不能删除或添加数组
        NSArray不能存储nil，nil做为元素最后一个结束符
        如果想在NSArray中存储NULL，可存储 [NSNull null]
        NSArray可用 NSLog(@&quot;%A&quot;) 打印
        C语言中的数组只能存放一种类型数据
        C语言的数组不能方便的动态添加删除数组元素
    创建
        - (instancetype)array;
        - (instancetype)arrayWithObject:(id)anObject;
        - (instancetype)arrayWithObjects:(id)firstObj, ...;
        - (instancetype)arrayWithArray:(NSArray *)array;
        - (id)arrayWithContentsOfFile:(NSString *)path;
        - (id)arrayWithContentsOfURL:(NSURL *)url;
    常见方法
        获取集合元素个数
            - (NSUInteger)count;
        获得index位置的元素
            - (id)objectAtIndex:(NSUInteger)index;
        是否包含某一个元素
            - (BOOL)containsObject:(id)anObject;
        返回最后一个元素
            - (id)lastObject;
        返回最后一个元素
            - (id)firstObject;
        查找anObject元素在数组中的位置(如果找不到，返回-1)
            - (NSUInteger)indexOfObject:(id)anObject;
        在range范围内查找anObject元素在数组中的位置
            - (NSUInteger)indexOfObject:(id)anObject inRange:(NSRange)range;
    范例
        创建空数组
            NSArray *arr = [NSArray array];
        创建数组只有一个元素
            NSArray *arr = [NSArray arrayWithObject:@&quot;a&quot;];
        创建数组有多个元素
            NSArray *arr = [NSArray arrayWithObjects:@&quot;a&quot;,@1,nil];
        调用对象方法 创建数组
            NSArray *arr = [NSArray alloc]initWithObjects:@&quot;a&quot;,nil];
        用已存在的数组创建数组
            NSArray *arr = [NSArray arrayWithArray:(nonnull NSArray *);
        简洁方法
            NSArray *arr = @[@&quot;Jack&quot;, @&quot;Rose&quot;, @&quot;Jim&quot;];
            arr[1];
    遍历
        NSArray的下标遍历
            NSArray *arr = @[@&quot;Jack&quot;, @&quot;Rose&quot;, @&quot;Jim&quot;];
            for (int i = 0; i &lt; arr.count; ++i) {
                NSLog(@&quot;%@&quot;,arr[i]);
            }
        NSArray的快速遍历
            NSArray *arr = @[@&quot;Jack&quot;, @&quot;Rose&quot;, @&quot;Jim&quot;];
            for (Person *p in arr) {
                NSLog(@&quot;%@&quot;,p);
            }
        NSArray 使用block进行遍历
            NSArray *arr = @[@&quot;Jack&quot;, @&quot;Rose&quot;, @&quot;Jim&quot;];
            [arr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
                NSLog(@&quot;obj = %@, idx = %lu&quot;, obj, idx);
            }];
    写入至文件
        NSArray *arr = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;];
        if([arr writeToFile:@&quot;/root/tmp.plist&quot; atomically:YES]){
            NSLog(@&quot;写入成功&quot;);
        };
    从文件读取数组
        NSArray *arr = [NSArray arrayWithContentsOfFile:@&quot;/root/tmp.plist&quot;];
        NSLog(@&quot;%@&quot;,arr);
    格式化字符串
        NSArray *arr = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;];
        NSString *str = [arr componentsJoinedByString:@&quot;-&quot;];
    字符串分割为数组
        NSString *str = @&quot;a-b-c-d&quot;;
        NSArray *arr = [str componentsSeparatedByString:@&quot;-&quot;];

NSMutableArray
    说明
        继承自NSArray，可使用NSArray的方法
        NSMutableArray是可变的，可以随时添加修改删除元素
    范例
        创建数组
            创建数组
                NSMutableArray *arr = [NSMutableArray array];
            创建并初始化
                NSMutableArray *arr = [NSMutableArray arrayWithObjects:@&quot;a&quot;,@&quot;b&quot;, nil];
            创建数组并指定长度
                NSMutableArray *arr = [NSMutableArray arrayWithCapacity:5];
        添加元素
            NSMutableArray *arr = [NSMutableArray array];
            [arr addObject:@&quot;a&quot;];
        插入元素
            [arr insertObject:@&quot;d&quot; atIndex:1];        
        删除元素
            [arr removeObject:@&quot;a&quot;];
            [arr removeObjectAtIndex:1];
        修改元素
            [arr replaceObjectAtIndex:1 withObject:@&quot;d&quot;];
            arr[2] = @&quot;d&quot;;
        查找元素
            BOOL isSearch = [arr containsObject:@&quot;a&quot;];
        交换元素
            [arr exchangeObjectAtIndex:1 withObjectAtIndex:2];

NSDictionary
    说明
        字典是用来存储Key,Value对应关系的数据结构
        不可变，初始化后内容不可修改
    范例
        创建空字典
            NSDictionary *dist = [NSDictionary dictionary];
        创建只有一组键值对的字典
            NSDictionary *dist = [NSDictionary dictionaryWithObject:@&quot;value&quot; forKey:@&quot;key&quot;];
        创建多组键值对的字典
            NSDictionary *dist = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;,@&quot;key1&quot;,@&quot;value2&quot;,@&quot;key2&quot;,nil];
        简洁创建方式
            NSDictionary *dist = @{
                @&quot;key1&quot;:@&quot;value1&quot;,
                @&quot;key2&quot;:@&quot;value2&quot;,
                @&quot;key3&quot;:@&quot;value3&quot;
            };
        返回键值对数
            long int n = [dist count];
        取值
            [dist objectForKey:@&quot;key1&quot;];
        取值简写
            dict[@&quot;key1&quot;];
        遍历
            for (NSString *key in dist) {
                NSLog(@&quot;%@=%@&quot;,key,[dist objectForKey:key]);
            }
        遍历通过block
            [dist enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL * stop) {
                NSLog(@&quot;%@=%@&quot;,key,value);
            }];
        把字典存储至文件
            if([dist writeToFile:@&quot;/root/tmp.plist&quot; atomically:YES]){
                NSLog(@&quot;写入成功&quot;);
            };
        从文件读取字典
            NSDictionary *dist = [NSDictionary dictionaryWithContentsOfFile:@&quot;/root/tmp.plist&quot;];

NSMutableDictionary
    说明
        NSMutableDictionary是NSDictionary的子类
        NSMutableDictionary是可变的，可增删改查
    范例
        创建
            NSMutableDictionary *dist = [NSMutableDictionary dictionary];
        添加
            [dist setValue:@&quot;value&quot; forKey:@&quot;key&quot;];
        删除
            [dist removeObjectForKey:@&quot;key&quot;];
        修改
            [dist setObject:@&quot;value&quot; forKey:@&quot;key&quot;];
        修改简写
            dist[@&quot;key&quot;] = @&quot;value&quot;;

NSFileManager
    说明
        用来管理文件系统，可对文件进行拷贝剪贴创建等操作
        也包括查看文件读写权限，目录修改创建等
    范例
        判断文件是否存在
            NSString *path = @&quot;/Users/caozheng/Downloads/tmp.plist&quot;;
            NSFileManager *fm = [NSFileManager defaultManager];
            if([fm fileExistsAtPath:path]){
                NSLog(@&quot;文件存在&quot;);
            }
        判断是否是一个目录
            BOOL isDirectory;
            [fm fileExistsAtPath:path isDirectory:&amp;isDirectory];
        判断文件是否可读
            if([fm isReadableFileAtPath:path]){
                NSLog(@&quot;文件可读&quot;);
            }
        判断文件是否可写
            if([fm isWritableFileAtPath:path]){
                NSLog(@&quot;文件可写&quot;);
            }
        判断文件是否可删除
            if([fm isDeletableFileAtPath:path]){
                NSLog(@&quot;文件可删除&quot;);
            }
        获取文件属性
            NSDictionary *dist = [fm attributesOfItemAtPath:path error:nil];
            NSLog(@&quot;%@&quot;,dist);
        获取指定目录下的文件和目录（递归，包括后代）
            NSArray *arr = [fm subpathsAtPath:path];
        获取指定目录下的文件和目录（非递归，包括后代）
            NSArray *arr = [fm subpathsOfDirectoryAtPath:path error:nil];
        获取指定目录下的子目录和文件（不包括后代）
            NSArray *arr = [fm contentsOfDirectoryAtPath:path error:nil];
        创建文件
            NSString *str= @&quot;abc&quot;;
            NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];
            if([fm createFileAtPath:path contents:data attributes:nil]){
                NSLog(@&quot;创建成功&quot;);
            };
        创建目录
            if([fm createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]){
                NSLog(@&quot;创建成功&quot;);
            };
        复制文件
            [fm copyItemAtPath:path toPath:@&quot;/root/&quot; error:nil]
        移s动文件
            [fm moveItemAtPath:path toPath:@&quot;/root/&quot; error:nil];
        删除文件
            [fm removeItemAtPath:path error:nil];

NSPoint/CGPoint
    说明
        表示二纬平面的一个点的结构体，包含x,y两个值
    范例
        NSPoint p = {10,20};

NSSize/CGSize
    说明
        表示二纬平面中宽度和高度的结构，包含height,width两个值
    范例
        NSSize s = {100,200};

NSRect/CGRect
    说明
        表示二纬平面中左上角是某个点的矩形区域,包含origin,size
    范例
        NSRect r = {{10,10},{100,100}};

NSNumber
    说明
        是OC中处理数字的类
        把int/float/double包装成一个对象
        可把基本类型的数据保存到数组或字典中
    范例
        简写
            NSNumber *n = @100;
        使用@转换为Number
            int i = 100;
            NSNumber *n = @(100); 
        int转换为NSNumber
            NSNumber *n = [NSNumber numberWithInt:10];
        float转换为NSNumber
            NSNumber *n = [NSNumber numberWithFloat:3.14f];
        double转换为NSNumber
            NSNumber *n = [NSNumber numberWithDouble:3.14];
        数组内NSNumber相加   
            NSArray *arr = @[@1,@3.14f];
            NSLog(@&quot;%f&quot;,[arr[0] intValue] + [arr[1] floatValue]);

NSValue
    说明
        可把指针和结构体包装为NS对象
        NSNumber是NSValue的子类
    范例
        NSPoint转换为NSValue
            NSPoint p = {10,20};
            NSValue *value = [NSValue valueWithPoint:p];
        NSRect转换为转换为NSValue
            NSRect r = {{10,20},{100,200}};
            NSMutableArray *arr = [NSMutableArray array];
            [arr addObject:[NSValue valueWithRect:r]];
        NSValue转换为NSRect
            NSRect r = {{10,20},{100,200}};
            NSValue *vlaue = [NSValue valueWithRect:r];
            NSLog(@&quot;%@&quot;,NSStringFromRect([vlaue rectValue]));
        转换C结构体为NSValue并取值
            typedef struct D{
                int year;
                int month;
                int day;
            } MyDate;
            MyDate data = {2016,8,15};
            NSValue *value = [NSValue valueWithBytes:&amp;data objCType:@encode(MyDate)];
            MyData data1;
            [value getValue:&amp;data1]          

NSData
    说明
        OC中处理时间日期的类
        可以用来表示时间，可以进行一些常见的日期\时间处理
        一个NSData对象代表一个时间
    范例
        获取当前时间（GMT 0时区）
            NSDate *date = [NSDate date];
        格式化显示时间
            NSDate *date = [NSDate date];
            NSDateFormatter *formatter = [NSDateFormatter new];
            formatter.dateFormat = @&quot;yyyy年MM月DD日 HH:mm:ss&quot;;
            NSString *str = [formatter stringFromDate:date];
            NSLog(@&quot;%@&quot;,str);
        计算时间
            NSTimeInterval t = 24 * 60 * 60;
            NSDate *tomorrow = [NSDate dateWithTimeIntervalSinceNow:t];
        单独获取年月日
            NSDate *d = [NSDate date];
            NSCalendar *cal = [NSCalendar currentCalendar];
            NSDateComponents *coms = [cal components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:d];
            NSLog(@&quot;year:%ld,month:%ld,day:%ld&quot;,coms.year,coms.month,coms.day);
</code></pre><h2 id="Sandbox-沙盒机制"><a href="#Sandbox-沙盒机制" class="headerlink" title="Sandbox - 沙盒机制"></a>Sandbox - 沙盒机制</h2><pre><code>说明
    是一种文件系统，每个应用程序只能访问自己的沙盒
    iOS8开始开放了几个固定区域用于其它程序访问

文件目录
    MyApp.app
        该目录包含了应用程序本身的数据，包括资源文件和可执行文件等。程序启动以后，会根据需要从该目录中动态加载代码或资源到内存，这里用到了lazy loading的思想。
        整个目录是只读的，
        不会被iTunes同步       
    Documents
        我们可以将应用程序的数据文件保存在该目录下。不过这些数据类型仅限于不可再生的数据，可再生的数据文件应该存放在Library/Cache目录下。
        会被iTunes同步
    Documents/Inbox
        该目录用来保存由外部应用请求当前应用程序打开的文件。
    Library
        苹果建议用来存放默认设置或其它状态信息。
    Library/Caches
        主要是缓存文件，用户使用过程中缓存都可以保存在这个目录中。前面说过，Documents目录用于保存不可再生的文件，那么这个目录就用于保存那些可再生的文件，比如网络请求的数据。鉴于此，应用程序通常还需要负责删除这些文件。
        不会被iTunes同步        
    Library/Preferences
        应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，这就是所谓的写道plist中！
        会被iTunes同步
    tmp
        各种临时文件，保存应用再次启动时不需要的文件。而且，当应用不再需要这些文件时应该主动将其删除，因为该目录下的东西随时有可能被系统清理掉，目前已知的一种可能清理的原因是系统磁盘存储空间不足的时候。
        不会被iTunes同步       

数据存储方式
    XML属性列表(plist)归档
    Preference(偏好设置),是plist的封装，使用比plist方便
    NSkeyedArchiver归档(NSCoding),用来保存自定义对象
    SQLite3
    Core Data,对SQLite3进行了封装。

路径获取
    MyApp.app
        [[NSBundle mainBundle] bundlePath]
    沙盒路径
        NSHomeDirectory();
    Documents
        NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];
    tmp
        NSTemporaryDirectory()

Preferences的读写
    存储信息
        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        [defaults setObject:@&quot;Value&quot; forKey:@&quot;Key&quot;];
        [defaults setInteger:10 forKey:@&quot;age&quot;];
        [defaults synchronize];
    读取信息
        NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        [defaults objectForKey:@&quot;Key&quot;];
        [defaults integerForKey:@&quot;age&quot;];

NSkeyedArchiver的读写
    说明
        能实现对象的存取
        归档的对象需遵守&lt;NSCoding&gt;协议
        归档的对象需实现encodeWithCoder方法，用来指定保存的信息
        归档的对象需实现initWithCoder方法，用来指定读取文件时解析的属性
    存储信息
        @interface Person : NSObject &lt;NSCoding&gt;
        @property (nonatomic,copy) NSString *name;
        @property (nonatomic,assign) int age;
        @end
        @implementation Person
        //保存对象时告诉保存当前对象的哪些的速写
        -(void)encodeWithCoder:(NSCoder *)aCoder{
            [aCoder encodeObject:self.name forKey:@&quot;name&quot;];
            [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];
        }
        -(instancetype)initWithCoder:(NSCoder *)aDecoder{
            if(self = [super init]){
                self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];
                self.age = [aDecoder decodeIntForKey:@&quot;age&quot;];
            }
            return self;
        }
        @end
        Person *person = [[Person alloc]init];
        person.name = @&quot;ZhangShan&quot;;
        person.age = 18;
        NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;Person.data&quot;];
        [NSKeyedArchiver archiveRootObject:person toFile:path];
    读取信息
        NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;Person.data&quot;];
        Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path];
</code></pre><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><pre><code>NSLog
    说明
        是cocoa框架提供的函数
        类似printf,参数为NSString
        相比printf，NSLog增加了日子时间换行等功能
    例子
        NSString *str = @&quot;张三丰&quot;;
        NSLog(@&quot;%@&quot;,str);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/MySQL-笔记/" itemprop="url">
                  MySQL-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-03T11:47:52+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="了解SQL"><a href="#了解SQL" class="headerlink" title="了解SQL"></a>了解SQL</h2><pre><code>术语 
    RDBMS       Relational Database Management System - 关系数据库管理系统
    DBMS        Database Management System - 数据库管理系统
    database    数据库 - 保存有组织的数据的容器（通常是一个文件或一组文件）
    table       表 - 某种特定类型数据的结构化清单
    schema      模式 - 关于数据库和表的布局及特性的信息
    column      列 - 表中的一个字段。所有表都是由一个或多个列组成的。
    datatype    数据类型 - 每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据
    row         行 - 表中的一个记录
    primarykey  主键 - 一列（或一组列），其值能够唯一区分表中每个行
    foreignkey  外键 - 为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系
    SQL         Structured Query Language - 一种专门用来与数据库通信的语言

SQL优点
    不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL。
    简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。
    灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。
</code></pre><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><pre><code>相关软件包
    mysql-server    MySQL服务器。
    mysql-client    MySQL 客户端程序，用于连接并操作Mysql服务器。
    mysql-devel     库和包含文件，如需编译其它MySQL客户端，例如Perl模块，需要安装该RPM
    mysql-shared    该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)
    mysql-bench     MySQL数据库服务器的基准和性能测试工具

安装命令
    apt-get install mysql-server

开启服务（三种方式）
    systemctl start mysql
    mysql.server start
    mysqld 
        --safe-mode   装载减去某些最佳配置的服务器；
        --verbose     显示全文本消息（为获得更详细的帮助消息与--help联合使用）；
        --version     显示版本信息然后退出。

验证
    mysqladmin --version
    mysql -u root -p

配置文件
    /etc/my.cnf
</code></pre><h2 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h2><pre><code>相关软件包
    mysql-server    MySQL服务器。
    mysql-devel     库和包含文件，如需编译其它MySQL客户端，例如Perl模块，需要安装该RPM
    mysql-shared    包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)
    mysql-bench     MySQL数据库服务器的基准和性能测试工具

安装命令
    apt-get install mysql-server

开启服务
    systemctl start mysql
    mysql.server start

验证
    mysqladmin --version
    mysql -u root -p

配置文件
    /etc/my.cnf
</code></pre><h2 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h2><pre><code>特点
    成本 - MySQL是开放源代码的，一般可以免费使用（甚至可以免费修改）
    性能 - MySQL执行很快（非常快）
    可信赖 - 某些非常重要和声望很高的公司都用MySQL来处理自己的重要数据
    简单 - MySQL很容易安装和使用

mysql - MySQL command-line tool
    选项参数
        -u &lt;user&gt;        用户名
        -p &lt;password&gt;    密码
        -h &lt;host&gt;        主机
        -P &lt;port&gt;        端口
    命令
        HELP [command]              显示[指定命令]的帮助
        USE &lt;database&gt;              选择数据库
        SHOW DATABASES              显示数据库
        SHOW TABLES                 获得一个数据库内的表的列表
        SHOW COLUMNS FROM &lt;table&gt;   显示表的列的描述信息
        DESCRIBE &lt;table&gt;            显示表的列的描述信息
        SHOW STATUS                 用于显示广泛的服务器状态信息
        SHOW CREATE DATA BASE       显示创建特定数据库
        SHOW CREATE TABLE           显示创建特定数据表
        SHOW GRANTS                 用来显示授予用户的安全权限
        SHOW ERRORS                 用来显示服务器错误消息
        SHOW WARNINGS               用来显示服务器警告消息
        INFORMATION_SCHEMA          获得和过滤模式信息。

mysqladmin - MySQL Administrator MySQL服务器的管理器
    选项和参数
        -u &lt;user&gt;                  用户名
        -p &lt;password&gt;              密码
    命令
        create databasename        创建一个新数据库
        drop databasename          删除一个数据库及其所有表
        extended-status            给出服务器的一个扩展状态消息
        flush-hosts                洗掉所有缓存的主机
        flush-logs                 洗掉所有日志 
        flush-tables               洗掉所有表 
        flush-privileges           再次装载授权表(同reload) 
        kill id,id,...             杀死mysql线程 
        password                   新口令，将老口令改为新口令
        ping                       检查mysqld是否活着 
        processlist                显示服务其中活跃线程列表
        reload                     重载授权表 
        refresh                    洗掉所有表并关闭和打开日志文件
        shutdown                   关掉服务器 
        status                     给出服务器的简短状态消息
        variables                  打印出可用变量
        version                    得到服务器的版本信息
</code></pre><h2 id="检索数据-SELECT"><a href="#检索数据-SELECT" class="headerlink" title="检索数据 SELECT"></a>检索数据 SELECT</h2><pre><code>例：
    SELECT &lt;column&gt; FROM &lt;table&gt;                检索指定的列
    SELECT &lt;column_1,column_2&gt; FROM &lt;table&gt;     检索多个指定的列
    SELECT * FROM &lt;table&gt;                       检索所有的列
    SELECT DISTINCT &lt;column&gt; FROM &lt;table&gt;       检索指定的列，只返回不同的值
    SELECT &lt;column&gt; FROM &lt;table&gt; LIMIT 5        检索指定的列中前5行
    SELECT &lt;column&gt; FROM &lt;table&gt; LIMIT 5,4      检索指定的列中第5行之后的4行
    SELECT last_insert_id()                     获取最后通过自动增量生成的值

子句及其顺序
    SELECT              要返回的列或表达式
    FROM                从中检索数据的表(仅在从表选择数据时使用)
    WHERE               行级过滤
    GROUP BY            分组说明(仅在按组计算聚集时使用)
    HAVING              组级过滤
    ORDER BY            输出排序顺序
    LIMIT               要检索的行数
</code></pre><h2 id="排序-ORDER-BY"><a href="#排序-ORDER-BY" class="headerlink" title="排序 ORDER BY"></a>排序 ORDER BY</h2><pre><code>ORDER BY &lt;column&gt;                           排序
ORDER BY &lt;column_1,column_2&gt;                按照多个列排序
ORDER BY &lt;column&gt; DESC                      按照降序排序
ORDER BY &lt;column_1&gt; DESC, &lt;column_2&gt;        对column_1降序排序在以column_2排序
</code></pre><h2 id="过滤数据-WHERE"><a href="#过滤数据-WHERE" class="headerlink" title="过滤数据 WHERE"></a>过滤数据 WHERE</h2><pre><code>WHERE &lt;condition&gt;                           依据条件对数据进行筛选
WHERE &lt;condition_1&gt; AND &lt;condition_2&gt;       两个条件需同时满足
WHERE &lt;condition_1&gt; OR &lt;condition_2&gt;        匹配任意条件
WHERE &lt;column&gt; IN &lt;value_1,value_2&gt;         值为value_1,value_2其中之一
WHERE NOT &lt;condition&gt;                       否定之后的条件
WHERE &lt;column&gt; IS NULL                      筛选column为NULL的数据

支持的条件操作符
    =                                       等于
    &lt;&gt;                                      不等于
    !=                                      不等于
    &lt;                                       小于
    &lt;=                                      小于等于
    &gt;                                       大于
    &gt;=                                      大于等于
    BETWEEN 5 AND 10                        在指定的两个值之间
</code></pre><h2 id="通配符-Like"><a href="#通配符-Like" class="headerlink" title="通配符 Like"></a>通配符 Like</h2><pre><code>通配符:
    %         匹配任意字符出现任意次数
    _         匹配任意字符一次

例
    WHERE &lt;column&gt; LIKE &apos;word%&apos; 
</code></pre><h2 id="正则表达式-REGEXP"><a href="#正则表达式-REGEXP" class="headerlink" title="正则表达式 REGEXP"></a>正则表达式 REGEXP</h2><pre><code>例
    WHERE prod_name REGEXP &apos;1000&apos;           列中包含1000
    WHERE prod_name REGEXP &apos;.000&apos;           . 匹配任意字符
    WHERE prod_name REGEXP &apos;1000|2000&apos;      | 为或者
    WHERE prod_name REGEXP &apos;[123] Ton&apos;      匹配 [] 内的几个字符之一 
    WHERE prod_name REGEXP &apos;[1-5] Ton&apos;      范围匹配
    WHERE vend_name REGEXP &apos;\\.&apos;            \\为转义字符,匹配后面的特殊字符

字符类
    [:alnum:]     任意字母和数字（同[a-zA-Z0-9]）
    [:alpha:]     任意字符（同[a-zA-Z]）
    [:blank:]     空格和制表（同[\\t]）
    [:cntrl:]     ASCII控制字符（ASCII 0到31和127）
    [:digit:]     任意数字（同[0-9]）
    [:graph:]     与[:print:]相同，但不包括空格
    [:lower:]     任意小写字母（同[a-z]）
    [:print:]     任意可打印字符
    [:punct:]     既不在[:alnum:]又不在[:cntrl:]中的任意字符
    [:space:]     包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）
    [:upper:]     任意大写字母（同[A-Z]）
    [:xdigit:]    任意十六进制数字（同[a-fA-F0-9]）

重复元字符
    -             0个或多个匹配
    *             1个或多个匹配（等于{1,}）
    ?             0个或1个匹配（等于{0,1}）
    {n}           指定数目的匹配
    {n,}          不少于指定数目的匹配
    {n,m}         匹配数目的范围（m不超过255）

定位符
    ^             文本的开始
    $             文本的结尾
    [[:           词的开始
    [[:&gt;:]]       词的结尾
</code></pre><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><pre><code>相关函数
    Concat()          拼接
    RTrim()           去掉右边空格
    LTrim()           去掉左边空格
    Trim()            去空格
    Now()             返回当前日期和时间

别名
    AS &lt;alias&gt;        给予列一个别名,可用于 列 和 表

算术操作符
    +      加
    -     减
    *     乘
    /      除

例
    SELECT Concat(column_1,column_2,...) FROM vendors
    SELECT column_1,column_2,column_1 * column_2 AS alias FROM table
    SELECT column AS alias FROM table AS t
</code></pre><h2 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h2><pre><code>文本处理函数
    Left()                返回串左边的字符
    Length()              返回串的长度
    Locate()              找出串的一个子串
    Lower()               将串转换为小写
    LTrim()               去掉串左边的空格
    Right()               返回串右边的字符
    RTrim()               去掉串右边的空格
    Soundex()             返回串的SOUNDEX值
    SubString()           返回子串的字符
    Upper()               将串转换为大写
    Convert()             转换字符集

日期和时间处理函数
    AddDate()             增加一个日期（天、周等）
    AddTime()             增加一个时间（时、分等）
    CurDate()             返回当前日期
    CurTime()             返回当前时间
    Date()                返回日期时间的日期部分
    DateDiff()            计算两个日期之差
    Date_Add()            高度灵活的日期运算函数
    Date_Format()         返回一个格式化的日期或时间串
    Day()                 返回一个日期的天数部分
    DayOfWeek()           对于一个日期，返回对应的星期几
    Hour()                返回一个时间的小时部分
    Minute()              返回一个时间的分钟部分
    Month()               返回一个日期的月份部分
    Now()                 返回当前日期和时间
    Second()              返回一个时间的秒部分
    Time()                返回一个日期时间的时间部分
    Year()                返回一个日期的年份部分

数值处理函数
    Abs()                 返回一个数的绝对值
    Cos()                 返回一个角度的余弦
    Exp()                 返回一个数的指数值
    Mod()                 返回除操作的余数
    Pi()                  返回圆周率
    Rand()                返回一个随机数
    Sin()                 返回一个角度的正弦
    Sqrt()                返回一个数的平方根
    Tan()                 返回一个角度的正切
</code></pre><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><pre><code>聚集函数
    AVG()                 返回某列的平均值
    COUNT()               返回某列的行数，除COUNT(*)外忽略NULL值
    MAX()                 返回某列的最大值
    MIN()                 返回某列的最小值
    SUM()                 返回某列值之和

DISTINCT 只聚集不同的值
    例: SELECT AVG(DISTINCT &lt;column&gt;) FROM &lt;table&gt;;
</code></pre><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><pre><code>GROUP BY  分组
    例: SELECT &lt;column&gt;, COUNT(*) FROM &lt;table&gt; GROUP BY &lt;column&gt;;
    GROUP BY &lt;column&gt; WITH ROLLUP  可得到每个分组以及每个分组汇总级别的值

HAVING  在分组后进行过滤
    例: SELECT &lt;column&gt; FROM &lt;table&gt; GROUP BY &lt;column&gt; HAVING &lt;condition&gt;;
</code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><pre><code>例: SELECT &lt;column&gt; FROM &lt;table&gt; WHERE &lt;column&gt; IN (SELECT ...);
</code></pre><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><pre><code>概念 
    内部联结: 也称为等值联结（equijoin），它基于两个表之间的相等测试。
    外部联结: 连接时需要包含没有关联行的那些行，分为左外部联结和右外部联结
    自然联结: 排除多次重复的列出现，使每个列只返回一次。

关键字
    INNER JOIN ON               内部联结
    LEFT OUTER JOIN ON          左外部联结
    RIGHT OUTER JOIN            右外部联结

例: 
    SELECT &lt;column-1&gt;,&lt;column-2&gt; FROM &lt;table-1&gt; INNER JOIN &lt;table-2&gt; ON table-1.column = table-2.column
例:
    SELECT &lt;column-1&gt;,&lt;column-2&gt; FROM &lt;table-1&gt;, &lt;table-2&gt; WHERE table-1.column = table-2.column
例:
    SELECT &lt;column-1&gt;,&lt;column-2&gt; FROM &lt;table-1&gt; LEFT OUTER JOIN &lt;table-2&gt; ON table-1.column = table-2.column
例:
    SELECT &lt;column-1&gt;,&lt;column-2&gt; FROM &lt;table-1&gt; RIGHT OUTER JOIN &lt;table-2&gt; ON table-1.column = table-2.column
</code></pre><h2 id="组合查询-UNION"><a href="#组合查询-UNION" class="headerlink" title="组合查询 UNION"></a>组合查询 UNION</h2><pre><code>概念: 
    执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。通常称为并（union）或复合查询（compoundquery）。

UNION规则:
    UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔
    UNION中的每个查询必须包含相同的列、表达式或聚集函数
    列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型
    只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后
    UNION 会自动去除重复的行，UNION ALL 不会

例: 
    SELECT &lt;column&gt; FROM &lt;table&gt; UNION SELECT &lt;column&gt; FROM &lt;table&gt;;
例:
    SELECT &lt;column&gt; FROM &lt;table&gt; UNION ALL SELECT &lt;column&gt; FROM &lt;table&gt;;
</code></pre><h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><pre><code>支持引擎: MyISAM 支持全文搜索，但 InnoDB 不支持

如何启用: CREATE 创建表时，通过 FULLTEXT(&lt;column&gt;) 指定须全文搜索的列，可多个。

等级值与排序
    全文搜索 相对与 LIKE 会对结果进行排序，排序依赖与计算出的等级值
    Match()和Against()用来建立一个计算列-搜索计算出的等级值 
    SELECT &lt;column&gt; Match(&lt;column&gt;) Against(&lt;text&gt;) AS &lt;alias&gt; FROM &lt;table&gt;

忽略的词
    短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词，可修改。
    MySQL带有一个内建的非用词（stopword）列表，这些词被忽略，可覆盖。
    如果一个词出现在50%以上的行中，则将它作为一个非用词忽略，不适用IN BOOLEAN MODE
    如果表中的行数少于3行，则全文本搜索不返回结果，因为50%规则
    忽略词中的单引号。例如，don&apos;t 索引为 dont
    不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果

相关函数
    Match()        指定被搜索的列，传递给Match()的值必须与FULLTEXT()定义中的相同
    Against()      指定要使用的搜索表达式，除BINARY方式，否则不区分大小写

例:
    SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&lt;text&gt;)

查询扩展
    概念: 基于所查询出来的行内的的关键字进行再次查询，扩展出更多的结果。
    关键字: WITH QUERY EXPANSION
    例: 
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&lt;text&gt;,WITH QUERY EXPANSION)

布尔文本搜索
    概念: 可实现要匹配的词，要排斥的词，排列提示，表达式分组等，无FULLTEXT索引也可使用
    关键字: IN BOOLEAN MODE
    全文本布尔操作符
        +       包含，词必须存在
        -       排除，词必须不出现
        &gt;       包含，而且增加等级值
        &lt;       包含，且减少等级值
        ()      把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）
        ~       取消一个词的排序值
        *       词尾的通配符
        &quot;&quot;      定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）
    例:
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&lt;text&gt;,IN BOOLEAN MODE)
    例 包含text1,排除text2开头的行:
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&apos;text1 -text2*&apos;,IN BOOLEAN MODE)
    例 包含text1 和 text2 的行:
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&apos;+text1 +text2&apos;,IN BOOLEAN MODE)
    例 包含text1 或 text2 的行:
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&apos;text1 text2&apos;,IN BOOLEAN MODE)
    例 包含text1 text2 的行:
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&apos;&quot;text1 text2&quot;&apos;,IN BOOLEAN MODE)
    例 包含text1 或 text2 增加前者的等级，降低后者的等级:
        SELECT &lt;column&gt; FROM &lt;table&gt; WHERE Match(&lt;column&gt;) Against(&apos;&gt;text1 &lt;text2&apos;,IN BOOLEAN MODE)
</code></pre><h2 id="数据插入-INSERT"><a href="#数据插入-INSERT" class="headerlink" title="数据插入 INSERT"></a>数据插入 INSERT</h2><pre><code>插入完整的行
    两种语法
        INSERT INTO &lt;table&gt; VALUES(value-1,value2);
        INSERT INTO &lt;table&gt;(column-1,column-2) VALUES(value-1,value2);
    省略列
        该列定义为允许NULL值（无值或空值）
        在表定义中给出默认值。这表示如果不给出值，将使用默认值
    降低优先级
        INSERT LOW_PRIORITY INTO

插入多个行
    INSERT INTO &lt;table&gt;(column-1,column-2) VALUES(value-1,value2),(value-1,value2);

插入检索出的数据
    INSERT INTO &lt;table-1&gt;(column-1,column-2) SELECT column-1,column-2 FROM &lt;table-2&gt;;
</code></pre><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><pre><code>更新特定行
    UPDATE &lt;table&gt; SET column-1=value-1,column-2=value-2 WHERE &lt;condition&gt;;

更新所有行
    UPDATE &lt;table&gt; SET column-1=value-1,column-2=value-2;

或略发生错误
    UPDATE IGNORE &lt;table&gt; ...
</code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre><code>删除特定的行
    DELETE FROM &lt;table&gt; WHERE &lt;condition&gt;;

删除所有行
    DELETE FROM &lt;table&gt;;

更快的删除(删除原表，重建新表) 
    TRUNCATE TABLE ...
</code></pre><h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><pre><code>关键字
    AUTO_INCREMENT                   自动增量
    NOT NULL                         不允许NULL值
    NULL                             允许NULL值
    PRIMARY KEY (column[,column-1])  主键，可指定多个列
    DEFAULT &lt;value&gt;                  指定默认值
    ENGINE=&lt;engine-type&gt;             指定引擎类型

引擎类型
    InnoDB   可靠的事务处理引擎，不支持全文本搜索；
    MEMORY   在功能等同于MyISAM，数据存储在内存中，速度很快，适合于临时表
    MyISAM   是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。

创建表 例
    CREATE TABLE &lt;table&gt;
    (
      column-1   int            NOT NULL AUTO_INCREMENT,
      column-2   char(50)       NOT NULL ,
      column-4   decimal(8,2)   NULL  DEFAULT 1,
      PRIMARY KEY (column-1, column-2)
      ...
    ) ENGINE=InnoDB;

更新表
    增加列
        ALTER TABLE &lt;table&gt; ADD &lt;column&gt; &lt;datatype&gt;;
    删除列
        ALTER TABLE &lt;table&gt; DROP COLUMN &lt;column&gt;;

删除表
    DROP TABLE &lt;table&gt;;

重命名表
    重命名一个表
        RENAME TABLE &lt;old-table&gt; TO &lt;new-table&gt;;
    重命名多个表
        RENAME TABLE &lt;old-table&gt; TO &lt;new-table&gt;,&lt;old-table&gt; TO &lt;new-table&gt;;
</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><pre><code>概念:
    视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。

为什么使用视图:
    重用SQL语句。
    简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。
    使用表的组成部分而不是整个表。
    保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。
    更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。

视图的规则和限制
    与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。
    对于可以创建的视图数目没有限制。
    为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。
    视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。
    ORDER BY可以用在视图中
    视图不能索引，也不能有关联的触发器或默认值。
    视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。

语法
    CREATE VIEW &lt;viewname&gt; AS ...    创建视图
    SHOW CREATE VIEW &lt;viewname&gt;;     查看创建视图的语句
    DROP VIEW &lt;viewname&gt;;            删除视图
    CREATE OR REPLACE VIEW           创建或更新视图

如下情况下视图无法被更新
    分组（使用GROUP BY和HAVING）；
    联结；
    子查询；
    并；
    聚集函数（Min()、Count()、Sum()等）；
    DISTINCT；
    导出（计算）列。
</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><pre><code>执行存储过程
    语法
        CALL &lt;procedure&gt;([@param[,...]])

创建存储过程
    语法
        CREATE PROCEDURE &lt;procedure&gt;([[IN|OUT|INOUT] param datatype [,..]])
        BEGIN
           ...
        END;
    命令行存储过程中的语句包含分隔符
        原理: DELIMITER 可临时修改语句分隔符
        例:
            DELIMITER //
            CREATE PROCEDURE productpricing()
            BEGIN
               SELECT Avg(prod_price) AS priceaverage
               FROM products;
            END //
            DELIMITER ;

删除存储过程
    DROP PROCEDURE &lt;procedure&gt;

变量
    规则
        变量名必须以 @ 开始
    关键字
        IN       传递给存储过程
        OUT      从存储过程传出，如这里所用
        INOUT    对存储过程传入和传出
    调用变量 例:
        SELECT @&lt;param&gt;;
    创建存储过程中使用变量 例:
        CREATE PROCEDURE &lt;procedure&gt;(
           OUT &lt;param&gt; INT
        )
        BEGIN
           SELECT &lt;column&gt; INTO param FROM &lt;table&gt;;
        END;

检查存储过程
    SHOW CREATE PROCEDURE &lt;procedure&gt;;
</code></pre><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><pre><code>概念  
    在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。
    只能用于存储过程（和函数）

使用步骤
    创建游标 --&gt; 打开游标 --&gt; 检索各行 --&gt; 关闭游标

创建游标
    语法:
        DECLARE &lt;cursor_name&gt; CURSOR FOR &lt;select_statement&gt;
    例:
        CREATE PROCEDURE &lt;procedure&gt;()
        BEGIN
           DECLARE &lt;cursor_name&gt; CURSOR
           FOR
           SELECT &lt;column&gt; FROM &lt;table&gt;;
        END;

打开游标
    OPEN &lt;cursor_name&gt;;

关闭游标
    CLOSE &lt;cursor_name&gt;;

使用游标数据
    FETCH [[NEXT] FROM] &lt;cursor_name&gt; INTO &lt;var_name&gt;; 
</code></pre><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><pre><code>支持触发器的语句
    DELETE; INSERT; UPDATE; BEGIN ... END;

创建触发器
    Tip
        仅支持表 只有表才支持触发器，视图和临时表不支持。
        每个表每个事件每次只允许一个触发器
        如果BEFORE触发器失败，MySQL将不执行请求的操作
    需要信息
        trigger_name     触发器名
        trigger_time     { BEFORE | AFTER }
        trigger_event    { INSERT | UPDATE | DELETE }
        trigger_order    { FOLLOWS | PRECEDES } other_trigger_name
    语法
        CREATE TRIGGER &lt;trigger_name&gt;
            &lt;trigger_time&gt; &lt;trigger_event&gt; ON &lt;table&gt;
            FOR EACH ROW
            [trigger_order]
            &lt;rigger_body&gt;

删除触发器
    Tip
        触发器不能更新或覆盖。只能删除后重新创建。
    语法
        DROP TRIGGER &lt;trigger_name&gt;;

使用触发器
    INSERT触发器
        在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行
        在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）
        AUTO_INCREMENT列:NEW在INSERT之前包含0，INSERT之后包含新的自动生成值
    DELETE触发器
        可以引用一个名为OLD的虚拟表，访问被删除的行
        OLD中的值全都是只读的，不能更新
    UPDATE触发器
        可以引用一个名为OLD的虚拟表访问更新之前的值，名为NEW的虚拟表访问新更新的值
        在BEFORE UPDATE触发器中，NEW中的值可能也被更新
        OLD中的值全都是只读的，不能更新
</code></pre><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><pre><code>概念
    用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。

事物开始
    START TRANSACTION

回滚
    ROLLBACK

提交
    概念
        一般的MySQL语句都是直接针对数据库表执行和编写的，提交（写或保存）操作是自动进行的
        在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句
        当COMMIT或ROLLBACK语句执行后，事务会自动关闭
    例:
        START TRANSACTION;
        DELETE FROM &lt;table&gt;;
        COMMIT;

保留点
    创建保留点
        SAVEPOINT &lt;identifier&gt;;
    回滚至保留点
        ROLLBACK TO &lt;identifier&gt;;
    释放保留点
        自动释放
            保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放
        明确释放
            RELEASE SAVEPOINT

设置默认提交
    SET autocommit=[0|1];
</code></pre><h2 id="字符集和语言"><a href="#字符集和语言" class="headerlink" title="字符集和语言"></a>字符集和语言</h2><pre><code>相关概念
    字符集   字母和符号的集合
    编码　   某个字符集成员的内部表示
    校对　   规定字符如何比较的指令

查看支持的字符集列表
    SHOW CHARACTER SET;

查看所支持校对的完整列表
    SHOW COLLATION;
        _cs  区分大小写
        _ci  不区分大小写

查看正在使用的字符集
    SHOW VARIABLES LIKE &apos;character%&apos;;

查看正在使用的校对
    SHOW VARIABLES LIKE &apos;collation%&apos;;

创建表时指定字符集和校对
    CREATE TABLE &lt;table&gt;
    (
        ...
    ) DEFAULT CHARACTER SET hebrew
      COLLATE hebrew_general_ci;

为每个列单独设置校对
    CREATE TABLE &lt;table&gt;
    (
       columnn1   INT,
       columnn2    VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci
    ) DEFAULT CHARACTER SET hebrew
      COLLATE hebrew_general_ci;

在语句中指定校对
    SELECT * FROM &lt;table&gt; ORDER BY &lt;column&gt; COLLATE latin1_general_cs;
</code></pre><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><pre><code>Tip:
    帐号信息存储在 mysql 数据库中

获取所有帐号密码
    SELECT user FROM user;

创建帐号
    CREATE USER &lt;username&gt; IDENTIFIED BY &lt;password&gt;;

重命名帐号
    RENAME USER &lt;username&gt; TO &lt;newUserName&gt;;

修改自己的密码
    SET PASSWORD = Password(&lt;password&gt;);

修改其他用户密码
    SET PASSWORD FOR &lt;username&gt; = Password(&lt;password&gt;);

删除用户账号
    DROP USER &lt;username&gt;;

查看账户权限
    SHOW GRANTS FOR &lt;username&gt;;

设置权限
    语法
        GRANT &lt;priv_type&gt; ON &lt;priv_level&gt; TO &lt;username&gt;;
    例 允许用户user在db数据库中的所有表中使用SELECT:
        GRANT SELECT ON db.* TO user;

取消权限
    语法
        REVOKE &lt;priv_type&gt; ON &lt;priv_level&gt; FROM &lt;username&gt;;

权限说明
    ALL                        除GRANT OPTION外的所有权限
    ALTER                      使用ALTER TABLE
    ALTER ROUTINE              使用ALTER PROCEDURE和DROP PROCEDURE
    CREATE                     使用CREATE TABLE
    CREATE ROUTINE             使用CREATE PROCEDURE
    CREATE TEMPORARY TABLES    使用CREATE TEMPORARY TABLE
    CREATE USER                使用CREATE USER、DROP USER、RENAME USER
                               和REVOKE ALL PRIVILEGES
    CREATE VIEW                使用CREATE VIEW
    DELETE                     使用DELETE
    DROP                       使用DROP TABLE
    EXECUTE                    使用CALL和存储过程
    FILE                       使用SELECT INTO OUTFILE和LOAD DATA INFILE
    GRANT OPTION               使用GRANT和REVOKE
    INDEX                      使用CREATE INDEX和DROP INDEX
    INSERT                     使用INSERT
    LOCK TABLES                使用LOCK TABLES
    PROCESS                    使用SHOW FULL PROCESSLIST
    RELOAD                     使用FLUSH
    REPLICATION CLIENT         服务器位置的访问
    REPLICATION SLAVE          由复制从属使用
    SELECT                     使用SELECT
    SHOW DATABASES             使用SHOW DATABASES
    SHOW VIEW                  使用SHOW CREATE VIEW
    SHUTDOWN                   使用mysqladmin shutdown（用来关闭MySQL）
    SUPER                      使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER
                               和SET GLOBAL。还允许mysqladmin调试登录
    UPDATE                     使用UPDATE
    USAGE                      无访问权限
</code></pre><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><pre><code>备份数据库
    Tip:
        由于数据库文件总是处于打开和使用状态，普通的文件备份不一定总是有效
        为了保证所有数据被写到磁盘，可能需要在进行备份前使用FLUSH TABLES语句
    命令行工具
        mysqldump             转存所有的数据库至外部文件
        mysqlhotcopy          从一个数据库复制所有工具
    MySQL命令
        BACKUP TABLE          转储所有数据到某个外部文件
        SELECT INTO OUTFILE   转储所有数据到某个外部文件
        RESTORE TABLE         复原数据

进行数据库维护
    检查表键是否正确
        ANALYZE TABLE &lt;table&gt;;
    针对更多问题对表进行检查
        语法
            CHECK TABLE &lt;table&gt; ... [option] ...;
        支持的检查方式
            QUICK        只进行快速扫描
            FAST         只检查未正常关闭的表
            MEDIUM       检查所有被删除的链接并进行键检验
            EXTENDED     执行最彻底的检查
            CHANGED      检查自最后一次检查以来改动过的表
    修复表(不应经常使用)
        REPAIR TABLE
    回收删除大量数据后的空间
        OPTIMIZE TABLE

查看日志文件
    日志类型
        错误日志
            包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。此日志名可用--log-error命令行选项更改。
        查询日志
            记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用--log命令行选项更改。
        二进制日志
            它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用--log-bin命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。
        缓慢查询日志
            顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log，位于data目录中。此名字可以用--log-slow-queries命令行选项更改。
    刷新日志
        FLUSH LOGS
</code></pre><h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><pre><code>查看配置
    SHOW VARIABLES;
    SHOW STATUS;

进程
    显示活动的进程
        SHOW PROCESS LIST
    杀掉进程
        KILL

推迟执行关键字
    DELAYED
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/12/MongoDB-笔记/" itemprop="url">
                  MongoDB-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-12T11:47:52+08:00" content="2016-07-12">
              2016-07-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文为阅读<a href="http://wiki.jikexueyuan.com/project/mongodb/" target="_blank" rel="external">极客学院 - Mongodb 教程</a>时的笔记，内容主要为知识点的梳理和备忘，建议大家查看原版。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>collection   集合就是一组 MongoDB 文档。相当于关系型数据库（RDBMS）中的表这种概念
document     文档就是一组键-值对。文档有着动态的模式
_id          12位十六进制数，它保证了每一个文档的唯一性。插入文档时如不提供会自动生成。
             组成:当前的时间戳(4位)，机器id号(3位)，服务器进程id(4位)，递增值(2位)
</code></pre><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><pre><code>MongoDB 相比 RDBMS 的优势
    模式较少
    采用单个对象的模式，清晰简洁
    没有复杂的连接功能
    深度查询功能MongoDB，支持对文档执行动态查询
    具有调优功能
    易于扩展
    不需要从应用对象到数据库对象的转换/映射
    使用内部存储存储（窗口化）工作集，能够更快地访问数据

为何选择使用 MongoDB
    面向文档的存储：以 JSON 格式的文档保存数据。
    任何属性都可以建立索引。
    复制以及高可扩展性。
    自动分片。
    丰富的查询功能。
    快速的即时更新。
    来自 MongoDB 的专业支持。

MongoDB 适用的领域
    大数据
    内容管理及交付
    移动及社会化基础设施
    用户数据管理
    数据中心
</code></pre><h2 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h2><pre><code>安装
    apt-get install mongodb

启动服务
    sudo service mongodb start|stop|restart

使用客户端
    mongo

获得帮助
    hlep                客户端帮助
    db.help()           数据库方法帮助
    db.mycoll.help()    集合方法帮助 

MongoDB 统计信息
    客户端中输入 db.stat()
</code></pre><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><pre><code>创建或切换数据库
    use DATABASE_NAME

查看当前选定的数据库
    db

查看数据库列表
    show dbs

删除选中的数据库
    db.dropDatabase()
</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><pre><code>创建集合
    语法
        db.createCollection(name, options) 
            name      字符串 所要创建的集合名称
            options   文档 可选。指定有关内存大小及索引的选项
                capped       布尔 (可选) 是否创建固定大小的集合。
                autoIndexID  布尔 (可选) 是否在_id字段创建索引，默认false
                size         数值 capped为true时必选。指定一个最大值（以字节计）
                max          数值 (可选) 指定固定集合中包含文档的最大数量。
    范例
        不带有选项
            db.createCollection(&quot;mycollection&quot;)
        带有选项
            db.createCollection(&quot;mycollection&quot;, {
                capped : true, 
                autoIndexID : 
                true, size : 6142800, 
                max : 10000 
            })

查看集合
    show collections

删除集合
    db.COLLECTION_NAME.drop()
</code></pre><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><pre><code>String               字符串。存储数据常用的数据类型。编码为UTF-8
Integer              整型数值。根据你所采用的服务器，可分为 32 位或 64 位
Boolean              布尔值
Double               双精度浮点值。用于存储浮点值
Min/Max keys         将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比
Arrays               用于将数组或列表或多个值存储为一个键
Timestamp            时间戳。记录文档修改或添加的具体时间
Object               用于内嵌文档
Null                 用于创建空值
Symbol               符号。类似字符串，不同的是它一般用于采用特殊符号类型的语言
Date                 日期时间。UNIX 时间格式
Object ID            对象 ID。用于创建文档的 ID
Binary Data          二进制数据。用于存储二进制数据
Code                 代码类型。用于在文档中存储 JavaScript 代码
Regular expression   正则表达式类型。用于存储正则表达式
</code></pre><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><pre><code>插入文档
    语法
        db.COLLECTION_NAME.insert(document)
    范例
        db.mycol.insert({
           _id: ObjectId(7df78ad8902c)
        })
    范例
        db.mycol.insert([
            {
               title: &apos;MongoDB Overview&apos;
            },
            {
               title: &apos;NoSQL Database&apos;
            }
        ])

查询文档
    语法
        db.COLLECTION_NAME.find()             查询所有文档
        db.COLLECTION_NAME.findOne()          只返回一个文档
        db.COLLECTION_NAME.find().pretty()    格式化查询内容
    条件查询
        等于  
            {&lt;key&gt;:&lt;value&gt;} 
            db.mycol.find({&quot;by&quot;:&quot;tutorials point&quot;}).pretty()    
        小于  
            {&lt;key&gt;:{$lt:&lt;value&gt;}}   
            db.mycol.find({&quot;likes&quot;:{$lt:50}}).pretty()  
        小于或等于   
            {&lt;key&gt;:{$lte:&lt;value&gt;}}  
            db.mycol.find({&quot;likes&quot;:{$lte:50}}).pretty() 
        大于  
            {&lt;key&gt;:{$gt:&lt;value&gt;}}   
            db.mycol.find({&quot;likes&quot;:{$gt:50}}).pretty()  
        大于或等于   
            {&lt;key&gt;:{$gte:&lt;value&gt;}}  
            db.mycol.find({&quot;likes&quot;:{$gte:50}}).pretty() 
        不等于 
            {&lt;key&gt;:{$ne:&lt;value&gt;}}   
            db.mycol.find({&quot;likes&quot;:{$ne:50}}).pretty()
    AND 条件
        语法
            db.COLLECTION_NAME.find({key1:value1, key2:value2}).pretty()
    OR 条件
        语法
            db.COLLECTION_NAME.find({$or:[{key1:value1}, {key2:value2}]}).pretty()
    结合 AND 与 OR 条件
        语法
            db.COLLECTION_NAME.find(key1:value1,$or:[{key2:value2}, {key3:value3}]).pretty()

更新文档
    语法 update
        db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA)
    范例
        db.mycol.update({&apos;title&apos;:&apos;MongoDB Overview&apos;},{$set:{&apos;title&apos;:&apos;New MongoDB Tutorial&apos;}})
    范例 更新多个文档
        db.mycol.update({&apos;title&apos;:&apos;MongoDB Overview&apos;},{$set:{&apos;title&apos;:&apos;New MongoDB Tutorial&apos;}},{multi:true})
    语法 save
        db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})
    范例
        db.mycol.save({&quot;_id&quot;:ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Tutorials Point New Topic&quot;, &quot;by&quot;:&quot;Tutorials Point&quot;})

删除文档
    语法
        删除所有符合的文档
            db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)
        只删除符合的第一条文档
            db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)
        删除所有文档
            db.COLLECTION_NAME.remove()
    范例
        db.mycol.remove({&apos;title&apos;:&apos;MongoDB Overview&apos;})
</code></pre><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><pre><code>概念
    映射（Projection）指的是只选择文档中的必要数据，而非全部数据。

语法
    db.COLLECTION_NAME.find({...},{KEY:1|0})

范例 显示title 不显示_id
    db.mycol.find({...},{&quot;title&quot;:1,_id:0})
</code></pre><h2 id="限制记录"><a href="#限制记录" class="headerlink" title="限制记录"></a>限制记录</h2><pre><code>limit()
    概念
        显示查询结果中前两条数据
    语法
        db.COLLECTION_NAME.find().limit(NUMBER)

skip()
    概念
        跳过指定条数数据显示
    语法
        db.COLLECTION_NAME.find().skip(NUMBER)
</code></pre><h2 id="记录排序"><a href="#记录排序" class="headerlink" title="记录排序"></a>记录排序</h2><pre><code>sort()
    语法
        db.COLLECTION_NAME.find().sort({KEY:1|-1})
    说明
        sort() 方法可以通过一些参数来指定要进行排序的字段，1表示升序，-1表示降序。
</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><pre><code>创建索引 ensureIndex()
    语法
        db.COLLECTION_NAME.ensureIndex({KEY:1[,options]}
    说明
        key 是想创建索引的字段名称，1 代表按升序排列字段值。-1 代表按降序排列。
    options 说明
        background          布尔值 在后台构建索引，默认值为 false
        unique              布尔值 创建一个唯一的索引，默认值为 false。
        name                字符串 索引名称。如果未指定，MongoDB自动生成
        dropDups            布尔值 在可能有重复的字段内创建唯一性索引。。
        sparse              布尔值 如果为 true，索引只引用带有指定字段的文档
        expireAfterSeconds  整型值 单位秒，控制 MongoDB 保持集合中文档的时间。
        v                   索引版本 索引版本号。
        weights             文档  数值，范围从 1 到 99, 999。表示重要性。
        default_language    字符串 用于确定停止词列表，以及词干分析器（stemmer）
                            与断词器（tokenizer）的规则。默认值为 english。
        language_override   字符串 对文本索引而言，指定了文档所包含的字段名
                            该语言将覆盖默认语言。默认值为 language。
    范例 为多个字段建立索引
        db.mycol.ensureIndex({&quot;title&quot;:1,&quot;description&quot;:-1})
</code></pre><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><pre><code>概念
    聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 SQL 中的 count(*) 组合 group by。

语法
    db.mycoll.aggregate([pipeline], &lt;optional params&gt; )

聚合表达式列表
    $sum
        描述  
            对集合中所有文档的定义值进行加和操作  
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, num : {$sum : &quot;$likes&quot;}}}])
    $avg
        描述
            对集合中所有文档的定义值进行平均值   
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, num : {$avg : &quot;$likes&quot;}}}])
    $min
        描述
            计算集合中所有文档的对应值中的最小值  
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, num : {$min : &quot;$likes&quot;}}}])
    $max
        描述
            计算集合中所有文档的对应值中的最大值  
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, num : {$max : &quot;$likes&quot;}}}])
    $push
        描述
            将值插入到一个结果文档的数组中 
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, url : {$push: &quot;$url&quot;}}}])
    $addToSet
        描述
            将值插入到一个结果文档的数组中，但不进行复制  
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, url : {$addToSet : &quot;$url&quot;}}}])
    $first
        描述
            根据成组方式，从源文档中获取第一个文档。但只有对之前应用过 $sort 管道操作符的结果才有意义。   
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, first_url : {$first : &quot;$url&quot;}}}])
    $last
        描述
            根据成组方式，从源文档中获取最后一个文档。但只有对之前进行过 $sort 管道操作符的结果才有意义。  
        范例
            db.mycol.aggregate([{$group : {_id : &quot;$key&quot;, last_url : {$last : &quot;$url&quot;}}}])

pipeline
    概念
        能够在一些输入上执行一个操作，然后将输出结果用作下一个命令的输入。MongoDB 的聚合架构也支持这种概念。管道中有很多阶段（stage），在每一阶段中，管道操作符都会将一组文档作为输入，产生一个结果文档（或者管道终点所得到的最终 JSON 格式的文档），然后再将其用在下一阶段。
    管道操作符
        $project  用来选取集合中一些特定字段。
        $match    过滤操作。减少用作下一阶段输入的文档的数量。
        $group    如上所述，执行真正的聚合操作。
        $sort     对文档进行排序。
        $skip     在一组文档中，跳过指定数量的文档。
        $limit    将查看文档的数目限制为从当前位置处开始的指定数目。
        $unwind   解开使用数组的文档。当使用数组时，数据处于预连接状态，
                  通过该操作，数据重新回归为各个单独的文档的状态。
                  利用该阶段性操作可增加下一阶段性操作的文档数量。
</code></pre><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><pre><code>概念
    复制是一种在多个服务器上同步数据的过程。通过在不同的数据库服务器上实现多个数据副本，复制能够实现数据冗余，提高数据的可用性，从而避免了仅仅因为一台服务器故障后就会产生的数据库灾难。

为什么需要复制
    保持数据安全
    保证数据的高可用性（24 小时 × 7 天，全年无休）
    灾难恢复
    无需停机维护（比如进行备份、索引重建，压缩等任务）
    读取的可扩展性（可读取其他副本）
    副本集对应用的公开性

复制在 MongoDB 中的运作方式
    概念
        MongoDB 使用副本集（replica set）来实现复制操作。副本集是一组托管同一数据集的 mongod 对象。在副本集中，主节点负责接收写入操作。所有其他的实例（从节点）则通过执行主节点的操作来拥有同样的数据集。副本集中只有一个主节点。
    运行方式
        副本集具有 2 个或多个节点（但一般最少需要 3 个节点）。
        副本集只有一个主节点，其他全是从节点。
        所有数据都是从主节点复制到从节点上的。
        当发生自动故障转移或维护时，会重新推举一个新的主节点。
        当失败节点恢复后，该节点重新又连接到副本集中，重新作为从节点。

副本集特点
    具有 N 个节点的集群
    任何节点都可能成为主节点
    所有写入操作必须由主节点来完成
    自动故障转移
    自动故障恢复
    重新推举主节点

建立副本集
    命令
        mongod --port &quot;PORT&quot; --dbpath &quot;YOUR_DB_DATA_PATH&quot; --replSet &quot;REPLICA_SET_INSTANCE_NAME&quot;
    范例
        mongod --port 27017 --dbpath &quot;D:\set up\mongodb\data&quot; --replSet rs0
    说明
        该命令会在端口 27017 处启动一个名为 rs0 的 MongoDB 实例。在命令行提示符上输入命令连接到该 MongoDB 对象上。在 MongoDB 客户端使用 rs.initiate() 命令来初始化一个新的副本集。检查该副本集设置，则需使用 rs.conf()。检查副本集状态使用 rs.status()。

为副本集添加成员
    语法
        rs.add(HOST_NAME:PORT)
</code></pre><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><pre><code>概念
    分片是一种在多台机器上存储数据记录的操作，它是 MongoDB 为应对数据增长需求而采取的办法。当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。通过横向扩展，分片技术解决了这个问题。利用分片技术，我们可以添加更多的机器来应对数据量增加以及读写操作的要求

为何要分片
    将所有的写入操作复制到主节点
    对延迟敏感的查询将在主节点上完成
    单个副本集的节点数限制为 12 个
    当活跃数据集过大时，内存有可能不够
    本地磁盘空间不足
    纵向扩展太过昂贵
</code></pre><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><pre><code>创建备份
    mongodump

恢复备份
    mongorestore
</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre><code>mongostat
    该命令检查所有运行中的 mongod 实例的状态，返回数据库操作的统计结果。这些统计命令包括插入数、查询数、更新数、删除数以及游标的操作等。有些命令还能显示碰到页面错误的时间，以及写锁的时间百分比。这意味着你遇到一些问题：内存低，写入及性能上出现了一些问题。

mongotop
    该命令能够记录并报告 MongoDB 实例基于每个集合的读写活动。mongotop 默认每秒返回一次结果，但我们可以修改间隔时间。你应该检查读写活动是否符合应用预期状态。理想情况下，不应该出现对数据库进行过多的写操作，过于频繁地读取磁盘，或者超出了工作集的容量等情况。
</code></pre><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><pre><code>概念
    MongoDB 中的关系表示文档之间的逻辑相关方式。关系可以通过内嵌（Embedded）或引用（Referenced）两种方式建模。这样的关系可能是 1:1、1:N、N:1，也有可能是 N:N。

内嵌
    {
       &quot;_id&quot;:ObjectId(&quot;52ffc33cd85242f436000001&quot;),
       &quot;address&quot;: [
          {
             &quot;city&quot;: &quot;Los Angeles&quot;,
             &quot;state&quot;: &quot;California&quot;
          },
          {
             &quot;city&quot;: &quot;Chicago&quot;,
             &quot;state&quot;: &quot;Illinois&quot;
          }]
    } 

手动引用       
    {
       &quot;_id&quot;:ObjectId(&quot;52ffc33cd85242f436000001&quot;),
       &quot;address_ids&quot;: [
          ObjectId(&quot;52ffc4a5d85242602e000000&quot;),
          ObjectId(&quot;52ffc4a5d85242602e000001&quot;)
       ]
    }

数据库引用
    字段
        $ref  该字段指定所引用文档的集合。
        $id   该字段指定引用文档的 -id
        $db   该字段是可选的，包含引用文档所在数据库的名称。
    范例
        {
           &quot;_id&quot;:ObjectId(&quot;53402597d852426020000002&quot;),
           &quot;address&quot;: {
               &quot;$ref&quot;: &quot;address_home&quot;,
               &quot;$id&quot;: ObjectId(&quot;534009e4d852427820000002&quot;),
               &quot;$db&quot;: &quot;tutorialspoint&quot;
           }
        }
</code></pre><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><pre><code>[极客学院 - Mongodb 教程](http://wiki.jikexueyuan.com/project/mongodb/)
[MongoDB权威指南](http://www.ituring.com.cn/book/1172)
[官方 - MongoDB Documentation](https://docs.mongodb.com/)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/C语言-笔记/" itemprop="url">
                  C语言-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-11T15:47:52+08:00" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C语言执行流程"><a href="#C语言执行流程" class="headerlink" title="C语言执行流程"></a>C语言执行流程</h2><pre><code>源程序.C --&gt; 编译 --&gt; 目标程序.o --&gt; 链接 --&gt; 可执行文件.out
编译：把源代码翻译成0,1，声称一个.o目标文件
链接：把目标文件和库函数整合成一个.out可执行文件

.h (header)文件作用
    方法的声明，但是不能实现方法
    声明变量
    声明结构体
</code></pre><h2 id="C语言数据类型"><a href="#C语言数据类型" class="headerlink" title="C语言数据类型"></a>C语言数据类型</h2><pre><code>基本类型
    整型
        短整形short
        整形int
        长整型long
    字符型char
    实型
        单精度型float
        双精度型double
构造类型
    数组
    结构体struct
    公用型union
    枚举类型enum
指针类型
空类型void
定义类型typedef

不同的数据类型占用的存储空间
                   16位编译器    32位编译器    64位编译器
    char             1             1            1
    int              2             4            4
    float            4             44           4
    double           8             8            8
    short            2             2            2
    long             4             4            8
    long long        8             8            8
    void*(指针变量)    2             4            8

数组
    一维数组定义
        格式
            类型说明符 数据名[常量表达式];
        范例
            int arr[4];
            float f[10];
            char ch[5+3];
    一维数组初始化
        Tip
            部分初始化的数据的其他值默认为0
            未初始化的数组，数组内元素的值为垃圾数
            元素类型为char类型的数组，部分初始化后其他元素的值为ASCII 0
        格式
            类型说明符 数据名[常量表达式] = {值,值,值....};
        范例
            int arr[4] = {1,2,3,4};
            int arr[3] = {1,2};             只初始化部分元素，未初始化的值默认为0
            int arr[] = {1,2,3};            数据长度根据元素个数决定
            int arr[10] = {[3]=23,[8]=24};  部分初始化，只初始化了下标为3和8的元素
            int arr[4];arr[0] = 1;          先定义再初始化
    在内存中的存储方式
        计算机会给数组分配一块连续的存储空间
        数组名代表数组的首地址，从首地址位置，一次存入数组的每个元素
        每个元素占用相同的字节数（取决于数组类型）
        元素之间的地址是连续的
        数组名代表了数组的首地址 等于数组第一个元素的地址
        数组名是一个常量，存储的就是数组的首地址
    数组计算
        sizeof(数组变量名)                   计算数组占用的总字节数
        sizeof(数组变量名)／sizeof(数组类型)   计算数组长度
    二纬数组
        定义
            int arr[2][3];
        初始化
            int arr[2][3] = {{2,3,4},{1,2,3}};
            int arr[2][3] = {1,2,3,4,5,6};
            int arr[][3] = {{2,3,4},{1,2,3}};
            int arr[][3] = {1,2,3,4,5,6};
        部分初始化
            int arr[2][3] = {1};
            int arr[2][3] = {{1},{2}};

字符串
    Tip
        C语言中没有字符串类型，需用字符数组来存储字符串
        字符串在内存中存储时，以 \0 (ASCII中0代表的字符) 结尾
        因字符串结尾符号，字符串的长度须至少比内容长度多1位
    初始化
        char ch[5] = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;};
        char ch[] = {&apos;a&apos;,&apos;b&apos;,&apos;c&apos;};
        char str[6] = {&quot;abcde&quot;};
        char str[6] = &quot;abcde&quot;;
        char str[] = &quot;abcde&quot;;
    处理函数
        stdio.h
            puts(str)              输出一个字符串
            gets(str)              输入一个字符串
        string.h
            strcat(str,str1)       连接str1至str
            strcpy(oldSte,newStr)  拷贝函数，拷贝newStr覆盖odlStr
            strcmp(str1,str2)      按照ASCII比较两个字符串大小，str1大时返回值&gt;0
            strlen(str)            计算字符串长度，不包含/0

二纬字符数组
    范例
        char str[2][4] = {{'a','b','c'},{'d','e','f'}};
        char str[2][4] = {&apos;abc&apos;,&apos;def&apos;};

const
    说明
        常量类型修饰符，一般用来修饰基本变量或指针变量。
        被const修饰的变量是只读的。
    与宏的区别
        编译时刻 宏:预编译 const:编译
        编译检查 宏:没有编译检查 const:有变异检查
        宏的好处 可以把任意字符串转换为为宏 如:[class method]
        宏的坏处 大量使用时会导致预编译时间过长
    范例
        const int i = 10;
        int i = 10; const int ＊p = &amp;i;         指向可以变，指向变量的值不可以改变
        int i = 10; int ＊ const p = &amp;i;        指向变量的值可以改变。指向不可以变
        int i = 10; const int ＊ const p = &amp;i;  指向变量的值和指向都不可以变

static
    说明
        内部变量修饰符，只能在当前文件使用
        延长局部变量的生命周期，从程序启动到程序退出，但并不改变变量作用域
        定义变量的代码在整个程序运行期间仅仅会执行一次
        被static修饰的局部变量只会分配一次内存
        被static修饰的局部变量在程序一运行就会分配内存
        被static修饰的全局变量，作用域会被修改，只能在当前文件内使用。
    范例
        static int i = 10;

extern
    说明
        extern修饰的变量，可在其他源文件中使用
        无法修饰局部变量
        extern修饰的全局变量在不同文件中不能同名
        函数声明时默认为extern方式
        extern只能用来生命，而不能用来定义。

构造类型
    说明
        构造数据类型是根据已定义的一个或多个数据类型用构造的方法定义的
        一个构造类型的值可以分解成若干个“成员”或“元素” 
        每个元素都是一个基本数据类型或又是一个构造类型
    构造类型种类
        数组类型
        结构体类型
        共用体(联合)类型
    结构体
        说明
            由若干个元素组成，每个元素可以是一个基本数据类型或又是一个构造类型
            和数组的区别是数组内元素的数据类型必须相同，结构体内的元素类型可以不同
        格式
            struct 结构名{
                成员列表
            };
        占用内存
            对齐模数是结构体中基本数据类型占用内存最大的元素的字节数
            计算所有元素的字节数和
            依次填充对齐模数大小的空间，剩余空间不够下个元素存储时，重新分配模数对应字节数的内存空间
        范例
            先定义结构体，再定义结构体变量
                struct Student{
                    int num;
                    char name[20];
                    char sex;
                    float score;
                };
                struct Student stu1={314159,&quot;张柏芝&quot;,&apos;Y&apos;,100};
                struct Student stu2={.name=&quot;张柏芝&quot;};
            定义结构体的同时，定义结构体变量
                struct Student{
                    int num;
                    char name[20];
                    char sex;
                    float score;
                }stu1,stu2,stu3;
                stu1.num = 314159;
                strcpy(stu1.name,&quot;张柏芝&quot;);
            使用匿名结构体，定义定义结构体变量
                struct{
                    int num;
                    char name[20];
                    char sex;
                    float score;
                }stu1,stu2,stu3;
    结构体数组
        说明
            结构数组的每一个元素都是具有相同结构类型的下标结构变量
        格式
            struct 结构名{
                成员列表
            }数组名[数组长度];
        范例
            定义结构体的同时定义数组
                struct Student{
                    char *name;
                    int age;
                }boys[5]={{"A",19},{"B",18},{"C",20}};
                struct Student girls = {{"E",19},{"F",18},{"G",20}};
            先定义结构体再定义数组
                struct Student{
                    char *name;
                    int age;
                };
                struct Student stu[5];
                stu[0] = (struct Student){&quot;E&quot;,19};
                stu[1].name = &quot;ZhangShan&quot;;
    结构体嵌套
        说明
            结构体定义中，结构体的成员为其他结构体变量
            结构体不可以嵌套自己变量，可以嵌套指向自己这种类型的指针
        范例
            struct Date{
                int month;
                int day;
                int year;
            }
            struct Student{
                char *name;
                int num;
                struct Date birth;
            }
            struct Student stu = {&quot;Z&quot;,1001,{12,01,1087}};
            stu.birth.day = 02;
    结构体指针作为函数参数
        注意
            结构体指针作文函数参数时，函数内可修改结构体变量的值
            结构体变量和结构体变量成员做为函数参数时，函数内不可修改结构体变量的值
        范例
            struct Date{
                int month;
                int day;
                int year;
            }
            struct Date date = {12,01,1087};
            void modifiy(struct Date *date1){
                *date1.month = 11;
                return 0;
            }
            modifiy(&amp;date);

枚举类型
    说明
        是一种基本数据类型而非构造类型，因为它不能再分解为各种基本类型
        在枚举类型的定义中列举出了所有可能的取值
        被说名为该枚举类型的变量的值不能超过定义的取值范围
        枚举类型定义后，系统会自动给每个元素赋值，初始默认为0，每个元素为上个元素+1
    格式
        enum 枚举类型名{ 枚举值列表 };
    范例
        enum weekday {sun,mon,tue=10,wed,thu,fri,sat};
        enum weekday day1,day2;
        day1 = sun;

定义类型
    说明
        C语言中允许为数据类型起别名
    格式
        typedef 原类型名 新类型名;
    范例
        用于基本数据类型
            typedef int NUMBER;
            NUMBER i = 10;
            NUMBER *p = &amp;i;
        用于数组
            typedef int ARRAY[5];
            ARRAY arr = {1,2,3,4,5};
        用于结构体
            先定义结构体再定义别名
                struct Person{
                    char *name;
                    int age;
                };
                struct Person man = {&quot;Z&quot;,18};
                typedef struct Person P;
                P woman = {&quot;A&quot;,24};
            定义结构体的同时定义别名
                typedef struct Person{
                    char *name;
                    int age;
                }PERSON;
                PERSON woman = {&quot;A&quot;,24};
            为匿名结构体起别名
                typedef struct{
                    char *name;
                    int age;
                }PERSON;
                PERSON woman = {&quot;A&quot;,24};
        用于枚举
            先定义枚举类型再定义别名
                enum color = {white,black,green};
                typedef enum color COLOR;
            定义枚举类型时同时定义别名
                typedef enum color = {white,black,green} COLOR;
        用于函数指针
            int sum(int a, int b){return a+b;};
            typedef int (*FUN)(int,int);
            FUN f = sum;
            f(1,2);
</code></pre><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre><code>说明
    指针为内存单元的编号也称为地址，通过地址可找到对应内存单元存储的数据。

指针变量
    说明
        C语言中，允许使用一个变量来存放指针，这种变量称为指针变量。
        指针本身是不可变的，但指针变量的值可变
        *加指针变量可获取指针变量指向的内容
    定义格式
        类型说明符 *变量名;
    范例
        int *pi;
        long *pl;
        float *pl;
        char *pc;
    初始化
        int *p = &amp;a;
        int *p = NULL;
        int *p = 0;
    使用
        int a = 0,*p = &amp;a;
        *加指针变量可获取指针变量指向的存储单元
        此时p为a的内存地址，*p为a的值

二级指针
    说明
        一个指针变量存放的另外一个指针变量的地址
    范例
        int a = 1,
            *p = &amp;a,
            **p1 = &amp;p;
        此时 *p1的值为&amp;a，**p1的值为1

数组指针
    说明
        一个指针变量指向一个数组元素，指向数组元素的指针
    范例
        int a[4] = {1,2,3,4}, *p = a;
    使用
        p + 1      指向数组下一个元素, 数组下一个元素的地址
        p - 1      指向数组上一个元素, 数组下一个元素的地址
        *(p + 1)   获取数据下一个元素的值
        *(p - 1)   获取数据上一个元素的值
        p++        改变p变量的值为指向数组下一个元素
        p--        改变p变量的值为指向数组上一个元素

一维指针数组
    说明
        数组的元素的值为指针的数组，
    格式
        类型说明符 *数组名[数组长度]
    范例
        int a = 1, b = 2, c = 3, *p[3] = {&amp;a,&amp;b,&amp;c};
    指针变量运算
        两个指针相减，结果是两个指针说指数组元素之间相差的个数

二纬数组行指针
    说明
        也称为行指针，用来指向二纬数组每一行，存放的是行的首地址
    格式
        数据类型 (*指针变量名)[数组第二纬长度];
    范例
        int a[3][4], (*p)[4] = a;
    使用范例
        *(*(p+i)+j)

字符串指针
    说明
        用来保存字符串
        字符数组保存的数据是在内存栈中，字符串内容可修改，例 str[2]=&apos;W&apos;
        字符串指针保存的是字符串常量的首地址，字符串内容不可修改但可充新指向
    格式
        char *变量名 = &quot;字符串内容&quot;;
    范例
        chr *str = &quot;C Program&quot;

字符串指针数组
    说明
        和二纬数组相比，数组元素长度没有限制，但元素内容不可修改
    范例
        char *str[] = {&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;};

结构指针变量
    说明
        指向结构体变量的指针，结构指针变量中的值指向结构变量的首地址
    格式
        struct 结构名 *结构指针变量名
    范例
        struct Student{
            int num;
            char *name;
            char sex;
            float score;
        };
        struct Student stu={314159,&quot;张柏芝&quot;,&apos;Y&apos;,100};
        struct Student *pstu = &amp;stu;
        (*pstu).num = 1001;
        pstu-&gt;score = 80;
</code></pre><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><pre><code>printf
    格式
        printf(&quot;格式控制字符串&quot;，变量列表)
    格式控制符
        %d        输出一个10进制的整数
        %ld       输出double（实型）类型的实型数值
        %md       设置域宽（位数）为m，m&gt;0左侧补空白，m&lt;0右侧补空白
                  m&lt;数字位数 按照实际位数输出
        %0md      设置域宽（位数）为m，m&gt;0左侧补0，m&lt;0右侧补0
                  m&lt;数字位数 按照实际位数输出
        %f        输出一个实数类型的数据（不能输出整形数据）默认输出6位小数 不足补0
        %.2f      输出2位小数
        %m.nf     m表示总的位数 n表示小数点后的位数 .也算一位 不足左补0
        %-m.nf    不足右补0
        %c        输出一个字符
        %s        输出一个字符串
        %o        以8进制输出一个数
        %x        以16进制输出一个数
        %p        输出一个变量的地址

scanf
    介绍
        包含在 stdio.h 中，用来接受键盘输入的内容，为阻塞式函数
    Tip
        C语言中，变量的地址可通过符号 &amp; 来获取，例如 &amp;a 表示变量a的地址
        可是控制符中 允许%mf，不允许%m.nf
        接受单个变量值时，输入值前，Tab 回车 都会被忽略
        scanf中如果是用了\n,在输入值后再次输入内控
    格式
        scanf(&quot;格式控制字符串&quot;,输入项地址列表)
    格式控制符
        %d          输入一个十进制整数
        %o          输入一个八进制整数
        %x          输入一个十六进制整数
        %i          输入一个有符号或无符号的十进制，八进制，十六进制整数
        %u          输入一个无符号十进制整数
        %f,e,E,g,G  输入一个小鼠形式或指数形式的浮点数
        %c          输入一个字符
        %s          输入一个字符串
    范例
        scanf(&quot;%d&quot;,&amp;age);
        scanf(&quot;%f,%f&quot;,&amp;a,&amp;b);

    修饰符
        域宽
        *        跳过输入，不复制给变量
        l,h      输入长整形，双精度型或短整形数据
    范例
        scanf(&quot;%d,%*d,%d&quot;,&amp;a,&amp;b);
</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><pre><code>功能分类
    算数运算符
        +      双目运算符，左结合性
        -      双目运算符，作为负值运算法时为单目运算符
        *      双目运算符，左结合性
        /      参与运算量均为整形时，结果为整型，如果有一个为实型，则结果为双精度实型
        %      求余，要求参与运算量均为整形
    关系运算符
    逻辑运算符
    按位运算符

按操作数运算符
    单目运算符      i++ ! sizeof 
    双目运算符      a+b
    三目运算符      a &gt; b ? 1 : 0

运算符表
    [C和C++运算符](https://zh.wikipedia.org/wiki/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90)

类型转换
    转换规则
        char|short -&gt; int -&gt; float -&gt; unsigned -&gt; long -&gt; double
    隐式转换
        int + float 时 int 隐式转换为float
    显式转换
        语法
            (要转换的类型)要转换的变量或表达式
        范例
            (int)f
            (int)(f + i)

sizeof
    作用
        以字节的形式给出操作数的存储大小，是操作符而不是函数
    Tip
        char类型常量为4个字节（存储时会转换为int类型数数字），char类型变量为1个字节。
        用于常量和变量时，可省略括号。
    语法
        sizeof(常量|变灵|数据类型)
    范例
        sizeof(1)
        sizeof(3.14f)      计算float类型值在内存中占用的字节
        sizeof(3.14)       计算double类型在内存中占用的字节
        sizeof 3.14
        sizeof(int)

逗号运算符
    格式
        表达式1,表达式2
    Tip
        逗号运算符可嵌套使用
        定义变量时无法使用逗号表达式
    范例
        a = (a+b,c+2)
    求值过程
        分别求每个表达式的值，并以最后表达式的值作为整个表达式的值

关系运算符
    真假性
        在C语言中所有的数值都有真假性，非0为真，关系运算符返回真或假
    关系运算符
        &gt;,&lt;,&gt;=,&lt;=,==,!=


逻辑表达式
    Tip
        逻辑表达式返回真或假
    逻辑运算符
        &amp;&amp;      与运算
        ||      或运算
        !       非运算

三木运算符
    格式
        表达式1 ? 表达式2 : 表达式3
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>分类
    库函数
    用户定义函数

自定义函数
    步骤
        定义 -&gt; 声明 -&gt; 调用
    格式
        返回值类型 函数名称(函数参数){
            函数体
        }
    函数声明作用
        告诉编译器被调函数已经存在和函数返回值类型，已便主调函数处理被调函数返回数据
    函数声明注意事项
        如果函数的返回类型为int，此时可以不用声明
        如果被调函数写在主调函数之前，此时可以不用声明
        可写成全局声明，声明在main函数之前

指针函数
    说明
        返回指针值的函数称为指针型函数
    格式
        类型说明符 * 函数名(形参表){
            函数体
            return 地址;
        }

函数指针
    说明
        函数名是函数所做占用内存去的首地址
        把函数首地址赋予一个指针变量，这个指向函数的指针变量称为函数指针变量。
        定义函数指针时，可省略形参名
    格式
        类型说明符(*变量名)(函数的参数);
    例子
        int sum(int x,int y){
            return x+y
        }; 
        int(*p)(int x,int y);
        p = sum;
        p(1,2);
</code></pre><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><pre><code>#include  文件包含
    Tip
        include实质为把文件内容拷贝至include语句位置
        不一定要写在第一行
    类型
        #include &lt;...&gt;    包含系统库
        #include &quot;...&quot;    包含用户定义的文件，可以是头文件也可以是普通文件
    文件搜索顺序
        #include &lt;...&gt;    编译器目录 -&gt; 系统目录
        #include &quot;...&quot;    当前目录 -&gt; 编译器目录 -&gt; 系统目录
    系统include目录
        /usr/include
        /usr/local/include
    Xcode 编译器目录
        /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/usr/include
    清除缓存两种方式
        Xcode菜单
            Product -&gt; Clean
        删除如下目录内缓存
            /Users/caozheng/Library/Developer/Xcode/DerivedData

#define  宏
    说明
        源程序在编译之前，犹预处理程序对我们写的源代码进行处理
        对源码中所有的宏名用宏定义中的字符串替换
        宏是预处理指令而非语句，所以不需要分号结束
        在字符串中出现的宏名不会被替换
        宏是有作作用域的，通过 #undef 可取消宏定义
        宏分为有参数和无参数两种
    无参数宏
        格式
            #define 表示符 字符串
        范例
            简单应用
                #define PI 3.14
            宏嵌套定义
                #define R 4
                #define PI 3.14
                #define AREA PI*R*R
            使用宏起别名
                #define INT int
                #define P struct Person
    有参数宏
        说明
            对带参数的宏，在调用中，不仅要宏展开，且要用实参代换形参
            有参宏定义中，形参之间可以出现空格，但是宏名和形参表之间不能有空格
        格式
            #define 宏名(形参表) 字符串
        范例
            #define SUM(a,b) a+b
            int main(){
                int resurt = SUM(3,4);
                return 0;
            }

条件编译
    #if #elif #else #endif
        说明
            按照不同的条件编译不同的程序部分，因而产生不同的目标代码文件
        格式
            #if 常量表达式
                程序段1
            #elif
                程序段2
            #else
                程序段3
            #endif
        范例
            #define I 0
            #if I == 1
                printf(&quot;OK&quot;);
            #else
                printf(&quot;NOTOK&quot;);
            #endif
    #ifdef
        说明
            判断某个宏是否定义
        范例
            #define DEBUGGER 1
            int main(){
                #ifdef DEBUGGER
                    printf(&quot;YES&quot;);
                #else
                    printf(&quot;NOT&quot;);
                #endif
                return 0;
            }
    #ifndef
        说明
            判断某个宏是否定义, 如果没有定义返回 真
        范例
            #define DEBUGGER 1
            int main(){
                #ifndef DEBUGGER
                    printf(&quot;YES&quot;);
                #else
                    printf(&quot;NOT&quot;);
                #endif
                return 0;
            }
</code></pre><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><pre><code>Tip
    计算机存储的二进制数据为补码
    为了计算机电路设计简洁，计算机只能计算加法，所以引入补码

各进制格式
    2进制       0b00101
    8进制       045
    16进制      0xaf0d

源码反码补码
    源码
        正数: 一个数绝对值的二进制表示，最高位(最左侧)为0
        负数: 一个数绝对值的二进制表示，最高位(最左侧)为1
    反码
        正数: 和源码相同
        负数: 除符号位不变，其他逐位取反(1-&gt;0,0-&gt;1)
    补码
        正数: 和源码相同
        负数: 反码 + 1

位运算符
    &amp;     按位与　     同1为1, 有0为0
    |     按位或　     有1为1
    ~     按位取反     1-&gt;0, 0-&gt;1
    ^     按位异或     相同为0, 不通为1
    &gt;&gt;    右移位　     每一位向右移动n位, 高位补符号位, 低位丢弃,
    &lt;&lt;    左移位　     每一位向左移动n位, 高位丢弃, 低位补0, 正数时相当原数*2的n次方

内存地址
    内存忧若干个1Byte的内存单元构成，每个内存单元有唯一的地址
    计算机分配内存时，由高地址向低地址分配
    两个连续定义的变量的内存地址不一定是连续的
    值在内存中存储时，二进制低位存储在低地址，高位存储在高地址
    &amp;获取的是变量的首地址(变量在内存中占用的存储单元地址最小的地址)
    可用符号*获取内存地址中的字节 
</code></pre><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><pre><code>三种内存分配方式
    从静态存储区分配
        内存在程序编译时就已经分配好，这块内存仔程序运行期间始终存在
        例如全局变量,static变量。
    在栈上创建
        在执行函数时，函数内部局部变量的存储单元都可以在栈上创建。函数之行后释放。
        栈内存分配运算内治愈处理器指令集中，效率很高，但分配的内存容量有限
    从堆上分配，亦称为动态内存分配
        程序仔运行过程中使用malloc或new申请任人意多少的内存，
        程序议案自己负责在何时使用free或delete释放内存。

内存分区（高地址向低地址排序）
    栈       运行时分配    存放程序临时创建的临时变量 
    堆       运行时分配    存放被动态分配的内存段
    BSS端    编译器分配    存放未初始化的全局变量和静态变量
    数据段    编译器分配    存放已经初始化的全局变量和静态变量和字符串常量等
    代码段    编译器分配    存放程序执行的编译后的代码

动态内存分配函数
    malooc
        说明
            包含在stdlib.h中，在内存的堆区分配一个大小为size的连续内存空间。
            如果分配成功，函数返回心分配内存的首地址，否则返回NULL 
            malooc申请的空间如果不赋值，存放的是垃圾数
        格式
            void * malloc(unsigned size)
        范例
            int *p = (int *)malloc(4 * sizeof(int));
    calloc
        说明
            分配制定长度和块数的内存空间。
            如果申请的空间如果不赋值，会初始化为0
        格式
            void * calloc(内存块数, 长度)
        范例
            int *p = (int *)calloc(4, sizeof(int));
    realloc
        说明
            可以给已经存在的空间扩充大小
            会先检测和原内存空间是否有足够相邻空间，如果没有则把原数据重新分配新内存空间
        格式
            void * calloc(内存地址, 长度)
        范例
            int *p = (int *)malloc(4 * sizeof(int));
            p = realloc(p, 10 * sizeof(int));

内存泄漏
    说明
        在函数内通过malooc申请的空间如果在函数释放时不释放，会造成内存泄露
    free
        作用
            释放内存空间，包含子啊stdlib.h头文件中
        格式
            free(要释放的空间首地址)
</code></pre><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><pre><code>说明
    文件是指存储在外部介质上数据的集合，这个数据集有一个名称叫文件名

文件的分类
    用户角度分类
        普通文件
        设备文件
    文件编码方式分类
        ASCII码文件
        二进制文件

文件操作步骤
    1. 引入头文件 stdio.h
    2. 定义文件指针
    3. 打开文件
    4. 文件读写
    5. 关闭文件

文件读写函数
    fgetc   fputc      字符读写函数
    fgets   fputs      字符串读写函数
    freed   fwrite     数据块读写函数
    fscanf  fprintf    格式化读写函数

文件指针
    说明
        在C语言中用一个指针变量指向一个文件，这个指针称为文件指针
    格式
        FILE *指针变量标识符;
    范例
        FILE *fp = NULL;

文件打开 fopen
    格式
        文件指针变量名 = fopen(文件名,操作方式);
        操作方式
            r      打开一个已存在文件，只能读取数据
            w      创建一个新文件，只能写入数据，如文件存在则删除后新建
            a      打开一个已存在的文件，并在文件末尾追加数据，文件不存在则新建
            r+     打开一个已存在文件，读写数据
            w+     创建一个新文件，读写数据，如文件存在则删除后新建
            a+     等价与a，并可读取数据
            t      打开一个文本文件
            b      打开一个二进制文件
    范例
        FILE *fp = NULL;
        fp = fopen(&quot;a.txt&quot;,&quot;r&quot;);

文件关闭 fclose
    格式
        fclose(文件指针);
    范例
        FILE *fp = NULL;
        fp = fopen(&quot;a.txt&quot;,&quot;r&quot;);
        fclose(fp);

字符写入函数 fputc
    说明
        fputc可把一个字符写入到文件中
        字符读写函数是以字节问单位的读写函数，每次从文件写入一个字符
    格式
        fputc(字符,文件指针);
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;a+&quot;);
        fputc(&apos;a&apos;, fp);

字符读取函数 fgetc
    说明
        读取一个字符到变量中
        字符读写函数是以字节问单位的读写函数，每次从文件读取一个字符
    格式
        fgetc(文件指针);
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;r&quot;);
        printf(&quot;%c\n&quot;,fgetc(fp));

字符串写入函数 fputs
    说明
        该函数是一个文件操作相关函数，可把字符串输出到指定文件中
        函数执行后返回写入字符串的长度
    格式
        fputs(字符串,文件指针);
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;a+&quot;);
        fputs(&quot;ABCDE&quot;, fp);

字符串读取函数 fgets
    说明
        该函数是一个文件操作相关函数，也可从键盘接受字符串保存至变量中
        scanf无法接受字符串，gets因为不限制字符串长度不安全
        使用fgets时，会依据字符串变量长度做限制，并在结尾保存 \0
        当遇到 \n 或者 EOF 时，读取结束
        使用stdin时，当输入字符串长度小于数组长度时，fgets会接受回车符
    格式
        char* fgets(char＊ s, int n, FILE* fp);
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;r&quot;);
        char ch[10];
        fgets(ch, sizeof(ch), fp);

数据块读取函数 fread
    说明
        用于整块数据的读取
    格式
        fread(buffer,size,count,fp)
        buffer   是一个指针，在fread函数中表示存放输入数据的首地址
        size     表示数据块的字节数 
        count    表示读取多少块 
        fp       文件指针
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;r&quot;);
        char str[10];
        fread(str, sizeof(str), 1, fp);

数据块写入函数 fwrite
    说明
        用于整块数据的写入
    格式
        fwrite(buffer,size,count,fp)
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;w&quot;);
        char str[] = &quot;Hello World!&quot;;
        fwrite(str, sizeof(str), 1, fp);

格式化读取函数 fscanf
    说明
        与scanf类似，接受的对象的磁盘文件
    格式
        fscanf(文件指针,格式化字符串,输入列表);
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;r&quot;);
        int a,b;
        fscanf(fp,&quot;%d----%d&quot;,&amp;a,&amp;b);

格式化写入函数 fprintf
    说明
        与printf类似，输出对象是磁盘文件
    格式
        fprintf(文件指针,格式化字符串,输出列表);
    范例
        FILE *fp = fopen(&quot;tmp.txt&quot;, &quot;w&quot;);
        int a = 1,b = 2;
        fprintf(fp,&quot;%d----%d&quot;,a,b);

文件定位
    rewind
        说明
            移动文件指针至文件头
        格式
            rewind(FILE *)
    fseek
        说明
            移动文件至指定位置
        格式
            fseek(文件指针,位移量,起始点);
                位移量    移动的字节数,long类型数据
                起始点    表示从何处计算位移量
                    文件起始   SEEK_SET  0
                    当前位置   SEEK_CUR  1
                    文件末尾   SEEK_END  2

文件监测函数 
    feof
        说明
            监测文件是否处于文件结束的位置，如果结束返回1，否则返回0
        格式
            feof(FILE *);
    ferror
        说明
            判断文件是否读取出错
        格式
            ferror(FILE *);
</code></pre><h2 id="终端编译"><a href="#终端编译" class="headerlink" title="终端编译"></a>终端编译</h2><pre><code>cc -c &lt;file&gt;  编译文件，生成 file.o 文件
cc &lt;file.o&gt;   连接，生成 file.out 可执行文件
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/26/Git-笔记/" itemprop="url">
                  Git-笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-26T15:47:52+08:00" content="2016-05-26">
              2016-05-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><pre><code>https://git-scm.com/book/zh/v2/
</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>/etc/gitconfig
    包含系统上每一个用户及他们仓库的通用配置。
    如果使用带有 --system 选项的 git config 时，它会从此文件读写配置变量。
~/.gitconfig 或 ~/.config/git/config
    只针对当前用户。 可以传递 --global 选项让 Git 读写此文件。
.git/config
    当前使用仓库的 Git 目录中的 config 文件：针对该仓库。
</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>设置用户和邮箱
    git config --global user.name &quot;CaoZheng&quot;
    git config --global user.email &quot;7760442@gmail.com&quot;
设置默认编辑器
    git config --global core.editor emacs
列出所有配置
    git config --list
查看某项配置
    git config &lt;key&gt;
</code></pre><h2 id="获取命令帮助"><a href="#获取命令帮助" class="headerlink" title="获取命令帮助"></a>获取命令帮助</h2><pre><code>git help &lt;verb&gt;
git &lt;verb&gt; --help
man git-&lt;verb&gt;
</code></pre><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><pre><code>mkdir repository
cd repository
git init
</code></pre><h2 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h2><pre><code>git add file.txt
</code></pre><h2 id="重置文件状态"><a href="#重置文件状态" class="headerlink" title="重置文件状态"></a>重置文件状态</h2><pre><code>git reset HEAD &lt;file&gt;   取消暂存文件
git reset --hard HEAD^  回退到上个版本
    HEAD表示当前版本，上一个版本是HEAD^，上上一个版本是HEAD^^，上100个版本可写成HEAD~100。
</code></pre><h2 id="转换分支或恢复文件"><a href="#转换分支或恢复文件" class="headerlink" title="转换分支或恢复文件"></a>转换分支或恢复文件</h2><pre><code>git checkout -- &lt;file&gt;  撤销对未暂存文件的修改
</code></pre><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><pre><code>git rm     把文件从暂存区域移除并删除本地文件
git rm -f  强制删除缓存区中已经修改过的文件
git rm --cached   从缓存区删除，但不删除本地文件
git rm log/\*.log  删除log目录下所有.log结尾的文件
</code></pre><h2 id="移动文件和改名"><a href="#移动文件和改名" class="headerlink" title="移动文件和改名"></a>移动文件和改名</h2><pre><code>git mv file_from file_to
    相当于连续行如下三个命令的
    mv README.md README
    git rm README.md
    git add README
</code></pre><h2 id="提交文件到仓库"><a href="#提交文件到仓库" class="headerlink" title="提交文件到仓库"></a>提交文件到仓库</h2><pre><code>git commit  提交文件并打开默认编辑器编辑提交说明
    -m &quot;commit description&quot;  提交时在命令中添加说明
    -a  跳转 git add  直接提交
    --amend  替换上一次提交
</code></pre><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><pre><code>git status     查看仓库当前的状态  如哪些文件被修改过
git diff --cached  查看已暂存的将要添加到下次提交里的内容
git diff --staged  查看已暂存的将要添加到下次提交里的内容（新版）
git status -s  简短状态描述
    ?? 新添加的未跟踪文件
    A  新添加到暂存区中的文件
    M  修改过的文件前面有
    M  左边的M表示该文件被修改了但是还没放入暂存区，
     M 右边的M表示该文件被修改了并放入了暂存区。
</code></pre><h2 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h2><pre><code>git diff    对比文件 可查看文件修改内容
git diff --cached  查看已经暂存起来的变化
git diff --staged  查看已经暂存起来的变化（新版）
</code></pre><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><pre><code>.gitignore  此文件中包含无需纳入Git的管理，也不出现在未跟踪文件的文件列表
    所有空行或者以 ＃ 开头的行都会被 Git 忽略。
    可以使用标准的 glob 模式匹配。
    匹配模式可以以（/）开头防止递归。
    匹配模式可以以（/）结尾指定目录。
    要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
glob 模式 指 shell 所使用的简化了的正则表达式
    *     匹配零个或多个任意字符；
    [abc] 匹配任何一个列在方括号中的字符
    ?     匹配一个任意字符；
    [0-9] 匹配所有 0 到 9 的数字
    **    匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。
</code></pre><h2 id="查看Log"><a href="#查看Log" class="headerlink" title="查看Log"></a>查看Log</h2><pre><code>git log       查看最近到最远的提交日志
    -p                按补丁格式显示每个更新之间的差异。
    --stat            显示每次更新的文件修改统计信息。
    --shortstat       只显示 --stat 中最后的行数修改添加移除统计。
    --name-only       仅在提交信息后显示已修改的文件清单。
    --name-status     显示新增、修改、删除的文件清单。
    --abbrev-commit   仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。
    --relative-date   使用较短的相对时间显示（比如，“2 weeks ago”）。
    --graph           显示 ASCII 图形表示的分支合并历史。
    --pretty  使用其他格式显示历史提交信息
        --pretty=oneline  只显示id和注释
        --pretty=short
        --pretty=full
        --pretty=fuller
        --pretty=format:&quot;%h - %an, %ar : %s&quot;  定制要显示的记录格式
            %H   提交对象（commit）的完整哈希字串
            %h   提交对象的简短哈希字串
            %T   树对象（tree）的完整哈希字串
            %t   树对象的简短哈希字串
            %P   父对象（parent）的完整哈希字串
            %p   父对象的简短哈希字串
            %an  作者（author）的名字
            %ae  作者的电子邮件地址
            %ad  作者修订日期（可以用 --date= 选项定制格式）
            %ar  作者修订日期，按多久以前的方式显示
            %cn  提交者(committer)的名字
            %ce  提交者的电子邮件地址
            %cd  提交日期
            %cr  提交日期，按多久以前的方式显示
            %s   提交说明
    -(n)              仅显示最近的 n 条提交
    --since, --after  仅显示指定时间之后的提交
    --until, --before 仅显示指定时间之前的提交
    --author          仅显示指定作者相关的提交
    --committer       仅显示指定提交者相关的提交
    --grep            仅显示含指定关键字的提交
    -S                仅显示添加或移除了某个关键字的提交
</code></pre><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><pre><code>git remote  会列出你指定的每一个远程服务器的简写
    -v      显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL
    add &lt;shortname&gt; &lt;url&gt;  添加远程仓库并指定简写
    show [remote-name]  查看更多信息
    rename &lt;old_name&gt; &lt;new_name&gt;  修改一个远程仓库的简写名
    rm &lt;remote-name&gt;  移除远程库
git clone   克隆了一个仓库，默认rigin为简写
git pull    从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。
git fetch &lt;remote-name&gt;  从远程仓库中获得数据,但不会自动合并或修改你当前的工作
git push [remote-name] [branch-name] [tagname] 推送到上游仓库
</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre><code>git tag  列出所有标签
    -l &lt;reg&gt;    查看包含特定字符的标签
    &lt;tagname&gt;   创见简单标签
    -a &lt;tagname&gt; -m &lt;msg&gt;  创建附注标签并添加信息
    -a &lt;tagname&gt; -m &lt;msg&gt; &lt;commit&gt; 对过去的提交创建附注标签并添加信息
git show &lt;tagname&gt;  查看标签与对应的提交信息
git push origin &lt;tagname&gt;  共享标签
git checkout -b &lt;branchname&gt; &lt;tagname&gt;  在特定的标签创建一个新分支
</code></pre><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><pre><code>设置别名例子
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.ci commit
    git config --global alias.st status
    git config --global alias.unstage &apos;reset HEAD --&apos;
    git config --global alias.last &apos;log -1 HEAD&apos;
使用别名
    git co
    git br
    git ci
    git st
    git unstage
    git last
设置外部命令的别名，需在命令前面加入 ! 符号
    git config --global alias.visual &apos;!gitk&apos;
</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre><code>查看分支
    git branch
        -v   查看每个分支的最后一次提交
        -vv  查看更详细的分支信息，包括跟踪的远程分支，是否领先或落后等。
        --merged     查看所有已经合并的分支
        --no-merged  查看所有包含未合并工作的分支
    git log --oneline --decorate   查看各个分支所指向的对象
    git log --oneline --decorate --graph --all   查看提交历史、各个分支的指向以及项目的分支分叉情况

创建切换分支
    git branch &lt;branchname&gt;        创建分支
    git checkout &lt;branchname&gt;      切换分支
    git checkout -b &lt;branchname&gt;   创建分支时同时切换分支

合并分支
    git merge &lt;branchname&gt;  合并 branchname分支 到当前分支
    git merge &lt;remote-name&gt;/&lt;branchname&gt;  合并远程分支到当前分支

删除分支
    git branch -d &lt;branchname&gt;   删除本地分支
    git push [remote-name] --delete [branch-name]  删除远程分支

远程分支
    git ls-remote &lt;remote-name&gt;     获取远程仓库的分支列表
    git remote show &lt;remote-name&gt;   获得远程分支的更多信息
    git push [remote-name] [branch-name][:other-branch-name] 推送本地分支到远程仓库上另外的分支
    git checkout --track origin/serverfix  创建跟踪分支
    git checkout -b [branch] [remotename]/[branch]  创建跟踪分支并设定本地分支为不同的名字
    git branch -u origin/serverfix  设置已有的本地分支跟踪一个刚刚拉取下来的远程分支
    git pull         从跟踪分支中拉取文件，与fetch的区别是拉去文件后会自动merge
    git fetch --all  抓取所有远程仓库，与pull的区别是拉去后不会merge

    Tip: 可通过 @{upstream} 或 @{u} 引用已跟踪的上游分支

变基
    git rebase &lt;branch-name&gt;  把目标分支上修改的内容，添加到现有的分支
        --continue  解决冲突并add至缓存区后，完成变基
        --abort     终止变基，让当前分支回到变基前的状态
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Cao Zheng" />
          <p class="site-author-name" itemprop="name">Cao Zheng</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cao Zheng</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
